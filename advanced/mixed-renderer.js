webpackJsonp([12,15],{1e3:function(s,a){s.exports={content:'<p>如果直接写 JSX 来渲染 VM 是会出错的，因为 JSX 语法会被解析成 <code>React.createElement</code>，这就是为什么我们在使用 JSX 的时候，必须要 import React。</p>\n<pre><code class="hljs language-js" data-query="{}" data-lang="js">&#x3C;h1>hi&#x3C;<span class="hljs-regexp">/h1>\n/</span><span class="hljs-regexp">/ ->\nReact.createElement(\'h1\', null, \'h1\')</span></code></pre>\n<p>而这个转换是由 babel 来完成的，只需要修改 <code>babel-plugin-transform-react-jsx</code> 的配置即可，当然需要先安装它啦。</p>\n<pre><code class="hljs language-js" data-query="{}" data-lang="js"><span class="hljs-string">"plugins"</span>: [\n  [\n    <span class="hljs-string">"transform-react-jsx"</span>, {\n      <span class="hljs-string">"pragma"</span>: <span class="hljs-string">"h"</span>\n    }\n  ]\n]</code></pre>\n<p>这样，JSX 就会转换过程如下：</p>\n<pre><code class="hljs language-js" data-query="{}" data-lang="js">&#x3C;h1>hi&#x3C;<span class="hljs-regexp">/h1>\n/</span><span class="hljs-regexp">/ ->\nh(\'h1\', null, \'h1\')</span></code></pre>\n<p>于是我们可以直接用 JSX 来渲染 VM</p>\n<pre><code class="hljs language-js" data-query="{}" data-lang="js"><span class="hljs-keyword">const</span> VM = Model.create()\nrender(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">VM</span> /></span>)\n\n// 注意：下面会有错\n// 因为 transform-react-jsx 认为小写字母开头的标志符表示为HTML标签\nconst vm = Model.create()\nrender(</span>&#x3C;vm /><span class="xml">) // -> h(\'vm\', null)</span></code></pre>\n<p>综合上面的原因，我们建议还是直接使用 <a href="/api/others#h"><code>h</code></a> 方法来渲染 VM 更为方便。</p>\n',extra:{}}}});
//# sourceMappingURL=mixed-renderer.js.map