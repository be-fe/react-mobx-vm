{"version":3,"sources":["webpack:///guide/contrast.js","webpack:///./docs/snippets/vm/Todo/index.js","webpack:///./docs/snippets/mst/components/Todo.js","webpack:///./docs/snippets/mst/components/TodoList.js","webpack:///./docs/snippets/mst/models/TodoStore.js","webpack:///./docs/snippets/vm/Todo/View.js","webpack:///./docs/snippets/vm/TodoList/View.js","webpack:///./docs/snippets/vm/TodoList/index.js","webpack:///../~/picidae/~/timers-browserify/main.js","webpack:///../~/mobx-state-tree/dist/mobx-state-tree.js","webpack:///./docs/guide/contrast.md","webpack:///../~/setimmediate/setImmediate.js"],"names":["webpackJsonp","241","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_initDefineProp","target","property","descriptor","context","Object","defineProperty","enumerable","configurable","writable","value","initializer","call","_applyDecoratedDescriptor","decorators","desc","forEach","key","slice","reverse","reduce","decorator","undefined","_dec","_class","_class2","_descriptor","_descriptor2","_descriptor3","_classCallCheck2","_classCallCheck3","_createClass2","_createClass3","_possibleConstructorReturn2","_possibleConstructorReturn3","_inherits2","_inherits3","_reactMobxVm","_View","_View2","Todo","bindView","_Root","_ref","_temp","_this","_ret","this","_len","arguments","length","args","Array","_key","__proto__","getPrototypeOf","apply","concat","finished","Root","prototype","observable","Math","random","action","getOwnPropertyDescriptor","370","_interopRequireWildcard","newObj","hasOwnProperty","_mobxReact","_react","React","observer","todo","createElement","type","checked","onClick","toggle","title","371","TodoList","_mobx","_Todo","_React$Component","handleChange","e","newTodoTitle","handleNewTodoClick","stopPropagation","props","todoStore","addTodo","onChange","todos","map","id","unfinishedTodoCount","Component","372","TodoStore","_mobxStateTree","types","model","optional","number","string","actions","self","array","views","filter","push","373","stateless","local","bind","374","binding","data-bind","h","375","_Todo2","create","get","computed","391","global","Timeout","clearFn","_id","_clearFn","Function","setTimeout","window","clearTimeout","setInterval","clearInterval","timeout","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","setImmediate","clearImmediate","996","getType$$1","object","getStateTreeNode$$1","getChildType$$1","child","getChildType","onPatch$$1","callback","onPatch","onSnapshot$$1","onSnapshot","applyPatch$$1","patch","applyPatches","asArray","recordPatches$$1","subject","resume","disposer","inversePatch","recorder","rawPatches","patches","_a","a","inversePatches","b","stop","replay","undo","protect$$1","node","isRoot","fail","isProtectionEnabled","unprotect$$1","isProtected$$1","isProtected","applySnapshot$$1","snapshot","applySnapshot","getSnapshot$$1","hasParent$$1","depth","parent","getParent$$1","d","storedValue","getRoot$$1","root","getPath$$1","path","getPathParts$$1","splitJsonPath$$1","isRoot$$1","resolvePath$$1","resolveNodeByPath$$1","resolveIdentifier$$1","identifier$$1","identifierCache","resolve","tryResolve$$1","getRelativePath$$1","base","getRelativePathBetweenNodes$$1","clone$$1","source","keepEnvironment","_environment","detach$$1","detach","destroy$$1","die","removeChild","subpath","isAlive$$1","isAlive","addDisposer$$1","addDisposer","getEnv$$1","env","EMPTY_OBJECT","walk$$1","processor","getChildren","isStateTreeNode$$1","__extends","__","constructor","extendStatics","__rest","s","t","p","indexOf","getOwnPropertySymbols","i","__decorate","c","r","Reflect","decorate","isType$$1","isType","createActionTrackingMiddleware","hooks","runningActions","Map","next","onStart","onResume","set","async","res","onSuspend","onSuccess","onFail","rootId","delete","serializeArgument","actionName","index","arg","Date","$MST_DATE","getTime","isPrimitive","serializeTheUnserializable","name","isPlainObject","isArray","JSON","stringify","deserializeArgument","adm","baseType","$MST_UNSERIALIZABLE","applyAction$$1","mobx","runInAction","action$$1","baseApplyAction","resolvedTarget","v","recordActions$$1","onAction$$1","listener","attachAfter","fireListener","rawCall","sourceNode_1","addMiddleware$$1","getNextActionId$$1","nextActionId","runWithActionContext$$1","fn","baseIsRunningAction","_isRunningAction","prevContext","currentActionContext","assertAlive","runMiddleWares","getActionContext$$1","createActionInvoker$$1","argsToArray","tree","parentId","middleware","addMiddleWare","decorate$$1","$mst_middleware","collectMiddlewareHandlers","baseCall","handlers","EMPTY_ARRAY","n","middlewares","originalFn","runNextMiddleware","handler","safeStringify","prettyPrintValue$$1","toErrorString","error","fullPath","join","pathPrefix","currentTypename","isSnapshotCompatible","is","message","isPrimitiveType$$1","describe","getContextForPath$$1","typeCheckSuccess$$1","typeCheckFailure$$1","flattenTypeErrors$$1","errors","typecheck$$1","typecheckPublic$$1","validate","createNode$$1","environment","initialValue","createNewInstance","finalizeNewInstance","identity","noop","targetNode","$treenode","setParent","shouldAttachNode","ObjectNode$$1","finalizeCreation","ScalarNode$$1","isNode$$1","toJSON$$1","baseParts","targetParts","common","doubleDot","joinJsonPath$$1","failIfResolveFails","resolveNodeByPathParts$$1","pathParts","current","getChildNode","process$1$$1","asyncAction","deprecated","DEPRECATION_MESSAGE","flow","Error","_","val","isObservableArray","extend","_i","proto","isMutable","RegExp","isSerializable","addHiddenFinalProp","propName","addReadOnlyProp","remove","collection","idx","splice","registerEventHandler","createFlowSpawner","generator","spawner","wrap","runId","baseContext","Promise","reject","onFulfilled","ret","gen","onRejected","err","throw","done","then","init","splitPatch$$1","stripPatch$$1","invertPatch","op","oldValue","escapeJsonPath$$1","str","replace","unescapeJsonPath$$1","parts","split","mapToString$$1","size","put","targetType","subType","identifierAttribute","identifier","map$$1","subtype","MapType$$1","arrayToString$$1","array$$1","ArrayType$$1","reconcileArrayChildren","childType","oldNodes","newValues","newPaths","oldNode","newValue","hasNewNode","oldMatch","areSame","valueAsNode","j","childNode_1","childNode_2","reconcile","childNode","instantiate","objectTypeToString","toString","toPropertiesObject","properties","keys","HOOK_NAMES","assign","optional$$1","getPrimitiveFactoryFromValue$$1","model$$1","shift","ModelType$$1","compose$$1","typeName","prev","cur","cloneAndEnhance","initializers","named","string$$1","number$$1","boolean$$1","DatePrimitive$$1","flags","TypeFlags$$1","String","Number","Boolean","literal$$1","Literal$$1","refinement$$1","predicate","Refinement$$1","enumeration$$1","options","realOptions","union$$1","option","dispatchOrType","otherTypes","dispatcher","Union$$1","defaultValueOrFunction","OptionalValue$$1","maybe$$1","optionalNullType","late$$1","nameOrType","maybeType","Late$$1","reference$$1","CustomReferenceType$$1","IdentifierReferenceType$$1","IdentifierType$$1","setPrototypeOf","canAttachTreeNode","_autoUnbox","state","NodeLifeCycle$$1","INITIALIZING","_parent","unbox","sawException","CREATED","DEAD","newParent","getValue","getSnapshot","nextNodeId","nodeId","preboot","IdentifierCache$$1","addNodeToCache","fireHook","snapshotDisposer","reaction","emitSnapshot","onError","mergeCache","isRunningAction","assertWritable","FINALIZED","DETACHING","splitCache","disposers","snapshotSubscribers","patchSubscribers","applyPatchLocally","aboutToDie","finalizeDeath","f","notifyDied","oldPath","emitPatch","basePatch","localizedPatch","substr","patch_1","reversePatch_1","unshift","ComplexType$$1","getDefaultSnapshot","isAssignableFrom","isValidSnapshot","newNode","Type$$1","_super","cache","has","shallowArray","values","nodes","basePath","matches","candidate","freeze","ids","shallowMap","instance","extras","interceptReads","intercept","willChange","observe","didChange","change","verifyIdentifier","expected","oldSnapshot","currentKeys","getAdministration","dehancer","peek","parseInt","childNodes","index_1","removedCount","added","removed","addedCount","PRE_PROCESS_SNAPSHOT","afterCreate","afterAttach","postProcessSnapshot","beforeDetach","beforeDestroy","defaultObjectOptions","opts","shallowObject","forAllProps","extendShallowObservable","test","propertiesNames","preProcessor","actionInitializer","instantiateActions","baseAction","specializedAction_1","volatile","stateInitializer","instantiateVolatileState","rest","instantiateViews","viewInitializer","isComputed","$mobx","setter","tmp","preProcessSnapshot","currentPreprocessor","applySnapshotPreProcessor","getAtom","reportObserved","CoreType$$1","checker","nullType$$1","Null","undefinedType$$1","Undefined","Literal","Refinement","inst","subtypeErrors","result","Union","some","factory","determineType","applicableTypes","errorArray","defaultValue","Optional","getDefaultValue","defaultSnapshot","definition","_subType","Late","Frozen$$1","Frozen","finalValue","frozen$$1","StoredReference","mode","BaseReferenceType$$1","Reference","targetMode","newIdentifier","identifierType","Identifier","enumeration","compose","reference","union","literal","maybe","refinement","boolean","frozen","late","null","typecheck","escapeJsonPath","unescapeJsonPath","addMiddleware","process","isStateTreeNode","applyAction","onAction","recordActions","getType","applyPatch","recordPatches","protect","unprotect","hasParent","getParent","getRoot","getPath","getPathParts","resolvePath","resolveIdentifier","tryResolve","getRelativePath","clone","destroy","getEnv","walk","1010","content","extra","transformer-react-render","list","editable","placement","pkg","react","react-dom","mobx-react","../snippets/mst/models/TodoStore","../snippets/mst/components/TodoList","react-mobx-vm","../snippets/vm/TodoList","../snippets/vm/Todo","1113","task","tasksByHandle","nextHandle","registerImmediate","handle","run","runIfPresent","currentlyRunningATask","installNextTickImplementation","nextTick","canUsePostMessage","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","installPostMessageImplementation","messagePrefix","onGlobalMessage","event","data","addEventListener","attachEvent","installMessageChannelImplementation","channel","MessageChannel","port1","port2","installReadyStateChangeImplementation","html","doc","documentElement","script","onreadystatechange","appendChild","installSetTimeoutImplementation","document","attachTo"],"mappings":"AAAAA,cAAc,EAAE,KAEVC,IACA,SAAUC,EAAQC,EAASC,GAEhC,YA+BA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAQC,EAAUC,EAAYC,GAChDD,GACLE,OAAOC,eAAeL,EAAQC,GAC5BK,WAAYJ,EAAWI,WACvBC,aAAcL,EAAWK,aACzBC,SAAUN,EAAWM,SACrBC,MAAOP,EAAWQ,YAAcR,EAAWQ,YAAYC,KAAKR,GAAW,SAI3E,QAASS,GAA0BZ,EAAQC,EAAUY,EAAYX,EAAYC,GAC3E,GAAIW,KAyBJ,OAxBAV,QAAkB,KAAEF,GAAYa,QAAQ,SAAUC,GAChDF,EAAKE,GAAOd,EAAWc,KAEzBF,EAAKR,aAAeQ,EAAKR,WACzBQ,EAAKP,eAAiBO,EAAKP,cAEvB,SAAWO,IAAQA,EAAKJ,eAC1BI,EAAKN,UAAW,GAGlBM,EAAOD,EAAWI,QAAQC,UAAUC,OAAO,SAAUL,EAAMM,GACzD,MAAOA,GAAUpB,EAAQC,EAAUa,IAASA,GAC3CA,GAECX,GAAgC,SAArBW,EAAKJ,cAClBI,EAAKL,MAAQK,EAAKJ,YAAcI,EAAKJ,YAAYC,KAAKR,GAAW,OACjEW,EAAKJ,YAAcW,QAGI,SAArBP,EAAKJ,cACPN,OAA4B,eAAEJ,EAAQC,EAAUa,GAChDA,EAAO,MAGFA,EAnETV,OAAOC,eAAeZ,EAAS,cAC7BgB,OAAO,IAEThB,EAAQK,QAAUuB,MAElB,IAgBIC,GAAMC,EAAuBC,EAASC,EAAaC,EAAcC,EAhBjEC,EAAmBlC,EAAoB,IAEvCmC,EAAmBlC,EAAuBiC,GAE1CE,EAAgBpC,EAAoB,IAEpCqC,EAAgBpC,EAAuBmC,GAEvCE,EAA8BtC,EAAoB,IAElDuC,EAA8BtC,EAAuBqC,GAErDE,EAAaxC,EAAoB,IAEjCyC,EAAaxC,EAAuBuC,GC1BzCE,EAAA1C,EAAA,IACA2C,EAAA3C,EAAA,KDiCK4C,EAAS3C,EAAuB0C,GC9BhBE,GD6ERjB,GC9EZ,EAAAc,EAAAI,UAAAF,EAAAxC,SD8E+DwB,GAAeE,EAAU,SAAUiB,GAGhG,QAASF,KACP,GAAIG,GAEAC,EAAOC,EAAOC,GAElB,EAAIhB,EAAiB/B,SAASgD,KAAMP,EAEpC,KAAK,GAAIQ,GAAOC,UAAUC,OAAQC,EAAOC,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAC3EF,EAAKE,GAAQJ,UAAUI,EAGzB,OAAeT,GAASC,GAAQ,EAAIX,EAA4BnC,SAASgD,MAAOJ,EAAOH,EAAKc,WAAajD,OAAOkD,eAAef,IAAO5B,KAAK4C,MAAMb,GAAOI,MAAMU,OAAON,KAAiBnD,EAAgB6C,EAAO,KAAMnB,EAAamB,GAAQ7C,EAAgB6C,EAAO,QAASlB,EAAckB,GAAQ7C,EAAgB6C,EAAO,WAAYjB,EAAciB,GAAxUC,EAAgVF,GAAQ,EAAIV,EAA4BnC,SAAS8C,EAAOC,GASjZ,OAtBA,EAAIV,EAAWrC,SAASyC,EAAME,IAgB9B,EAAIV,EAAcjC,SAASyC,IACzBvB,IAAK,SACLP,MAAO,WC3FRqC,KAAKW,UAAYX,KAAKW,aD+FhBlB,GACPH,EAAasB,MAAQjC,EAAcb,EAA0BY,EAAQmC,UAAW,MAAOvB,EAAawB,aACpGtD,YAAY,EACZI,YAAa,WACX,MCvGcmD,MAAKC,YDyGnBpC,EAAed,EAA0BY,EAAQmC,UAAW,SAAUvB,EAAawB,aACrFtD,YAAY,EACZI,YAAa,WACX,MC3GiB,MD6GjBiB,EAAef,EAA0BY,EAAQmC,UAAW,YAAavB,EAAawB,aACxFtD,YAAY,EACZI,YAAa,WACX,OC/GoB,KDiHpBE,EAA0BY,EAAQmC,UAAW,UAAWvB,EAAa2B,QAAS3D,OAAO4D,yBAAyBxC,EAAQmC,UAAW,UAAWnC,EAAQmC,WAvCpFpC,EAuCiGC,KAAaD,EAClL9B,GAAQK,QCrHYyC,EDsHpB/C,EAAOC,QAAUA,EAAiB,SAI7BwE,IACA,SAAUzE,EAAQC,EAASC,GAEhC,YAaA,SAASwE,GAAwBtE,GAAO,GAAIA,GAAOA,EAAIC,WAAc,MAAOD,EAAc,IAAIuE,KAAa,IAAW,MAAPvE,EAAe,IAAK,GAAIoB,KAAOpB,GAAWQ,OAAOuD,UAAUS,eAAezD,KAAKf,EAAKoB,KAAMmD,EAAOnD,GAAOpB,EAAIoB,GAAgC,OAAtBmD,GAAOrE,QAAUF,EAAYuE,EAXlQ/D,OAAOC,eAAeZ,EAAS,cAC7BgB,OAAO,IAEThB,EAAQ8C,KAAOlB,MEtIhB,IAAAgD,GAAA3E,EAAA,KACA4E,EAAA5E,EAAA,GAAY6E,EF2ICL,EAAwBI,EEzIxB/B,SAAO,EAAA8B,EAAAG,UAAS,SAAA9B,GAAA,GAAG+B,GAAH/B,EAAG+B,IAAH,OAC3BF,GAAAG,cAAA,UACEH,EAAAG,cAAA,SACEC,KAAK,WACLC,QAASH,EAAKhB,SACdoB,QAASJ,EAAKK,SAEfL,EAAKM,UFsJJC,IACA,SAAUxF,EAAQC,EAASC,GAEhC,YAmCA,SAASwE,GAAwBtE,GAAO,GAAIA,GAAOA,EAAIC,WAAc,MAAOD,EAAc,IAAIuE,KAAa,IAAW,MAAPvE,EAAe,IAAK,GAAIoB,KAAOpB,GAAWQ,OAAOuD,UAAUS,eAAezD,KAAKf,EAAKoB,KAAMmD,EAAOnD,GAAOpB,EAAIoB,GAAgC,OAAtBmD,GAAOrE,QAAUF,EAAYuE,EAElQ,QAASxE,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAQC,EAAUC,EAAYC,GAChDD,GACLE,OAAOC,eAAeL,EAAQC,GAC5BK,WAAYJ,EAAWI,WACvBC,aAAcL,EAAWK,aACzBC,SAAUN,EAAWM,SACrBC,MAAOP,EAAWQ,YAAcR,EAAWQ,YAAYC,KAAKR,GAAW,SAI3E,QAASS,GAA0BZ,EAAQC,EAAUY,EAAYX,EAAYC,GAC3E,GAAIW,KAyBJ,OAxBAV,QAAkB,KAAEF,GAAYa,QAAQ,SAAUC,GAChDF,EAAKE,GAAOd,EAAWc,KAEzBF,EAAKR,aAAeQ,EAAKR,WACzBQ,EAAKP,eAAiBO,EAAKP,cAEvB,SAAWO,IAAQA,EAAKJ,eAC1BI,EAAKN,UAAW,GAGlBM,EAAOD,EAAWI,QAAQC,UAAUC,OAAO,SAAUL,EAAMM,GACzD,MAAOA,GAAUpB,EAAQC,EAAUa,IAASA,GAC3CA,GAECX,GAAgC,SAArBW,EAAKJ,cAClBI,EAAKL,MAAQK,EAAKJ,YAAcI,EAAKJ,YAAYC,KAAKR,GAAW,OACjEW,EAAKJ,YAAcW,QAGI,SAArBP,EAAKJ,cACPN,OAA4B,eAAEJ,EAAQC,EAAUa,GAChDA,EAAO,MAGFA,EAzETV,OAAOC,eAAeZ,EAAS,cAC7BgB,OAAO,IAEThB,EAAQwF,SAAW5D,MAEnB,IAgBIE,GAAuBC,EAASC,EAhBhCG,EAAmBlC,EAAoB,IAEvCmC,EAAmBlC,EAAuBiC,GAE1CE,EAAgBpC,EAAoB,IAEpCqC,EAAgBpC,EAAuBmC,GAEvCE,EAA8BtC,EAAoB,IAElDuC,EAA8BtC,EAAuBqC,GAErDE,EAAaxC,EAAoB,IAEjCyC,EAAaxC,EAAuBuC,GGxLzCgD,EAAAxF,EAAA,IACA2E,EAAA3E,EAAA,KACA4E,EAAA5E,EAAA,GAAY6E,EHgMCL,EAAwBI,GG9LrCa,EAAAzF,EAAA,IHiPgBD,GG9OHwF,UH8OsB,EAAIZ,EAAWG,WAAoBhD,EAAU,SAAU4D,GAGvF,QAASH,KACP,GAAIvC,GAEAC,EAAOC,EAAOC,GAElB,EAAIhB,EAAiB/B,SAASgD,KAAMmC,EAEpC,KAAK,GAAIlC,GAAOC,UAAUC,OAAQC,EAAOC,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAC3EF,EAAKE,GAAQJ,UAAUI,EAGzB,OAAeT,GAASC,GAAQ,EAAIX,EAA4BnC,SAASgD,MAAOJ,EAAOuC,EAAS5B,WAAajD,OAAOkD,eAAe2B,IAAWtE,KAAK4C,MAAMb,GAAOI,MAAMU,OAAON,KAAiBnD,EAAgB6C,EAAO,eAAgBnB,EAAamB,GAAQA,EG3O7PyC,aAAe,SAACC,GACd1C,EAAK2C,aAAeD,EAAEtF,OAAOS,OH4OzBmC,EGzON4C,mBAAqB,SAACF,GACpBA,EAAEG,kBACF7C,EAAK8C,MAAMC,UAAUC,QAAQhD,EAAK2C,cAClC3C,EAAK2C,aAAe,IHoOZ1C,EAMJF,GAAQ,EAAIV,EAA4BnC,SAAS8C,EAAOC,GA6B7D,OAhDA,EAAIV,EAAWrC,SAASmF,EAAUG,IAsBlC,EAAIrD,EAAcjC,SAASmF,IACzBjE,IAAK,SACLP,MAAO,WGpQD,GACCkF,GAAc7C,KAAK4C,MAAnBC,SACR,OACEpB,GAAAG,cAAA,WACEH,EAAAG,cAAA,SAAOjE,MAAOqC,KAAKyC,aAAcM,SAAU/C,KAAKuC,eAChDd,EAAAG,cAAA,UAAQG,QAAS/B,KAAK0C,oBAAtB,OACAjB,EAAAG,cAAA,UACGiB,EAAUG,MAAMC,IAAI,SAAAtB,GAAA,MAAQF,GAAAG,cAAAS,EAAA5C,MAAMkC,KAAMA,EAAMzD,IAAKyD,EAAKuB,QAJ7D,eAMeL,EAAUM,yBHmRrBhB,GG/RoBV,EAAM2B,WHgSdzE,EAAcb,EAA0BY,EAAQmC,UAAW,gBAAiBuB,EAAMtB,aACrGtD,YAAY,EACZI,YAAa,WACX,MGlSwB,MH6O+Ba,EAuDtDC,KAAaD,GAIb4E,IACA,SAAU3G,EAAQC,EAASC,GAEhC,YAEAU,QAAOC,eAAeZ,EAAS,cAC7BgB,OAAO,IAEThB,EAAQ2G,UAAY3G,EAAQ8C,KAAOlB,MIxTpC,IAAAgF,GAAA3G,EAAA,KAEa6C,SAAO8D,EAAAC,MACjBC,MAAM,QACLP,GAAIK,EAAAC,MAAME,SAASH,EAAAC,MAAMG,OAAQ,iBAAM5C,MAAKC,WAC5CiB,MAAOsB,EAAAC,MAAMI,OACbjD,UAAU,IAEXkD,QAAQ,SAAAC,GAAA,OAEL9B,OADF,WAEI8B,EAAKnD,UAAYmD,EAAKnD,YAKjB2C,aAAYC,EAAAC,MACtBC,MAAM,aACLT,MAAOO,EAAAC,MAAMO,MAAMtE,KAEpBuE,MAAM,SAAAF,GAAA,OAEHX,GAAIA,uBACF,MAAOW,GAAKd,MAAMiB,OAAO,SAAAtC,GAAA,OAASA,EAAKhB,WAAUR,WAItD0D,QAAQ,SAAAC,GAAA,OAELhB,QADF,SACUb,GACN6B,EAAKd,MAAMkB,MAAOjC,eJgUpBkC,IACA,SAAUzH,EAAQC,EAASC,GAEhC,YAYA,SAASwE,GAAwBtE,GAAO,GAAIA,GAAOA,EAAIC,WAAc,MAAOD,EAAc,IAAIuE,KAAa,IAAW,MAAPvE,EAAe,IAAK,GAAIoB,KAAOpB,GAAWQ,OAAOuD,UAAUS,eAAezD,KAAKf,EAAKoB,KAAMmD,EAAOnD,GAAOpB,EAAIoB,GAAgC,OAAtBmD,GAAOrE,QAAUF,EAAYuE,EAVlQ/D,OAAOC,eAAeZ,EAAS,cAC7BgB,OAAO,GKpWV,IAAA2B,GAAA1C,EAAA,IAGA4E,EAAA5E,EAAA,GAAY6E,ELwWCL,EAAwBI,EAIpC7E,GAAQK,SK1WM,EAAAsC,EAAA8E,WAAU,SAAAC,GAAA,MACvB5C,GAAAG,cAAA,UACEH,EAAAG,cAAA,SACEC,KAAK,WACLC,QAASuC,EAAM1D,SACfoB,QAASsC,EAAMrC,OAAOsC,KAAKD,KAE5BA,EAAMpC,SL+WVvF,EAAOC,QAAUA,EAAiB,SAI7B4H,IACA,SAAU7H,EAAQC,EAASC,GAEhC,YA+BA,SAASwE,GAAwBtE,GAAO,GAAIA,GAAOA,EAAIC,WAAc,MAAOD,EAAc,IAAIuE,KAAa,IAAW,MAAPvE,EAAe,IAAK,GAAIoB,KAAOpB,GAAWQ,OAAOuD,UAAUS,eAAezD,KAAKf,EAAKoB,KAAMmD,EAAOnD,GAAOpB,EAAIoB,GAAgC,OAAtBmD,GAAOrE,QAAUF,EAAYuE,EAElQ,QAASxE,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GA/BvFQ,OAAOC,eAAeZ,EAAS,cAC7BgB,OAAO,IAEThB,EAAQK,QAAUuB,MAElB,IAgBIE,GAhBAK,EAAmBlC,EAAoB,IAEvCmC,EAAmBlC,EAAuBiC,GAE1CE,EAAgBpC,EAAoB,IAEpCqC,EAAgBpC,EAAuBmC,GAEvCE,EAA8BtC,EAAoB,IAElDuC,EAA8BtC,EAAuBqC,GAErDE,EAAaxC,EAAoB,IAEjCyC,EAAaxC,EAAuBuC,GMvZzCE,EAAA1C,EAAA,IACA4E,EAAA5E,EAAA,GAAY6E,EN8ZCL,EAAwBI,GM3ZhBW,GNiaL,EAAI7C,EAAakF,SAAS/F,EAAS,SAAU6D,GAG1D,QAASH,KACP,GAAIvC,GAEAC,EAAOC,EAAOC,GAElB,EAAIhB,EAAiB/B,SAASgD,KAAMmC,EAEpC,KAAK,GAAIlC,GAAOC,UAAUC,OAAQC,EAAOC,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAC3EF,EAAKE,GAAQJ,UAAUI,EAGzB,OAAeT,GAASC,GAAQ,EAAIX,EAA4BnC,SAASgD,MAAOJ,EAAOuC,EAAS5B,WAAajD,OAAOkD,eAAe2B,IAAWtE,KAAK4C,MAAMb,GAAOI,MAAMU,OAAON,KAAiBN,EM/ZjM4C,mBAAqB,SAACF,GACpBA,EAAEG,kBACF7C,EAAKuE,MAAMvB,QAAQhD,EAAK2C,cACxB3C,EAAKuE,MAAM5B,aAAe,IN4ZlB1C,EAIJF,GAAQ,EAAIV,EAA4BnC,SAAS8C,EAAOC,GA4B7D,OA7CA,EAAIV,EAAWrC,SAASmF,EAAUG,IAoBlC,EAAIrD,EAAcjC,SAASmF,IACzBjE,IAAK,SACLP,MAAO,WMrbR,GAAMkF,GAAY7C,KAAKqE,KACvB,OACE5C,GAAAG,cAAA,WACEH,EAAAG,cAAA,SAAO6C,YAAU,iBACjBhD,EAAAG,cAAA,UAAQG,QAAS/B,KAAK0C,oBAAtB,OACAjB,EAAAG,cAAA,UACGiB,EAAUG,MAAMC,IAAI,SAAAtB,GAAA,OAAQ,EAAArC,EAAAoF,GAAE/C,GAAQzD,IAAKyD,EAAKuB,QAJrD,eAMeL,EAAUM,yBNocrBhB,GM/c4BV,EAAM2B,aNgdpB3E,CAEvB9B,GAAQK,QMldYmF,ENmdpBzF,EAAOC,QAAUA,EAAiB,SAI7BgI,IACA,SAAUjI,EAAQC,EAASC,GAEhC,YAmCA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAQC,EAAUC,EAAYC,GAChDD,GACLE,OAAOC,eAAeL,EAAQC,GAC5BK,WAAYJ,EAAWI,WACvBC,aAAcL,EAAWK,aACzBC,SAAUN,EAAWM,SACrBC,MAAOP,EAAWQ,YAAcR,EAAWQ,YAAYC,KAAKR,GAAW,SAI3E,QAASS,GAA0BZ,EAAQC,EAAUY,EAAYX,EAAYC,GAC3E,GAAIW,KAyBJ,OAxBAV,QAAkB,KAAEF,GAAYa,QAAQ,SAAUC,GAChDF,EAAKE,GAAOd,EAAWc,KAEzBF,EAAKR,aAAeQ,EAAKR,WACzBQ,EAAKP,eAAiBO,EAAKP,cAEvB,SAAWO,IAAQA,EAAKJ,eAC1BI,EAAKN,UAAW,GAGlBM,EAAOD,EAAWI,QAAQC,UAAUC,OAAO,SAAUL,EAAMM,GACzD,MAAOA,GAAUpB,EAAQC,EAAUa,IAASA,GAC3CA,GAECX,GAAgC,SAArBW,EAAKJ,cAClBI,EAAKL,MAAQK,EAAKJ,YAAcI,EAAKJ,YAAYC,KAAKR,GAAW,OACjEW,EAAKJ,YAAcW,QAGI,SAArBP,EAAKJ,cACPN,OAA4B,eAAEJ,EAAQC,EAAUa,GAChDA,EAAO,MAGFA,EAvETV,OAAOC,eAAeZ,EAAS,cAC7BgB,OAAO,IAEThB,EAAQK,QAAUuB,MAElB,IAgBIC,GAAMC,EAAuBC,EAASC,EAAaC,EAhBnDE,EAAmBlC,EAAoB,IAEvCmC,EAAmBlC,EAAuBiC,GAE1CE,EAAgBpC,EAAoB,IAEpCqC,EAAgBpC,EAAuBmC,GAEvCE,EAA8BtC,EAAoB,IAElDuC,EAA8BtC,EAAuBqC,GAErDE,EAAaxC,EAAoB,IAEjCyC,EAAaxC,EAAuBuC,GOnfzCE,EAAA1C,EAAA,IAOA2C,EAAA3C,EAAA,KPofK4C,EAAS3C,EAAuB0C,GOlfrC8C,EAAAzF,EAAA,KPsfKgI,EAAS/H,EAAuBwF,GOnfhBF,GPkiBJ3D,GOniBhB,EAAAc,EAAAI,UAAAF,EAAAxC,SPmiBmEwB,GAAeE,EAAU,SAAUiB,GAGpG,QAASwC,KACP,GAAIvC,GAEAC,EAAOC,EAAOC,GAElB,EAAIhB,EAAiB/B,SAASgD,KAAMmC,EAEpC,KAAK,GAAIlC,GAAOC,UAAUC,OAAQC,EAAOC,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAC3EF,EAAKE,GAAQJ,UAAUI,EAGzB,OAAeT,GAASC,GAAQ,EAAIX,EAA4BnC,SAASgD,MAAOJ,EAAOuC,EAAS5B,WAAajD,OAAOkD,eAAe2B,IAAWtE,KAAK4C,MAAMb,GAAOI,MAAMU,OAAON,KAAiBnD,EAAgB6C,EAAO,QAASnB,EAAamB,GAAQ7C,EAAgB6C,EAAO,eAAgBlB,EAAckB,GAAjSC,EAAySF,GAAQ,EAAIV,EAA4BnC,SAAS8C,EAAOC,GAgB1W,OA7BA,EAAIV,EAAWrC,SAASmF,EAAUxC,IAgBlC,EAAIV,EAAcjC,SAASmF,IACzBjE,IAAK,UACLP,MAAO,WO9iBRqC,KAAKgD,MAAMkB,KAAKU,EAAA5H,QAAK6H,QAAS5C,MAAOjC,KAAKyC,mBPkjBzCvE,IAAK,sBACL4G,IAAK,WOtjBN,MAAO9E,MAAKgD,MAAMiB,OAAO,SAAAtC,GAAA,OAASA,EAAKhB,WAAUR,WP4jB3CgC,GACP7C,EAAasB,MAAQjC,EAAcb,EAA0BY,EAAQmC,UAAW,SAAUvB,EAAawB,aACvGtD,YAAY,EACZI,YAAa,WACX,YAEAgB,EAAed,EAA0BY,EAAQmC,UAAW,gBAAiBvB,EAAawB,aAC5FtD,YAAY,EACZI,YAAa,WACX,MOvkBwB,MPykBxBE,EAA0BY,EAAQmC,UAAW,uBAAwBvB,EAAayF,UAAWzH,OAAO4D,yBAAyBxC,EAAQmC,UAAW,uBAAwBnC,EAAQmC,WAAY/C,EAA0BY,EAAQmC,UAAW,WAAYvB,EAAa2B,QAAS3D,OAAO4D,yBAAyBxC,EAAQmC,UAAW,WAAYnC,EAAQmC,WAzC9QpC,EAyC2RC,KAAaD,EAChX9B,GAAQK,QO5kBYmF,EP6kBpBzF,EAAOC,QAAUA,EAAiB,SAI7BqI,IACA,SAAUtI,EAAQC,EAASC,IAEJ,SAASqI,GAAS,YQ/kB/C,SAASC,GAAQhC,EAAIiC,GACnBnF,KAAKoF,IAAMlC,EACXlD,KAAKqF,SAAWF,EAnBlB,GAAI1E,GAAQ6E,SAASzE,UAAUJ,KAI/B9D,GAAQ4I,WAAa,WACnB,MAAO,IAAIL,GAAQzE,EAAM5C,KAAK0H,WAAYC,OAAQtF,WAAYuF,eAEhE9I,EAAQ+I,YAAc,WACpB,MAAO,IAAIR,GAAQzE,EAAM5C,KAAK6H,YAAaF,OAAQtF,WAAYyF,gBAEjEhJ,EAAQ8I,aACR9I,EAAQgJ,cAAgB,SAASC,GAC3BA,GACFA,EAAQC,SAQZX,EAAQrE,UAAUiF,MAAQZ,EAAQrE,UAAUkF,IAAM,aAClDb,EAAQrE,UAAUgF,MAAQ,WACxB7F,KAAKqF,SAASxH,KAAK2H,OAAQxF,KAAKoF,MAIlCzI,EAAQqJ,OAAS,SAASC,EAAMC,GAC9BT,aAAaQ,EAAKE,gBAClBF,EAAKG,aAAeF,GAGtBvJ,EAAQ0J,SAAW,SAASJ,GAC1BR,aAAaQ,EAAKE,gBAClBF,EAAKG,cAAe,GAGtBzJ,EAAQ2J,aAAe3J,EAAQ4J,OAAS,SAASN,GAC/CR,aAAaQ,EAAKE,eAElB,IAAID,GAAQD,EAAKG,YACbF,IAAS,IACXD,EAAKE,eAAiBZ,WAAW,WAC3BU,EAAKO,YACPP,EAAKO,cACNN,KAKPtJ,EAAQ,MAIRD,EAAQ8J,aAAgC,mBAAT3C,OAAwBA,KAAK2C,cAClB,mBAAXxB,IAA0BA,EAAOwB,cACxClI,OACxB5B,EAAQ+J,eAAkC,mBAAT5C,OAAwBA,KAAK4C,gBAClB,mBAAXzB,IAA0BA,EAAOyB,gBACxCnI,SR6lBIV,KAAKlB,EAAU,WAAa,MAAOqD,WAI3D2G,IACA,SAAUjK,EAAQC,EAASC,IS7pBjC,SAAA6J,GAAA,YAaA,SAAAG,GAAAC,GACA,MAAAC,IAAAD,GAAAhF,KAgBA,QAAAkF,GAAAF,EAAAG,GACA,MAAAF,IAAAD,GAAAI,aAAAD,GAaA,QAAAE,GAAAhK,EAAAiK,GAQA,MAAAL,IAAA5J,GAAAkK,QAAAD,GAYA,QAAAE,GAAAnK,EAAAiK,GAQA,MAAAL,IAAA5J,GAAAoK,WAAAH,GAaA,QAAAI,GAAArK,EAAAsK,GAQAV,GAAA5J,GAAAuK,aAAAC,GAAAF,IA2BA,QAAAG,GAAAC,GAOA,QAAAC,KACAC,IAEAA,EAAAZ,EAAAU,EAAA,SAAAJ,EAAAO,GACAC,EAAAC,WAAA/D,MAAAsD,EAAAO,OALA,GAAAD,GAAA,KAQAE,GACAC,cACAC,cACA,MAAAlI,MAAAiI,WAAAhF,IAAA,SAAAkF,GACA,GAAAC,GAAAD,EAAA,EACA,OAAAC,MAGAC,qBACA,MAAArI,MAAAiI,WAAAhF,IAAA,SAAAkF,GACA,GAAAG,IAAAH,EAAA,GAAAA,EAAA,GACA,OAAAG,MAGAC,KAAA,WACAT,GACAA,IACAA,EAAA,MAEAD,SACAW,OAAA,SAAAtL,GACAqK,EAAArK,GAAA0K,EAAAI,EAAAE,UAEAO,KAAA,SAAAvL,GACAqK,EAAArK,GAAA0K,EAAAI,EAAAK,eAAAlK,QAAAC,YAIA,OADAyJ,KACAG,EASA,QAAAU,GAAAxL,GAMA,GAAAyL,GAAA7B,GAAA5J,EACAyL,GAAAC,QACAC,GAAA,+CACAF,EAAAG,qBAAA,EAwBA,QAAAC,GAAA7L,GAMA,GAAAyL,GAAA7B,GAAA5J,EACAyL,GAAAC,QACAC,GAAA,iDACAF,EAAAG,qBAAA,EAKA,QAAAE,GAAA9L,GACA,MAAA4J,IAAA5J,GAAA+L,YAUA,QAAAC,GAAAhM,EAAAiM,GAMA,MAAArC,IAAA5J,GAAAkM,cAAAD,GAUA,QAAAE,GAAAnM,GAMA,MAAA4J,IAAA5J,GAAAiM,SAUA,QAAAG,GAAApM,EAAAqM,GACA,SAAAA,IAA2BA,EAAA,EAW3B,KADA,GAAAC,GAAA1C,GAAA5J,GAAAsM,OACAA,GAAA,CACA,SAAAD,EACA,QACAC,YAEA,SAaA,QAAAC,GAAAvM,EAAAqM,GACA,SAAAA,IAA2BA,EAAA,EAY3B,KAFA,GAAAG,GAAAH,EACAC,EAAA1C,GAAA5J,GAAAsM,OACAA,GAAA,CACA,SAAAE,EACA,MAAAF,GAAAG,WACAH,YAEA,MAAAX,IAAA,gCAAA/B,GAAA5J,GAAA,aAAAqM,GASA,QAAAK,GAAA1M,GAMA,MAAA4J,IAAA5J,GAAA2M,KAAAF,YASA,QAAAG,GAAA5M,GAMA,MAAA4J,IAAA5J,GAAA6M,KASA,QAAAC,GAAA9M,GAMA,MAAA+M,IAAAnD,GAAA5J,GAAA6M,MASA,QAAAG,GAAAhN,GAMA,MAAA4J,IAAA5J,GAAA0L,OAWA,QAAAuB,GAAAjN,EAAA6M,GAQA,GAAApB,GAAAyB,GAAAtD,GAAA5J,GAAA6M,EACA,OAAApB,KAAAhL,MAAAY,OAYA,QAAA8L,GAAAxI,EAAA3E,EAAAoN,GAUA,GAAA3B,GAAA7B,GAAA5J,GAAA2M,KAAAU,gBAAAC,QAAA3I,EAAA,GAAAyI,EACA,OAAA3B,KAAAhL,MAAAY,OAUA,QAAAkM,GAAAvN,EAAA6M,GAQA,GAAApB,GAAAyB,GAAAtD,GAAA5J,GAAA6M,GAAA,EACA,IAAAxL,SAAAoK,EAEA,MAAAA,KAAAhL,MAAAY,OAWA,QAAAmM,GAAAC,EAAAzN,GAQA,MAAA0N,IAAA9D,GAAA6D,GAAA7D,GAAA5J,IAcA,QAAA2N,GAAAC,EAAAC,GACA,SAAAA,IAAqCA,GAAA,EAMrC,IAAApC,GAAA7B,GAAAgE,EACA,OAAAnC,GAAA9G,KAAAgD,OAAA8D,EAAAQ,SAAA4B,KAAA,EACApC,EAAAkB,KAAAmB,aACAD,KAAA,EAAAxM,OAAAwM,GAKA,QAAAE,GAAA/N,GAOA,MADA4J,IAAA5J,GAAAgO,SACAhO,EAKA,QAAAiO,GAAAjO,GAMA,GAAAyL,GAAA7B,GAAA5J,EACAyL,GAAAC,OACAD,EAAAyC,MAEAzC,EAAAa,OAAA6B,YAAA1C,EAAA2C,SAYA,QAAAC,GAAArO,GAMA,MAAA4J,IAAA5J,GAAAsO,QA0BA,QAAAC,GAAAvO,EAAA4K,GAQAhB,GAAA5J,GAAAwO,YAAA5D,GAYA,QAAA6D,GAAAzO,GAMA,GAAAyL,GAAA7B,GAAA5J,GACA0O,EAAAjD,EAAAkB,KAAAmB,YACA,OAAAY,GAEAA,EADAC,GAMA,QAAAC,GAAA5O,EAAA6O,GAQA,GAAApD,GAAA7B,GAAA5J,EAEAyL,GAAAqD,cAAA/N,QAAA,SAAA+I,GACAiF,GAAAjF,EAAA2C,cACAmC,EAAA9E,EAAA2C,YAAAoC,KAEAA,EAAApD,EAAAgB,aAuBA,QAAAuC,GAAAxC,EAAApB,GAEA,QAAA6D,KAAmBnM,KAAAoM,YAAA1C,EADnB2C,GAAA3C,EAAApB,GAEAoB,EAAA7I,UAAA,OAAAyH,EAAAhL,OAAAuH,OAAAyD,IAAA6D,EAAAtL,UAAAyH,EAAAzH,UAAA,GAAAsL,IAKA,QAAAG,GAAAC,EAAA/J,GACA,GAAAgK,KACA,QAAAC,KAAAF,GAAAjP,OAAAuD,UAAAS,eAAAzD,KAAA0O,EAAAE,IAAAjK,EAAAkK,QAAAD,GAAA,IACAD,EAAAC,GAAAF,EAAAE,GACA,UAAAF,GAAA,kBAAAjP,QAAAqP,sBACA,OAAAC,GAAA,EAAAH,EAAAnP,OAAAqP,sBAAAJ,GAA4DK,EAAAH,EAAAtM,OAAcyM,IAAApK,EAAAkK,QAAAD,EAAAG,IAAA,IAC1EJ,EAAAC,EAAAG,IAAAL,EAAAE,EAAAG,IACA,OAAAJ,GAGA,QAAAK,GAAA9O,EAAAb,EAAAgB,EAAAF,GACA,GAAA0L,GAAAoD,EAAA5M,UAAAC,OAAA4M,EAAAD,EAAA,EAAA5P,EAAA,OAAAc,IAAAV,OAAA4D,yBAAAhE,EAAAgB,GAAAF,CACA,oBAAAgP,UAAA,kBAAAA,SAAAC,SAAAF,EAAAC,QAAAC,SAAAlP,EAAAb,EAAAgB,EAAAF,OACA,QAAA4O,GAAA7O,EAAAoC,OAAA,EAA4CyM,GAAA,EAAQA,KAAAlD,EAAA3L,EAAA6O,MAAAG,GAAAD,EAAA,EAAApD,EAAAqD,GAAAD,EAAA,EAAApD,EAAAxM,EAAAgB,EAAA6O,GAAArD,EAAAxM,EAAAgB,KAAA6O,EACpD,OAAAD,GAAA,GAAAC,GAAAzP,OAAAC,eAAAL,EAAAgB,EAAA6O,KAonBA,QAAAG,GAAAvP,GACA,sBAAAA,SAAAwP,UAAA,EAyBA,QAAAC,GAAAC,GACA,GAAAC,GAAA,GAAAC,IACA,iBAAA1P,EAAA2P,GACA,OAAA3P,EAAAgE,MACA,aACA,GAAAwL,EAAApJ,QAAAoJ,EAAApJ,OAAApG,MAAA,EAsBA,MAAA2P,GAAA3P,EArBA,IAAAR,GAAAgQ,EAAAI,QAAA5P,EACAwP,GAAAK,SAAA7P,EAAAR,GACAiQ,EAAAK,IAAA9P,EAAAqF,IACArF,OACAR,UACAuQ,OAAA,GAEA,KACA,GAAAC,GAAAL,EAAA3P,EAKA,OAJAwP,GAAAS,UAAAjQ,EAAAR,GACAiQ,EAAAxI,IAAAjH,EAAAqF,IAAA0K,SAAA,GACAP,EAAAU,UAAAlQ,EAAAR,EAAAwQ,GAEAA,EAEA,MAAArL,GAEA,KADA6K,GAAAW,OAAAnQ,EAAAR,EAAAmF,GACAA,EAOA,iBACA,GAAAqH,GAAAyD,EAAAxI,IAAAjH,EAAAoQ,OAEA,OADApE,GAAA+D,OAAA,EACAJ,EAAA3P,EAEA,mBACA,wBACA,GAAAgM,GAAAyD,EAAAxI,IAAAjH,EAAAoQ,OACAZ,GAAAK,SAAA7P,EAAAgM,EAAAxM,QACA,KACA,MAAAmQ,GAAA3P,GAEA,QACAwP,EAAAS,UAAAjQ,EAAAgM,EAAAxM,SAGA,iBACA,GAAAwM,GAAAyD,EAAAxI,IAAAjH,EAAAoQ,OAGA,OAFAX,GAAAY,OAAArQ,EAAAqF,IACAmK,EAAAW,OAAAnQ,EAAAgM,EAAAxM,QAAAQ,EAAAuC,KAAA,IACAoN,EAAA3P,EAEA,mBACA,GAAAgM,GAAAyD,EAAAxI,IAAAjH,EAAAoQ,OAGA,OAFAX,GAAAY,OAAArQ,EAAAqF,IACAmK,EAAAU,UAAAlQ,EAAAgM,EAAAxM,QAAAQ,EAAAuC,KAAA,IACAoN,EAAA3P,KAMA,QAAAsQ,GAAAxF,EAAAyF,EAAAC,EAAAC,GACA,GAAAA,YAAAC,MACA,OAAgBC,UAAAF,EAAAG,UAChB,IAAAC,GAAAJ,GACA,MAAAA,EAGA,IAAArC,GAAAqC,GACA,MAAAK,GAAA,aAAA/H,EAAA0H,GAAAM,KAAA,IACA,sBAAAN,GACA,MAAAK,GAAA,aACA,oBAAAL,KAAAO,GAAAP,KAAAQ,GAAAR,GACA,MAAAK,GAAA,YAAAL,KAAAlC,aAAAkC,EAAAlC,YAAAwC,MAAA,sBACA,KAIA,MADAG,MAAAC,UAAAV,GACAA,EAEA,MAAA9L,GACA,MAAAmM,GAAA,GAAAnM,IAGA,QAAAyM,GAAAC,EAAAvR,GACA,MAAAA,IAAA,gBAAAA,IAAA,aAAAA,GACA,GAAA4Q,MAAA5Q,EAAA,WACAA,EAEA,QAAAgR,GAAAQ,GACA,OACAC,qBAAA,EACAvN,KAAAsN,GAaA,QAAAE,GAAAnS,EAAA2G,GAQAyL,GAAAC,YAAA,WACA7H,GAAA7D,GAAA5F,QAAA,SAAAuR,GAAuD,MAAAC,GAAAvS,EAAAsS,OAGvD,QAAAC,GAAAvS,EAAAsS,GACA,GAAAE,GAAAjF,EAAAvN,EAAAsS,EAAAzF,MAAA,GACA,KAAA2F,EACA,MAAA7G,IAAA,yBAAA2G,EAAAzF,MAAA,IACA,IAAApB,GAAA7B,GAAA4I,EAEA,0BAAAF,EAAAZ,KACArH,EAAA1J,KAAA,KAAA6R,EAAAF,EAAApP,KAAA,IAEA,oBAAAoP,EAAAZ,KACA1F,EAAArL,KAAA,KAAA6R,EAAAF,EAAApP,KAAA,KAEA,kBAAAsP,GAAAF,EAAAZ,OACA/F,GAAA,WAAA2G,EAAAZ,KAAA,wBAAAjG,EAAAoB,KAAA,KACA2F,EAAAF,EAAAZ,MAAAnO,MAAAiP,EAAAF,EAAApP,KAAAoP,EAAApP,KAAA6C,IAAA,SAAA0M,GAAkH,MAAAV,GAAAtG,EAAAgH,UAoBlH,QAAAC,GAAAhI,GAMA,GAAAI,IACAnE,WACA0E,KAAA,WAA2B,MAAAT,MAC3BU,OAAA,SAAAtL,GACAmS,EAAAnS,EAAA8K,EAAAnE,WAGAiE,EAAA+H,EAAAjI,EAAAI,EAAAnE,QAAAK,KAAAI,KAAA0D,EAAAnE,SACA,OAAAmE,GAuCA,QAAA6H,GAAA3S,EAAA4S,EAAAC,GAWA,QAAAC,GAAAC,GACA,cAAAA,EAAApO,MAAAoO,EAAA/M,KAAA+M,EAAAhC,OAAA,CACA,GAAAiC,GAAApJ,GAAAmJ,EAAA5S,QACAyS,IACAlB,KAAAqB,EAAArB,KACA7E,KAAAa,GAAA9D,GAAA5J,GAAAgT,GACA9P,KAAA6P,EAAA7P,KAAA6C,IAAA,SAAAqL,EAAAD,GACA,MAAAF,GAAA+B,EAAAD,EAAArB,KAAAP,EAAAC,QAKA,MAtBA,UAAAyB,IAAiCA,GAAA,GAsBjCI,EAAAjT,EAAA6S,EACA,SAAAE,EAAAzC,GACA,GAAAK,GAAAL,EAAAyC,EAEA,OADAD,GAAAC,GACApC,GAEA,SAAAoC,EAAAzC,GAEA,MADAwC,GAAAC,GACAzC,EAAAyC,KAMA,QAAAG,KACA,MAAAC,MAEA,QAAAC,GAAAjT,EAAAkT,GACA,GAAA5H,GAAA7B,GAAAzJ,WACAmT,EAAA7H,EAAA8H,iBACAC,EAAAC,EACAhI,GAAAiI,cACAjI,EAAA8H,kBAAA,EACAE,GAAAtT,CACA,KACA,MAAAwT,GAAAlI,EAAAtL,EAAAkT,GAEA,QACAI,GAAAD,EACA/H,EAAA8H,iBAAAD,GAGA,QAAAM,KACA,MAAAH,IAEAA,GADA9H,GAAA,0BAGA,QAAAkI,GAAA7T,EAAA0R,EAAA2B,GACA,kBACA,GAAArN,GAAAkN,GACA,OAAAE,IACAzO,KAAA,SACA+M,OACA1L,KACA9C,KAAA4Q,GAAA9Q,WACA7C,QAAAH,EACA+T,KAAArH,EAAA1M,GACA+Q,OAAA0C,MAAA1C,OAAA/K,EACAgO,SAAAP,MAAAzN,GAAA,GACSqN,IAcT,QAAAJ,GAAAjT,EAAAiU,GACA,GAAAxI,GAAA7B,GAAA5J,EAKA,OAAAyL,GAAAyI,cAAAD,GAwBA,QAAAE,GAAAF,EAAAZ,GAKA,MAJAA,GAAAe,gBACAf,EAAAe,gBAAApN,KAAAiN,GAEAZ,EAAAe,iBAAAH,GACAZ,EAEA,QAAAgB,GAAA5I,EAAA6I,EAAAjB,GAIA,IAHA,GAAAkB,GAAAlB,EAAAe,iBAAAI,GACAC,EAAAhJ,EAEAgJ,GACAA,EAAAC,cACAH,IAAA/Q,OAAAiR,EAAAC,cACAD,IAAAnI,MAEA,OAAAiI,GAEA,QAAAZ,GAAAlI,EAAA6I,EAAAK,GAMA,QAAAC,GAAAjU,GACA,GAAAkU,GAAAN,EAAApD,IACA,OAAA0D,GACAA,EAAAlU,EAAAiU,GAEAxC,GAAArO,OAAA4Q,GAAApR,MAAA,KAAA+Q,EAAApR,MAVA,GAAAqR,GAAAF,EAAA5I,EAAA6I,EAAAK,EAEA,KAAAJ,EAAAtR,OACA,MAAAmP,IAAArO,OAAA4Q,GAAApR,MAAA,KAAA+Q,EAAApR,KACA,IAAAiO,GAAA,CAQA,OAAAyD,GAAAN,GAGA,QAAAQ,GAAArU,GACA,IACA,MAAAoR,MAAAC,UAAArR,GAEA,MAAA6E,GACA,0BAAAA,EAAA,KAGA,QAAAyP,GAAAtU,GACA,wBAAAA,GACA,aAAAA,EAAAiR,KAAA,IAAAjR,EAAAiR,KAAA,QACA3C,GAAAtO,GAAA,IAAAA,EAAA,QAAAqU,EAAArU,GAAA,IAEA,QAAAuU,GAAAC,GACA,GAAAxU,GAAAwU,EAAAxU,MACAkE,EAAAsQ,EAAA9U,QAAA8U,EAAA9U,QAAA8C,OAAA,GAAA0B,KACAuQ,EAAAD,EAAA9U,QACA4F,IAAA,SAAAkF,GACA,GAAA4B,GAAA5B,EAAA4B,IACA,OAAAA,KAEA9F,OAAA,SAAA8F,GAAiC,MAAAA,GAAA5J,OAAA,IACjCkS,KAAA,KACAC,EAAAF,EAAAjS,OAAA,eAAAiS,EAAA,QACAG,EAAAtG,GAAAtO,GACA,iBAAAmJ,GAAAnJ,GAAAkE,KAAA+M,KAAA,IACAF,GAAA/Q,GAAA,mBACA6U,EAAA3Q,GAAAoK,GAAAtO,IAAAkE,EAAA4Q,GAAA3L,GAAAnJ,GAAAwL,SACA,UAAAmJ,EAAAC,EAAA,IAAAN,EAAAtU,GAAA,uBAAAkE,EACA,aAAAA,EAAA+M,KAAA,IACA,KACAuD,EAAAO,QAAA,KAAAP,EAAAO,QAAA,SACA7Q,EACA8Q,GAAA9Q,GACA,IACA,8BAAAA,EAAA+M,KAAA,yBAAA/M,EAAA+Q,WAAA,cACAJ,EACA,qFACA,IACA,KAGA,QAAAK,IAAAxV,EAAA0M,EAAAlI,GACA,MAAAxE,GAAAqD,SAA4BqJ,OAAAlI,UAE5B,QAAAiR,MACA,MAAApB,IAEA,QAAAqB,IAAA1V,EAAAM,EAAA+U,GACA,QAAarV,UAAAM,QAAA+U,YAEb,QAAAM,IAAAC,GACA,MAAAA,GAAA5U,OAAA,SAAA+J,EAAAwE,GAA0C,MAAAxE,GAAA1H,OAAAkM,QAG1C,QAAAsG,IAAArR,EAAAlE,IAgBA,QAAAwV,IAAAtR,EAAAlE,GACA,GAAAsV,GAAApR,EAAAuR,SAAAzV,IAAwCoM,KAAA,GAAAlI,SACxCoR,GAAA9S,OAAA,GACA0I,GAAA,0BAAAoJ,EAAAtU,GAAA,QAAAkE,EAAA+M,KAAA,OACAqE,EAAAhQ,IAAAiP,GAAAG,KAAA,OAqEA,QAAAgB,IAAAxR,EAAA2H,EAAA8B,EAAAgI,EAAAC,EAAAC,EAAAC,GAGA,GAFA,SAAAD,IAAuCA,EAAAE,IACvC,SAAAD,IAAyCA,EAAAE,IACzC1H,GAAAsH,GAAA,CACA,GAAAK,GAAAL,EAAAM,SAMA,OALAD,GAAAhL,QACAC,GAAA,gIAAAW,EACAA,EAAAO,KACA,QAAAuB,EAAA,+BAAAsI,EAAA7J,KAAA,KACA6J,EAAAE,UAAAtK,EAAA8B,GACAsI,EAEA,GAAAjK,GAAA6J,EAAAD,EACA,IAAA1R,EAAAkS,iBAAA,CACA,GAAApL,GAAA,GAAAqL,IAAAnS,EAAA2H,EAAA8B,EAAAgI,EAAAC,EAAA5J,EAAA9H,EAAAkS,iBAAAN,EAEA,OADA9K,GAAAsL,mBACAtL,EAEA,UAAAuL,IAAArS,EAAA2H,EAAA8B,EAAAgI,EAAAC,EAAA5J,EAAA9H,EAAAkS,iBAAAN,GAEA,QAAAU,IAAAxW,GACA,MAAAA,aAAAuW,KAAAvW,YAAAqW,IAoBA,QAAA/H,IAAAtO,GACA,SAAAA,MAAAkW,WAEA,QAAA/M,IAAAnJ,GACA,MAAAsO,IAAAtO,GACAA,EAAAkW,UAEAhL,GAAA,SAAAlL,EAAA,mBAGA,QAAAyW,MACA,MAAAtN,IAAA9G,MAAAmJ,SAGA,QAAAyB,IAAAD,EAAAzN,GAEAyN,EAAAd,OAAA3M,EAAA2M,MACAhB,GAAA,4CAAA8B,EAAA,UAAAzN,EAAA,yCAIA,KAHA,GAAAmX,GAAApK,GAAAU,EAAAZ,MACAuK,EAAArK,GAAA/M,EAAA6M,MACAwK,EAAA,EACUA,EAAAF,EAAAlU,QACVkU,EAAAE,KAAAD,EAAAC,GADqCA,KAKrC,MAAAF,GACAlW,MAAAoW,GACAtR,IAAAuR,IACAnC,KAAA,KAAAoC,GAAAH,EAAAnW,MAAAoW,IAEA,QAAAnK,IAAAO,EAAAZ,EAAA2K,GAEA,MADA,UAAAA,IAAwCA,GAAA,GACxCC,GAAAhK,EAAAV,GAAAF,GAAA2K,GAEA,QAAAC,IAAAhK,EAAAiK,EAAAF,GACA,SAAAA,IAAwCA,GAAA,EAMxC,QADAG,GAAAlK,EACAiC,EAAA,EAAmBA,EAAAgI,EAAAzU,OAAsByM,IAAA,CACzC,QAAAgI,EAAAhI,GACAiI,IAAAhL,SACA,WAAA+K,EAAAhI,GACAiI,IAAArL,WACA,UAAAoL,EAAAhI,IAAA,KAAAgI,EAAAhI,GAEA,QACA,IAAAiI,EAAA,CACA,KAAAA,YAAAb,KAGA,MAAAnL,IAAA,gBAFAgM,KAAAC,aAAAF,EAAAhI,GAGA,WAEA,IAAAiI,EACA,MAAAH,GACA7L,GAAA,sBAAA+L,EAAAhI,GAAA,SAAA6H,GAAAG,EAAAzW,MAAA,EAAAyO,EAAA,6CAEA,OAGA,MAAAiI,GAuBA,QAAAE,IAAAC,GAEA,MADAC,IAAA,uDAAAC,IACAC,GAAAH,GAKA,QAAAnM,IAAA6J,GAEA,KADA,UAAAA,IAA6BA,EAAA,iBAC7B,GAAA0C,OAAA,qBAAA1C,GAEA,QAAAgB,IAAA2B,GACA,MAAAA,GAGA,QAAA1B,OACA,QAAA7E,IAAAwG,GACA,SAAAjV,MAAAyO,QAAAwG,KAAAhG,GAAAiG,kBAAAD,IAEA,QAAA5N,IAAA4N,GACA,MAAAA,GAEAxG,GAAAwG,GACAA,GACAA,GAHA5D,GAKA,QAAA8D,IAAApN,GAEA,OADAE,MACAmN,EAAA,EAAoBA,EAAAvV,UAAAC,OAAuBsV,IAC3CnN,EAAAmN,EAAA,GAAAvV,UAAAuV,EAEA,QAAA7I,GAAA,EAAmBA,EAAAtE,EAAAnI,OAAcyM,IAAA,CACjC,GAAAiI,GAAAvM,EAAAsE,EACA,QAAA1O,KAAA2W,GACAzM,EAAAlK,GAAA2W,EAAA3W,GAEA,MAAAkK,GAGA,QAAAyG,IAAAlR,GACA,UAAAA,GAAA,gBAAAA,GACA,QACA,IAAA+X,GAAApY,OAAAkD,eAAA7C,EACA,OAAA+X,KAAApY,OAAAuD,WAAA,OAAA6U,EAEA,QAAAC,IAAAhY,GACA,eAAAA,GACA,gBAAAA,IACAA,YAAA4Q,OACA5Q,YAAAiY,SAEA,QAAAlH,IAAA/Q,GACA,cAAAA,GAAAY,SAAAZ,IAEA,gBAAAA,IACA,gBAAAA,IACA,iBAAAA,IACAA,YAAA4Q,OAmBA,QAAAsH,IAAAlY,GACA,wBAAAA,GAEA,QAAAmY,IAAAjP,EAAAkP,EAAApY,GACAL,OAAAC,eAAAsJ,EAAAkP,GACAvY,YAAA,EACAE,UAAA,EACAD,cAAA,EACAE,UAIA,QAAAqY,IAAAnP,EAAAkP,EAAApY,GACAL,OAAAC,eAAAsJ,EAAAkP,GACAvY,YAAA,EACAE,UAAA,EACAD,cAAA,EACAE,UAGA,QAAAsY,IAAAC,EAAAjQ,GACA,GAAAkQ,GAAAD,EAAAxJ,QAAAzG,EACAkQ,MAAA,GACAD,EAAAE,OAAAD,EAAA,GAEA,QAAAE,IAAA5E,EAAAM,GAEA,MADAN,GAAAvN,KAAA6N,GACA,WACAkE,GAAAxE,EAAAM,IAIA,QAAAf,IAAA5Q,GAEA,OADAyN,GAAA,GAAAxN,OAAAD,EAAAD,QACAyM,EAAA,EAAmBA,EAAAxM,EAAAD,OAAiByM,IACpCiB,EAAAjB,GAAAxM,EAAAwM,EACA,OAAAiB,GAyBA,QAAAsH,IAAAH,GACA,MAAAsB,IAAAtB,EAAApG,KAAAoG,GAEA,QAAAsB,IAAA1H,EAAA2H,GACA,GAAAC,GAAA,WAKA,QAAAC,GAAAlG,EAAA1O,EAAAyM,GACAiC,EAAAe,gBAAAkF,EAAAlF,gBACAhB,GACA1B,OACA/M,OACAqB,GAAAwT,EACAtW,MAAAkO,GACA2C,KAAA0F,EAAA1F,KACA5T,QAAAsZ,EAAAtZ,QACA6T,SAAAyF,EAAAzT,GACA+K,OAAA0I,EAAA1I,QACasC,GAdb,GAAAmG,GAAAtG,IACAuG,EAAA7F,IACA1Q,EAAAF,SAcA,WAAA0W,SAAA,SAAApM,EAAAqM,GAiBA,QAAAC,GAAAjJ,GACA,GAAAkJ,EACA,KAEAN,EAAA,SAAA1J,GAAuCgK,EAAAC,EAAAxJ,KAAAT,IAAqB,cAAAc,GAE5D,MAAArL,GAKA,WAHAiE,GAAA,WACAgQ,EAAA,SAAA1J,GAA2C8J,EAAArU,IAAa,aAAAA,KAIxDgL,EAAAuJ,GAGA,QAAAE,GAAAC,GACA,GAAAH,EACA,KAEAN,EAAA,SAAA1J,GAAuCgK,EAAAC,EAAAG,MAAApK,IAAsB,oBAAAmK,GAE7D,MAAA1U,GAKA,WAHAiE,GAAA,WACAgQ,EAAA,SAAA1J,GAA2C8J,EAAArU,IAAa,aAAAA,KAIxDgL,EAAAuJ,GAEA,QAAAvJ,GAAAuJ,GACA,MAAAA,GAAAK,SAEA3Q,GAAA,WACAgQ,EAAA,SAAA1J,GAA2CvC,EAAAuC,IAAc,cAAAgK,EAAApZ,UAKzDoZ,EAAApZ,OAAA,kBAAAoZ,GAAApZ,MAAA0Z,MACAxO,GAAA,iDAAAkO,GACAA,EAAApZ,MAAA0Z,KAAAP,EAAAG,IA1DA,GAAAD,GACAM,EAAA,WACAN,EAAAT,EAAA9V,MAAA,KAAAP,WACA4W,EAAAvY,QAEA+Y,GAAAhG,gBAAAkF,EAAAlF,gBACAhB,GACA1B,OACA/M,KAAA,aACAqB,GAAAwT,EACAtW,KAAA4Q,GAAA5Q,GACA6Q,KAAA0F,EAAA1F,KACA5T,QAAAsZ,EAAAtZ,QACA6T,SAAAyF,EAAAzT,GACA+K,OAAA0I,EAAA1I,QACaqJ,KA+Cb,OAAAd,GAGA,QAAAe,IAAA/P,GAGA,MAFA,YAAAA,IACAqB,GAAA,wDACA2O,GAAAhQ,GAAAiQ,GAAAjQ,IAEA,QAAAgQ,IAAAhQ,GAGA,OAAAA,EAAAkQ,IACA,UACA,OAAoBA,GAAA,MAAA3N,KAAAvC,EAAAuC,KAAApM,MAAA6J,EAAA7J,MACpB,cACA,OAAoB+Z,GAAA,SAAA3N,KAAAvC,EAAAuC,KACpB,eACA,OAAoB2N,GAAA,UAAA3N,KAAAvC,EAAAuC,KAAApM,MAAA6J,EAAA7J,QAGpB,QAAA8Z,IAAAjQ,GACA,OAAAA,EAAAkQ,IACA,UACA,OACAA,GAAA,SACA3N,KAAAvC,EAAAuC,KAEA,cACA,OACA2N,GAAA,MACA3N,KAAAvC,EAAAuC,KACApM,MAAA6J,EAAAmQ,SAEA,eACA,OACAD,GAAA,UACA3N,KAAAvC,EAAAuC,KACApM,MAAA6J,EAAAmQ,WAQA,QAAAC,IAAAC,GACA,MAAAA,GAAAC,QAAA,WAAAA,QAAA,YAKA,QAAAC,IAAAF,GACA,MAAAA,GAAAC,QAAA,WAAAA,QAAA,WAEA,QAAArD,IAAA1K,GAEA,WAAAA,EAAA5J,OACA,GACA,IAAA4J,EAAA9G,IAAA2U,IAAAvF,KAAA,KAEA,QAAApI,IAAAF,GAEA,GAAAiO,GAAAjO,EAAAkO,MAAA,KAAAhV,IAAA8U,GAGA,YAAAC,EAAA,GAAAA,EAAA7Z,MAAA,GAAA6Z,EAGA,QAAAE,MACA,MAAApR,IAAA9G,MAAA,IAAAA,KAAAmY,KAAA,UAEA,QAAAC,IAAAza,GACAA,GACAkL,GAAA,6CACA,IAAAF,EACA,IAAAsD,GAAAtO,GACAgL,EAAA7B,GAAAnJ,OAEA,KAAAgY,GAAAhY,GAMA,MAAAkL,IAAA,mDALA,IAAAwP,GAAAvR,GAAA9G,MAAA6B,KACAyW,OACA3P,GAAA7B,GAAAuR,EAAAxT,OAAAlH,IAQA,MAHAgL,GAAA4P,qBACA1P,GAAA,2FACA7I,KAAA2N,IAAAhF,EAAA6P,WAAA7P,EAAAhL,OACAqC,KA2LA,QAAAyY,IAAAC,GACA,UAAAC,IAAA,eAAAD,EAAA9J,KAAA,IAAA8J,GAGA,QAAAE,MACA,MAAA9R,IAAA9G,MAAA,IAAAA,KAAAG,OAAA,UA+JA,QAAA0Y,IAAAH,GAKA,UAAAI,IAAAJ,EAAA9J,KAAA,KAAA8J,GAEA,QAAAK,IAAAvP,EAAAwP,EAAAC,EAAAC,EAAAC,GAEA,OADAC,GAAAC,EAAAC,GAAA,EAAAC,EAAAhb,OACAqO,EAAA,EACA0M,EAAA1M,GAAAsM,EAAA/Y,OAAA,EACAiZ,EAAAH,EAAArM,GACAyM,EAAAC,EAAAJ,EAAAtM,GAAArO,OAGA4V,GAAAkF,KACAA,IAAA1P,aAEAyP,GAAAE,EAToB1M,IAapB,GAAA0M,EAMA,GAAAF,EASA,GAAAI,GAAAJ,EAAAC,GACAJ,EAAArM,GAAA6M,GAAAT,EAAAxP,EAAA,GAAA2P,EAAAvM,GAAAyM,EAAAD,OAGA,CACAG,EAAAhb,MAEA,QAAAmb,GAAA9M,EAA2B8M,EAAAT,EAAA9Y,OAAqBuZ,IAChD,GAAAF,GAAAP,EAAAS,GAAAL,GAAA,CACAE,EAAAN,EAAA7C,OAAAsD,EAAA,KACA,OAGAT,EAAA7C,OAAAxJ,EAAA,EAAA6M,GAAAT,EAAAxP,EAAA,GAAA2P,EAAAvM,GAAAyM,EAAAE,QApBAtN,IAAAoN,IAAAvS,GAAAuS,GAAA7P,YAEAX,GAAA,+HAAAW,EAAAO,KAAA,IAAAoP,EAAAvM,GAAA,+BAAA9F,GAAAuS,GAAAtP,KAAA,KAEAkP,EAAA7C,OAAAxJ,EAAA,EAAA6M,GAAAT,EAAAxP,EAAA,GAAA2P,EAAAvM,GAAAyM,QAXAD,GAAAhO,MACA6N,EAAA7C,OAAAxJ,EAAA,GACAA,GA4BA,OAAAqM,GAGA,QAAAQ,IAAAT,EAAAxP,EAAA8B,EAAA+N,EAAAD,GAIA,GAFAlG,GAAA8F,EAAAK,GAEApN,GAAAoN,GAAA,CACA,GAAAM,GAAA7S,GAAAuS,EAGA,IAFAM,EAAA/I,cAEA,OAAA+I,EAAAnQ,QAAAmQ,EAAAnQ,WAIA,MAHAmQ,GAAA7F,UAAAtK,EAAA8B,GACA8N,OAAAO,GACAP,EAAAhO,MACAuO,EAIA,GAAAP,EAAA,CACA,GAAAQ,GAAAZ,EAAAa,UAAAT,EAAAC,EAEA,OADAO,GAAA9F,UAAAtK,EAAA8B,GACAsO,EAGA,GAAAE,GAAAd,EAAAe,YAAAvQ,EAAA8B,EAAA9B,EAAAwB,aAAAqO,EACA,OAAAS,GAGA,QAAAN,IAAAJ,EAAAC,GAEA,MAAApN,IAAAoN,GACAvS,GAAAuS,KAAAD,KAGAzD,GAAA0D,IAAAD,EAAAjQ,WAAAkQ,OAGAD,YAAApF,KACA,OAAAoF,EAAAZ,YACAY,EAAAb,qBACA1J,GAAAwK,IACAA,EAAAD,EAAAb,uBAAAa,EAAAZ,YAaA,QAAAwB,MACA,MAAAlT,IAAA9G,MAAAia,WAOA,QAAAC,IAAAC,GAEA,MAAA7c,QAAA8c,KAAAD,GAAA9b,OAAA,SAAA8b,EAAAjc,GAEA,GAAAA,IAAAmc,IACA,MAAAxR,IAAA,SAAA3K,EAAA,4EAEA,IAAAd,GAAAE,OAAA4D,yBAAAiZ,EAAAjc,EACA,QAAAd,IACAyL,GAAA,oEAGA,IAAAlL,GAAAP,EAAAO,KACA,WAAAA,EACAkL,GAAA,2IAGA,IAAA6F,GAAA/Q,GACA,MAAAL,QAAAgd,UAAmCH,GAAAhS,KACnCA,EAAAjK,GAAAqc,GAAAC,GAAA7c,MACAwK,GAGA,IAAA+E,EAAAvP,GACA,MAAAwc,EAIAtR,IADA,kBAAAlL,GACA,+DAGA,gBAAAA,GACA,gBAAAO,EAAA,uDAAAP,EAAA,IAIA,kCAAAO,EAAA,KAEA,GAAAiK,IACKgS,GAuSL,QAAAM,MAEA,OADAra,MACAqV,EAAA,EAAoBA,EAAAvV,UAAAC,OAAuBsV,IAC3CrV,EAAAqV,GAAAvV,UAAAuV,EAEA,IAAA7G,GAAA,gBAAAxO,GAAA,GAAAA,EAAAsa,QAAA,iBACAP,EAAA/Z,EAAAsa,WACA,WAAAC,KAA6B/L,OAAAuL,eAU7B,QAAAS,MAEA,OADAxa,MACAqV,EAAA,EAAoBA,EAAAvV,UAAAC,OAAuBsV,IAC3CrV,EAAAqV,GAAAvV,UAAAuV,EAGA,IAAAoF,GAAA,gBAAAza,GAAA,GAAAA,EAAAsa,QAAA,gBAQA,OAAAta,GACA/B,OAAA,SAAAyc,EAAAC,GACA,MAAAD,GAAAE,iBACApM,KAAAkM,EAAAlM,KAAA,IAAAmM,EAAAnM,KACAuL,WAAAY,EAAAZ,WACAc,aAAAF,EAAAE,iBAGAC,MAAAL,GAsGA,QAAAL,IAAA7c,GACA,aAAAA,IACA,aACA,MAAAwd,GACA,cACA,MAAAC,GACA,eACA,MAAAC,GACA,cACA,GAAA1d,YAAA4Q,MACA,MAAA+M,IAEA,MAAAzS,IAAA,8CAAAlL,GAEA,QAAAgV,IAAA9Q,GACA,MAAAqL,GAAArL,KACAA,EAAA0Z,OAAAC,GAAAC,OAAAD,GAAAE,OAAAF,GAAAG,QAAAH,GAAAjN,OACA,EA2CA,QAAAqN,IAAAje,GAMA,UAAAke,IAAAle,GA4DA,QAAAme,MAEA,OADA1b,MACAqV,EAAA,EAAoBA,EAAAvV,UAAAC,OAAuBsV,IAC3CrV,EAAAqV,GAAAvV,UAAAuV,EAEA,IAAA7G,GAAA,gBAAAxO,GAAA,GAAAA,EAAAsa,QAAAxN,EAAA9M,EAAA,IAAAA,EAAA,GAAAwO,KAAA,KACA/M,EAAAzB,EAAA,GACA2b,EAAA3b,EAAA,GACAsS,EAAAtS,EAAA,GACAA,EAAA,GACA,SAAAuP,GAAwB,wDAcxB,WAAAqM,IAAApN,EAAA/M,EAAAka,EAAArJ,GAkBA,QAAAuJ,IAAArN,EAAAsN,GACA,GAAAC,GAAA,gBAAAvN,GAAAsN,EAAAtN,EAQA/M,EAAAua,GAAA3b,MAAA,OAAA0b,EAAAlZ,IAAA,SAAAoZ,GAAyE,MAAAT,IAAA,GAAAS,KAGzE,OAFA,gBAAAzN,KACA/M,EAAA+M,QACA/M,EA+EA,QAAAua,IAAAE,GAEA,OADAC,MACA9G,EAAA,EAAoBA,EAAAvV,UAAAC,OAAuBsV,IAC3C8G,EAAA9G,EAAA,GAAAvV,UAAAuV,EAEA,IAAA+G,GAAAtP,EAAAoP,GAAA,KAAAA,EACA9Y,EAAA0J,EAAAoP,GAAAC,EAAA7b,OAAA4b,GAAAC,EACA3N,EAAA,IAAApL,EAAAP,IAAA,SAAApB,GAAgD,MAAAA,GAAA+M,OAAoByD,KAAA,UAUpE,WAAAoK,IAAA7N,EAAApL,EAAAgZ,GA+EA,QAAAjC,IAAA1Y,EAAA6a,GAYA,UAAAC,IAAA9a,EAAA6a,GAcA,QAAAE,IAAA/a,GAQA,MAAAua,IAAAS,GAAAhb,GA2EA,QAAAib,IAAAC,EAAAC,GACA,GAAApO,GAAA,gBAAAmO,KAAA,QAAAA,EAAA9C,WAAA,IACApY,EAAA,gBAAAkb,GAAAC,EAAAD,CAOA,WAAAE,IAAArO,EAAA/M,GAmLA,QAAAqb,IAAA5E,EAAA4D,GAQA,MAAAA,GACA,GAAAiB,IAAA7E,EAAA4D,GAEA,GAAAkB,IAAA9E,GAyDA,QAAAhO,IAAA6E,GAMA,MALA,UAAAA,IAA8BA,EAAAgM,IAK9B,GAAAkC,IAAAlO,GA3zHA7R,OAAAC,eAAAZ,EAAA,cAA8CgB,OAAA,GAE9C,IAsmCA6d,IAtmCAlM,GAAA1S,EAAA,IAmmBAyP,GAAA/O,OAAAggB,iBACM/c,uBAAgBF,QAAA,SAAAqJ,EAAApB,GAAsCoB,EAAAnJ,UAAA+H,IAC5D,SAAAoB,EAAApB,GAAqB,OAAAmE,KAAAnE,KAAAhH,eAAAmL,KAAA/C,EAAA+C,GAAAnE,EAAAmE,KA2BrByH,GAAA,WACA,QAAAA,GAAArS,EAAA2H,EAAA8B,EAAAgI,EAAAC,EAAA5J,EAAA4T,EAAA9J,GACA,SAAAA,IAA6CA,EAAAE,IAC7C3T,KAAAsL,QAAA,GACAtL,KAAAgL,aAAAzM,OACAyB,KAAAwd,YAAA,EACAxd,KAAAyd,MAAAC,GAAAC,aACA3d,KAAA6B,OACA7B,KAAA2J,cACA3J,KAAA4d,QAAApU,EACAxJ,KAAAsL,UACAtL,KAAA2J,cACA3J,KAAAgL,aAAAsI,EACAtT,KAAA6d,MAAA7d,KAAA6d,MAAAvZ,KAAAtE,MACAud,GACAzH,GAAA9V,KAAA2J,YAAA,YAAA3J,KACA,IAAA8d,IAAA,CACA,KACAP,GACAzH,GAAA9V,KAAA2J,YAAA,SAAAyK,IACAX,EAAAzT,KAAAuT,GACAvT,KAAAyd,MAAAC,GAAAK,QACAD,GAAA,EAEA,QACAA,IAEA9d,KAAAyd,MAAAC,GAAAM,OAwFA,MApFA1gB,QAAAC,eAAA2W,EAAArT,UAAA,QAIAiE,IAAA,WACA,MAAA9E,MAAAwJ,OAEAxJ,KAAAwJ,OAAAO,KAAA,IAAA6N,GAAA5X,KAAAsL,SADA,IAGA9N,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAA2W,EAAArT,UAAA,UACAiE,IAAA,WACA,cAAA9E,KAAAwJ,QAEAhM,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAA2W,EAAArT,UAAA,UACAiE,IAAA,WACA,MAAA9E,MAAA4d,SAEApgB,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAA2W,EAAArT,UAAA,QACAiE,IAAA,WAEA,MAAA9E,MAAA4d,QAEA5d,KAAA4d,QAAA/T,KADAhB,GAAA,2CAGArL,YAAA,EACAC,cAAA,IAEAyW,EAAArT,UAAAiT,UAAA,SAAAmK,EAAA3S,GACA,SAAAA,IAAiCA,EAAA,MACjCtL,KAAAwJ,SAAAyU,GACApV,GAAA,0CACA7I,KAAAsL,cAEAtL,KAAAsL,WAAA,KAEAhO,OAAAC,eAAA2W,EAAArT,UAAA,SACAiE,IAAA,WACA,MAAA9E,MAAA6B,KAAAqc,SAAAle,OAEAxC,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAA2W,EAAArT,UAAA,YACAiE,IAAA,WACA,GAAAqE,GAAAnJ,KAAA6B,KAAAsc,YAAAne,KAKA,OAAAmJ,IAEA3L,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAA2W,EAAArT,UAAA,WACAiE,IAAA,WACA,MAAA9E,MAAAyd,QAAAC,GAAAM,MAEAxgB,YAAA,EACAC,cAAA,IAEAyW,EAAArT,UAAAgd,MAAA,SAAA/D,GACA,MAAAA,IAAA9Z,KAAAwd,cAAA,EACA1D,EAAAnc,MACAmc,GAEA5F,EAAArT,UAAAoZ,SAAA,WACA,MAAAja,MAAA6B,KAAA+M,KAAA,KAAA5O,KAAA+J,MAAA,WAAA/J,KAAAwL,QAAA,cAEA0I,EAAArT,UAAAuK,IAAA,WACApL,KAAAyd,MAAAC,GAAAM,MAEAnR,GACAyC,GAAAxO,YACAoT,EAAArT,UAAA,kBACAqT,KAGAkK,GAAA,EACApK,GAAA,WACA,QAAAA,GAAAnS,EAAA2H,EAAA8B,EAAAgI,EAAAC,EAAA5J,EAAA4T,EAAA9J,GACA,SAAAA,IAA6CA,EAAAE,GAC7C,IAAA7T,GAAAE,IACAA,MAAAqe,SAAAD,GACApe,KAAAsL,QAAA,GACAtL,KAAA4d,QAAA,KACA5d,KAAAyQ,kBAAA,EACAzQ,KAAA8I,qBAAA,EACA9I,KAAAuY,oBAAAha,OACAyB,KAAAgL,aAAAzM,OACAyB,KAAAwd,YAAA,EACAxd,KAAAyd,MAAAC,GAAAC,aACA3d,KAAA4R,YAAAF,GACA1R,KAAA6B,OACA7B,KAAA2J,cACA3J,KAAA4d,QAAApU,EACAxJ,KAAAsL,UACAtL,KAAAgL,aAAAsI,EACAtT,KAAA6d,MAAA7d,KAAA6d,MAAAvZ,KAAAtE,MACAA,KAAAse,UACA9U,IACAxJ,KAAAuK,gBAAA,GAAAgU,KACAhB,GACAzH,GAAA9V,KAAA2J,YAAA,YAAA3J,KACA,IAAA8d,IAAA,CACA,KACAP,GACAzH,GAAA9V,KAAA2J,YAAA,SAAAyK,IACApU,KAAAyQ,kBAAA,EACAgD,EAAAzT,KAAAuT,GACAvT,KAAAyQ,kBAAA,EACAjH,EACAA,EAAAK,KAAAU,gBAAAiU,eAAAxe,MAEAA,KAAAuK,gBAAAiU,eAAAxe,MACAA,KAAAye,SAAA,eACAze,KAAAyd,MAAAC,GAAAK,QACAD,GAAA,EAEA,QACAA,IAEA9d,KAAAyd,MAAAC,GAAAM,MAGA,GAAAU,GAAApP,GAAAqP,SAAA,WAA0D,MAAA7e,GAAAqJ,UAAyB,SAAAA,GACnFrJ,EAAA8e,aAAAzV,IAEAuV,GAAAG,QAAA,SAAArc,GACA,KAAAA,KAEAxC,KAAA0L,YAAAgT,GAwTA,MAtTAphB,QAAAC,eAAAyW,EAAAnT,UAAA,QAIAiE,IAAA,WACA,MAAA9E,MAAAwJ,OAEAxJ,KAAAwJ,OAAAO,KAAA,IAAA6N,GAAA5X,KAAAsL,SADA,IAGA9N,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAAyW,EAAAnT,UAAA,UACAiE,IAAA,WACA,cAAA9E,KAAAwJ,QAEAhM,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAAyW,EAAAnT,UAAA,UACAiE,IAAA,WACA,MAAA9E,MAAA4d,SAEApgB,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAAyW,EAAAnT,UAAA,QAEAiE,IAAA,WAEA,IADA,GAAA2H,GAAAM,EAAA/M,KACAyM,EAAAM,EAAAvD,QACAuD,EAAAN,CACA,OAAAM,IAEAvP,YAAA,EACAC,cAAA,IAEAuW,EAAAnT,UAAAiT,UAAA,SAAAmK,EAAA3S,GACA,SAAAA,IAAiCA,EAAA,MACjCtL,KAAAwJ,SAAAyU,GAAAje,KAAAsL,cAEA2S,IACAje,KAAA4d,SAAAK,IAAAje,KAAA4d,SACA/U,GAAA,+DAAA7I,KAAA,aAAAie,EAAAlU,KAAA,IAAAuB,EAAA,MAEAtL,KAAA4d,SAAAK,EAAApU,OAAA7J,MACA6I,GAAA,gEAAA7I,KAAA,aAAAie,EAAAlU,KAAA,IAAAuB,EAAA,MAEAtL,KAAA4d,SACA5d,KAAA6J,KAAAmB,cACAhL,KAAA6J,KAAAmB,eAAAiT,EAAApU,KAAAmB,cACAnC,GAAA,wGAGA7I,KAAAwJ,SAAAyU,EACAje,KAAAoL,OAGApL,KAAAsL,WAAA,GACA2S,OAAAje,KAAA4d,UACAK,EAAApU,KAAAU,gBAAAuU,WAAA9e,MACAA,KAAA4d,QAAAK,EACAje,KAAAye,SAAA,mBAIAzK,EAAAnT,UAAA4d,SAAA,SAAA7P,GACA,GAAA2B,GAAAvQ,KAAA2J,aAAA,gBAAA3J,MAAA2J,aAAA3J,KAAA2J,YAAAiF,EACA,mBAAA2B,IACAA,EAAA9P,MAAAT,KAAA2J,cAEArM,OAAAC,eAAAyW,EAAAnT,UAAA,SACAiE,IAAA,WACA,GAAA9E,KAAAwL,QAEA,MAAAxL,MAAA6B,KAAAqc,SAAAle,OAEAxC,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAAyW,EAAAnT,UAAA,YACAiE,IAAA,WACA,GAAA9E,KAAAwL,QAAA,CAGA,GAAArC,GAAAnJ,KAAA6B,KAAAsc,YAAAne,KAKA,OAAAmJ,KAEA3L,YAAA,EACAC,cAAA,IAEAuW,EAAAnT,UAAAke,gBAAA,WACA,QAAA/e,KAAAyQ,mBAEAzQ,KAAA4I,QAEA5I,KAAAwJ,OAAAuV,mBAEAzhB,OAAAC,eAAAyW,EAAAnT,UAAA,cACAiE,IAAA,WACA,MAAA9E,MAAAuY,oBAAAvY,KAAA2J,YAAA3J,KAAAuY,qBAAA,MAEA/a,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAAyW,EAAAnT,UAAA,WACAiE,IAAA,WACA,MAAA9E,MAAAyd,QAAAC,GAAAM,MAEAxgB,YAAA,EACAC,cAAA,IAEAuW,EAAAnT,UAAA+P,YAAA,WACA5Q,KAAAwL,SACA3C,GAAA7I,KAAA,sLAEAgU,EAAAnT,UAAAiU,aAAA,SAAAxJ,GACAtL,KAAA4Q,cACA5Q,KAAAwd,YAAA,CACA,IAAA3P,GAAA7N,KAAA6B,KAAAiT,aAAA9U,KAAAsL,EAEA,OADAtL,MAAAwd,YAAA,EACA3P,GAEAmG,EAAAnT,UAAAmL,YAAA,WACAhM,KAAA4Q,cACA5Q,KAAAwd,YAAA,CACA,IAAA3P,GAAA7N,KAAA6B,KAAAmK,YAAAhM,KAEA,OADAA,MAAAwd,YAAA,EACA3P,GAEAmG,EAAAnT,UAAAoG,aAAA,SAAA/I,GACA,MAAA8B,MAAA6B,KAAAoF,aAAA/I,IAEAZ,OAAAC,eAAAyW,EAAAnT,UAAA,eACAiE,IAAA,WACA,MAAA9E,MAAA6J,KAAAf,qBAEAtL,YAAA,EACAC,cAAA,IAEAuW,EAAAnT,UAAAme,eAAA,WACAhf,KAAA4Q,eACA5Q,KAAA+e,mBAAA/e,KAAAiJ,aACAJ,GAAA,kBAAA7I,KAAA,4EAGAgU,EAAAnT,UAAAwK,YAAA,SAAAC,GACAtL,KAAA6B,KAAAwJ,YAAArL,KAAAsL,IAEA0I,EAAAnT,UAAAgd,MAAA,SAAA/D,GACA,MAAAA,IAAA9Z,KAAAwd,cAAA,EACA1D,EAAAnc,MACAmc,GAEA9F,EAAAnT,UAAAoZ,SAAA,WACA,GAAA3P,GAAAtK,KAAAwY,WAAA,QAAAxY,KAAAwY,WAAA,MACA,OAAAxY,MAAA6B,KAAA+M,KAAA,KAAA5O,KAAA+J,MAAA,UAAAO,GAAAtK,KAAAwL,QACA,GACA,WAEAwI,EAAAnT,UAAAoT,iBAAA,WAEA,GAAAjU,KAAAyd,QAAAC,GAAAK,QAAA,CACA,GAAA/d,KAAAwJ,OAAA,CACA,GAAAxJ,KAAAwJ,OAAAiU,QAAAC,GAAAuB,UAEA,MAEAjf,MAAAye,SAAA,eAEAze,KAAAyd,MAAAC,GAAAuB,SACA,QAAAxJ,GAAA,EAAAtN,EAAAnI,KAAAgM,cAAqDyJ,EAAAtN,EAAAhI,OAAgBsV,IAAA,CACrE,GAAAzO,GAAAmB,EAAAsN,EACAzO,aAAAgN,IACAhN,EAAAiN,sBAIAD,EAAAnT,UAAAqK,OAAA,WACAlL,KAAAwL,SACA3C,GAAA,6CACA7I,KAAA4I,SAGA5I,KAAAye,SAAA,gBACAze,KAAAgL,aAAAhL,KAAA6J,KAAAmB,aACAhL,KAAAyd,MAAAC,GAAAwB,UACAlf,KAAAuK,gBAAAvK,KAAA6J,KAAAU,gBAAA4U,WAAAnf,MACAA,KAAAwJ,OAAA6B,YAAArL,KAAAsL,SACAtL,KAAA4d,QAAA,KACA5d,KAAAsL,QAAA,GACAtL,KAAAyd,MAAAC,GAAAuB,YAGAjL,EAAAnT,UAAAyd,QAAA,WACA,GAAAxe,GAAAE,IACAA,MAAAof,aACApf,KAAA4R,eACA5R,KAAAqf,uBACArf,KAAAsf,oBAGAtf,KAAAyH,aAAAsJ,EAAA/Q,KAAA2J,YAAA,0BAAAzB;AACAA,EAAAjK,QAAA,SAAAuJ,GACA,GAAAwQ,GAAA/N,GAAAzC,EAAAuC,MACApB,EAAAgM,GAAA7U,EAAAkY,EAAA7Z,MAAA,MACAwK,GAAA4W,kBAAAvH,IAAA7X,OAAA,GAAAqH,OAESlD,KAAAtE,KAAA2J,aACT3J,KAAAoJ,cAAA2H,EAAA/Q,KAAA2J,YAAA,2BAAAR,GAEA,GAAAA,IAAArJ,EAAAqJ,SAGA,MAAArJ,GAAA+B,KAAAuH,cAAAtJ,EAAAqJ,KACS7E,KAAAtE,KAAA2J,cAETqK,EAAAnT,UAAAuK,IAAA,WACApL,KAAAyd,QAAAC,GAAAwB,WAEAjT,GAAAjM,KAAA2J,eAEAmC,EAAA9L,KAAA2J,YAAA,SAAA3C,GACA,GAAA2B,GAAA7B,GAAAE,EACA2B,aAAAqL,IACArL,EAAA6W,eAEA1T,EAAA9L,KAAA2J,YAAA,SAAA3C,GACA,GAAA2B,GAAA7B,GAAAE,EACA2B,aAAAqL,IACArL,EAAA8W,oBAIAzL,EAAAnT,UAAA2e,WAAA,WACAxf,KAAAof,UAAAhJ,OAAA,GAAAnY,QAAA,SAAAyhB,GAAuD,MAAAA,OACvD1f,KAAAye,SAAA,kBAEAzK,EAAAnT,UAAA4e,cAAA,WAEAzf,KAAA6J,KAAAU,gBAAAoV,WAAA3f,KACA,IAAA8D,GAAA9D,KACA4f,EAAA5f,KAAA+J,IACAiM,IAAAhW,KAAA,WAAAA,KAAAmJ,UACAnJ,KAAAsf,iBAAAlJ,OAAA,GACApW,KAAAqf,oBAAAjJ,OAAA,GACApW,KAAAsf,iBAAAlJ,OAAA,GACApW,KAAAyd,MAAAC,GAAAM,KACAhe,KAAA4d,QAAA,KACA5d,KAAAsL,QAAA,GAIAhO,OAAAC,eAAAyC,KAAA2J,YAAA,SACA7E,IAAA,WACA+D,GAAA,+GAAA/E,EACAjC,KACA+M,KAAA,uBAAAgR,EAAA,0NAIA5L,EAAAnT,UAAAyG,WAAA,SAAAvE,GACA,MAAAsT,IAAArW,KAAAqf,oBAAAtc,IAEAiR,EAAAnT,UAAA+d,aAAA,SAAAzV,GACAnJ,KAAAqf,oBAAAphB,QAAA,SAAAyhB,GAAuD,MAAAA,GAAAvW,MAEvD6K,EAAAnT,UAAAuG,QAAA,SAAA2K,GACA,MAAAsE,IAAArW,KAAAsf,iBAAAvN,IAEAiC,EAAAnT,UAAAgf,UAAA,SAAAC,EAAAhV,GACA,GAAA9K,KAAAsf,iBAAAnf,OAAA,CACA,GAAA4f,GAAAvK,MAA0CsK,GAC1C/V,KAAAe,EAAAf,KAAAiW,OAAAhgB,KAAA+J,KAAA5J,QAAA,IAAA2f,EAAA/V,OAEA5B,EAAAoP,GAAAwI,GAAAE,EAAA9X,EAAA,GAAA+X,EAAA/X,EAAA,EACAnI,MAAAsf,iBAAArhB,QAAA,SAAAyhB,GAAwD,MAAAA,GAAAO,EAAAC,KAExDlgB,KAAAwJ,QACAxJ,KAAAwJ,OAAAqW,UAAAC,EAAAhV,IAEAkJ,EAAAnT,UAAA6K,YAAA,SAAA5D,GACA9H,KAAAof,UAAAe,QAAArY,IAEAkM,EAAAnT,UAAAuQ,cAAA,SAAAW,GACA,MAAAsE,IAAArW,KAAA4R,YAAAG,IAEAiC,EAAAnT,UAAA0e,kBAAA,SAAAjU,EAAA9D,GACAxH,KAAAgf,iBACAhf,KAAA6B,KAAA0d,kBAAAvf,KAAAsL,EAAA9D,IAEAqF,GACAyC,GAAAxO,YACAkT,EAAAnT,UAAA,kBACAgM,GACAyC,GAAAxO,YACAkT,EAAAnT,UAAA,kBACAgM,GACAyC,GAAAvK,UACAiP,EAAAnT,UAAA,aACAgM,GACAyC,GAAAvK,UACAiP,EAAAnT,UAAA,cACAgM,GACAyC,GAAAvK,UACAiP,EAAAnT,UAAA,iBACAmT,MAIA,SAAAwH,GACAA,IAAA,mBACAA,IAAA,mBACAA,IAAA,qBACAA,IAAA,eACAA,IAAA,sBACAA,IAAA,kBACAA,IAAA,cACAA,IAAA,qBACAA,IAAA,qBACAA,IAAA,yBACAA,IAAA,4BACAA,IAAA,8BACAA,IAAA,kBACAA,IAAA,8BACAA,IAAA,qBACAA,IAAA,mBACAA,IAAA,8BACCA,YAID,IAypBAkC,IAzpBA0C,GAAA,WACA,QAAAA,GAAAxR,GACA5O,KAAAmN,QAAA,EACAnN,KAAA4O,OAqEA,MAnEAwR,GAAAvf,UAAAgE,OAAA,SAAAsE,EAAAmK,GAGA,MAFA,UAAAnK,IAAkCA,EAAAnJ,KAAAqgB,sBAClCnN,GAAAlT,KAAAmJ,GACAnJ,KAAA+Z,YAAA,QAAAzG,EAAAnK,GAAAxL,OAEAyiB,EAAAvf,UAAAyf,iBAAA,SAAAze,GACA,MAAAA,KAAA7B,MAEAogB,EAAAvf,UAAAuS,SAAA,SAAAzV,EAAAN,GACA,MAAA4O,IAAAtO,GACAiJ,EAAAjJ,KAAAqC,WAAAsgB,iBAAA1Z,EAAAjJ,IACAmV,KACAC,GAAA1V,EAAAM,GAGAqC,KAAAugB,gBAAA5iB,EAAAN,IAEA+iB,EAAAvf,UAAA4R,GAAA,SAAA9U,GACA,MAA6D,KAA7DqC,KAAAoT,SAAAzV,IAAsCoM,KAAA,GAAAlI,KAAA7B,QAAuBG,QAE7DigB,EAAAvf,UAAAgZ,UAAA,SAAAhF,EAAAwE,GACA,GAAAxE,EAAA1L,WAAAkQ,EAEA,MAAAxE,EACA,IAAA5I,GAAAoN,IAAAvS,GAAAuS,KAAAxE,EAEA,MAAAA,EACA,IAAAA,EAAAhT,OAAA7B,MACA2V,GAAA0D,KACApN,GAAAoN,MACAxE,EAAA0D,qBACA1D,EAAA2D,aAAAa,EAAAxE,EAAA0D,sBAIA,MADA1D,GAAAzL,cAAAiQ,GACAxE,CAGA,IAAArL,GAAAqL,EAAArL,OAAA8B,EAAAuJ,EAAAvJ,OAGA,IAFAuJ,EAAAzJ,MAEAa,GAAAoN,IAAArZ,KAAAsgB,iBAAA1Z,EAAAyS,IAAA,CAEA,GAAAmH,GAAA1Z,GAAAuS,EAEA,OADAmH,GAAA1M,UAAAtK,EAAA8B,GACAkV,EAGA,MAAAxgB,MAAA+Z,YAAAvQ,EAAA8B,EAAAuJ,EAAA7J,aAAAqO,IAEA/b,OAAAC,eAAA6iB,EAAAvf,UAAA,QACAiE,IAAA,WACA,MAAA+D,IAAA,0JAEArL,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAA6iB,EAAAvf,UAAA,gBACAiE,IAAA,WACA,MAAA+D,IAAA,0KAEArL,YAAA,EACAC,cAAA,IAEAoP,GACAyC,GAAArO,QACAmf,EAAAvf,UAAA,eACAuf,KAEAK,GAAA,SAAAC,GAEA,QAAAD,GAAA7R,GACA,MAAA8R,GAAA7iB,KAAAmC,KAAA4O,IAAA5O,KAqCA,MAvCAkM,GAAAuU,EAAAC,GAIAD,EAAA5f,UAAAqd,SAAA,SAAAvV,GACA,MAAAA,GAAAgB,aAEA8W,EAAA5f,UAAAsd,YAAA,SAAAxV,GACA,MAAAA,GAAAgB,aAEA8W,EAAA5f,UAAAwf,mBAAA,aAGAI,EAAA5f,UAAAuI,cAAA,SAAAT,EAAAQ,GACAN,GAAA,sDAEA4X,EAAA5f,UAAA0e,kBAAA,SAAA5W,EAAA2C,EAAA9D,GACAqB,GAAA,oDAEA4X,EAAA5f,UAAAmL,YAAA,SAAArD,GACA,MAAA+I,KAEA+O,EAAA5f,UAAAiU,aAAA,SAAAnM,EAAAzK,GACA,MAAA2K,IAAA,aAAA3K,EAAA,wBAAA8B,KAAA4O,OAEA6R,EAAA5f,UAAAoG,aAAA,SAAA/I,GACA,MAAA2K,IAAA,aAAA3K,EAAA,wBAAA8B,KAAA4O,OAEA6R,EAAA5f,UAAAgZ,UAAA,SAAAhF,EAAAwE,GAEA,GAAAxE,EAAAhT,OAAA7B,MAAA6U,EAAAlL,cAAA0P,EACA,MAAAxE,EACA,IAAAhH,GAAA7N,KAAA+Z,YAAAlF,EAAArL,OAAAqL,EAAAvJ,QAAAuJ,EAAA7J,aAAAqO,EAEA,OADAxE,GAAAzJ,MACAyC,GAEA4S,EAAA5f,UAAAwK,YAAA,SAAA1C,EAAA2C,GACA,MAAAzC,IAAA,aAAAyC,EAAA,wBAAAtL,KAAA4O,OAEA6R,GACCL,IA2QD/P,GAAA,EACAM,GAAA,KAiMA4N,GAAA,WACA,QAAAA,KACAve,KAAA2gB,MAAArR,GAAAxO,WAAAmC,MA2DA,MAzDAsb,GAAA1d,UAAA2d,eAAA,SAAA7V,GACA,GAAAA,EAAA4P,oBAAA,CACA,GAAAjO,GAAA3B,EAAA6P,UACAxY,MAAA2gB,MAAAC,IAAAtW,IACAtK,KAAA2gB,MAAAhT,IAAArD,EAAAgF,GAAAxO,WAAA+f,eAEA,IAAAlT,GAAA3N,KAAA2gB,MAAA7b,IAAAwF,EACAqD,GAAAjB,QAAA/D,MAAA,GACAE,GAAA,sBACA8E,EAAAzJ,KAAAyE,GAEA,MAAA3I,OAEAue,EAAA1d,UAAAie,WAAA,SAAAnW,GACA,GAAA7I,GAAAE,IACA2I,GAAA4B,gBAAAoW,MAAAG,SAAA7iB,QAAA,SAAA8iB,GACA,MAAAA,GAAA9iB,QAAA,SAAA+I,GACAlH,EAAA0e,eAAAxX,QAIAuX,EAAA1d,UAAA8e,WAAA,SAAAhX,GACA,GAAAA,EAAA4P,oBAAA,CACA,GAAA5K,GAAA3N,KAAA2gB,MAAA7b,IAAA6D,EAAA6P,WACA7K,IACAA,EAAAsI,OAAAtN,KAGA4V,EAAA1d,UAAAse,WAAA,SAAAxW,GACA,GAAAkF,GAAA,GAAA0Q,GACAyC,EAAArY,EAAAoB,IASA,OARA/J,MAAA2gB,MAAAG,SAAA7iB,QAAA,SAAA8iB,GACA,OAAAnU,GAAAmU,EAAA5gB,OAAA,EAA0CyM,GAAA,EAAQA,IAClD,IAAAmU,EAAAnU,GAAA7C,KAAA2C,QAAAsU,KACAnT,EAAA2Q,eAAAuC,EAAAnU,IACAmU,EAAA3K,OAAAxJ,EAAA,MAIAiB,GAEA0Q,EAAA1d,UAAA2J,QAAA,SAAA3I,EAAAyI,GACA,GAAAqD,GAAA3N,KAAA2gB,MAAA7b,IAAAwF,EACA,KAAAqD,EACA,WACA,IAAAsT,GAAAtT,EAAA1J,OAAA,SAAAid,GAAuD,MAAArf,GAAAye,iBAAAY,EAAArf,OACvD,QAAAof,EAAA9gB,QACA,OACA,WACA,QACA,MAAA8gB,GAAA,EACA,SACA,MAAApY,IAAA,uCAAAhH,EAAA+M,KAAA,eAAAtE,EAAA,kDAAA2W,EACAhe,IAAA,SAAA0O,GAAuC,MAAAA,GAAA5H,OACvCsI,KAAA,SAGAkM,MA6BA,SAAAb,GACAA,IAAA,+BACAA,IAAA,qBACAA,IAAA,yBACAA,IAAA,yBACAA,IAAA,gBACCA,YAuBD,IAAAlJ,IAAA,SAAAa,GAA8B,YA+D9BH,GAAA,qKAgBAxD,GAAApU,OAAA6jB,WACAtV,GAAAvO,OAAA6jB,WA4GAlM,GAAA,YACAA,IAAA,SAAA/R,EAAAwP,KAYAuC,GAAAmM,MA0LA,IAAAzI,IAAA,SAAA+H,GAEA,QAAA/H,GAAA/J,EAAA0J,GACA,GAAAxY,GAAA4gB,EAAA7iB,KAAAmC,KAAA4O,IAAA5O,IAkBA,OAjBAF,GAAAiU,kBAAA,EACAjU,EAAAyb,MAAAC,GAAAjO,IACAzN,EAAA0T,kBAAA,WAEA,GAAAiF,GAAAnJ,GAAAxO,WAAAugB,YAGA,OAFAvL,IAAA2C,EAAA,MAAAL,IACAtC,GAAA2C,EAAA,WAAAP,IACAO,GAEA3Y,EAAA2T,oBAAA,SAAA9K,EAAAQ,GACA,GAAAmY,GAAA3Y,EAAAgB,WACA2F,IAAAiS,OAAAC,eAAAF,EAAA3Y,EAAAkV,OACAvO,GAAAmS,UAAAH,EAAA,SAAAxU,GAAmD,MAAAhN,GAAA4hB,WAAA5U,KACnDnE,EAAAS,cAAAD,GACAmG,GAAAqS,QAAAL,EAAAxhB,EAAA8hB,YAEA9hB,EAAAwY,UACAxY,EAuIA,MA3JAoM,GAAAyM,EAAA+H,GAsBA/H,EAAA9X,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAAnK,GACA,MAAAkK,IAAArT,KAAAwJ,EAAA8B,EAAAgI,EAAAnK,EAAAnJ,KAAAwT,kBAAAxT,KAAAyT,sBAEAkF,EAAA9X,UAAA+R,SAAA,WACA,qBAAA5S,KAAAsY,QAAA1F,WAAA,KAEA+F,EAAA9X,UAAAmL,YAAA,SAAArD,GACA,MAAAA,GAAAgB,YAAAmX,UAEAnI,EAAA9X,UAAAiU,aAAA,SAAAnM,EAAAzK,GACA,GAAA4b,GAAAnR,EAAAgB,YAAA7E,IAAA5G,EAGA,OAFA4b,IACAjR,GAAA,eAAA3K,GACA4b,GAEAnB,EAAA9X,UAAA6gB,WAAA,SAAAG,GACA,GAAAlZ,GAAA7B,GAAA+a,EAAAhb,OAEA,QADA8B,EAAAqW,iBACA6C,EAAAhgB,MACA,aAEA,GAAAwX,GAAAwI,EAAAxI,SACA1B,EAAAkK,EAAAhb,OAAA/B,IAAA+c,EAAAjT,KACA,IAAAyK,IAAA1B,EACA,WACAzE,IAAAlT,KAAAsY,QAAAe,GACAwI,EAAAxI,SAAArZ,KAAAsY,QAAAuB,UAAAlR,EAAAmM,aAAA+M,EAAAjT,MAAAiT,EAAAxI,UACArZ,KAAA8hB,iBAAAD,EAAAjT,KAAAiT,EAAAxI,SAEA,MACA,WAEAnG,GAAAlT,KAAAsY,QAAAuJ,EAAAxI,UACAwI,EAAAxI,SAAArZ,KAAAsY,QAAAyB,YAAApR,EAAAkZ,EAAAjT,KAAArQ,OAAAsjB,EAAAxI,UACArZ,KAAA8hB,iBAAAD,EAAAjT,KAAAiT,EAAAxI,UAIA,MAAAwI,IAEAlJ,EAAA9X,UAAAihB,iBAAA,SAAAC,EAAApZ,GACA,GAAAA,YAAAqL,IAAA,CACA,GAAA1J,GAAA3B,EAAA6P,UACA,QAAAlO,GAAA,GAAAA,GAAA,GAAAyX,GACAlZ,GAAA,6HAAAyB,EAAA,qBAAAyX,EAAA,OAGApJ,EAAA9X,UAAAqd,SAAA,SAAAvV,GACA,MAAAA,GAAAgB,aAEAgP,EAAA9X,UAAAsd,YAAA,SAAAxV,GACA,GAAAkF,KAIA,OAHAlF,GAAAqD,cAAA/N,QAAA,SAAA6b,GACAjM,EAAAiM,EAAAxO,SAAAwO,EAAA3Q,WAEA0E,GAEA8K,EAAA9X,UAAA+gB,UAAA,SAAAC,GACA,GAAAlZ,GAAA7B,GAAA+a,EAAAhb,OACA,QAAAgb,EAAAhgB,MACA,aACA,WAAA8G,GAAAkX,WACAnI,GAAA,UACA3N,KAAA6N,GAAAiK,EAAAjT,MACAjR,MAAAkkB,EAAAxI,SAAAlQ,SACAwO,SAAAkK,EAAAlK,SAAAkK,EAAAlK,SAAAxO,SAAA5K,QACiBoK,EACjB,WACA,WAAAA,GAAAkX,WACAnI,GAAA,MACA3N,KAAA6N,GAAAiK,EAAAjT,MACAjR,MAAAkkB,EAAAxI,SAAAlQ,SACAwO,SAAApZ,QACiBoK,EACjB,cAEA,GAAAqZ,GAAAH,EAAAlK,SAAAxO,QAGA,OAFA0Y,GAAAlK,SAAAvM,UAEAzC,GAAAkX,WAA4CnI,GAAA,SAAA3N,KAAA6N,GAAAiK,EAAAjT,MAAA+I,SAAAqK,GAA4ErZ,KAGxHgQ,EAAA9X,UAAA0e,kBAAA,SAAA5W,EAAA2C,EAAA9D,GACA,GAAAtK,GAAAyL,EAAAgB,WACA,QAAAnC,EAAAkQ,IACA,UACA,cACAxa,EAAAyQ,IAAArC,EAAA9D,EAAA7J,MACA,MACA,cACAT,EAAAgR,OAAA5C,KAIAqN,EAAA9X,UAAAuI,cAAA,SAAAT,EAAAQ,GACA+J,GAAAlT,KAAAmJ,EACA,IAAAjM,GAAAyL,EAAAgB,YACAsY,IACA/kB,GAAAkd,OAAAnc,QAAA,SAAAC,GACA+jB,EAAA/jB,IAAA,IAGAZ,OAAA8c,KAAAjR,GAAAlL,QAAA,SAAAC,GACAhB,EAAAyQ,IAAAzP,EAAAiL,EAAAjL,IACA+jB,EAAA/jB,IAAA,IAEAZ,OAAA8c,KAAA6H,GAAAhkB,QAAA,SAAAC,GACA+jB,EAAA/jB,MAAA,GACAhB,EAAAgR,OAAAhQ,MAGAya,EAAA9X,UAAAoG,aAAA,SAAA/I,GACA,MAAA8B,MAAAsY,SAEAK,EAAA9X,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,GAAAyC,GAAAE,IACA,OAAA6O,IAAAlR,GAGAqV,GAAA1V,OAAA8c,KAAAzc,GAAAsF,IAAA,SAAA8G,GACA,MAAAjK,GAAAwY,QAAAlF,SAAAzV,EAAAoM,GAAA8I,GAAAxV,EAAA0M,EAAAjK,EAAAwY,aAHAvF,GAAA1V,EAAAM,EAAA,gCAMAgb,EAAA9X,UAAAwf,mBAAA,WACA,UAEA1H,EAAA9X,UAAAwK,YAAA,SAAA1C,EAAA2C,GAEA3C,EAAAgB,YAAAuE,OAAA5C,IAEAuB,GACAyC,GAAArO,QACA0X,EAAA9X,UAAA,sBACA8X,GACCyH,IAmCDtH,GAAA,SAAA4H,GAEA,QAAA5H,GAAAlK,EAAA0J,GACA,GAAAxY,GAAA4gB,EAAA7iB,KAAAmC,KAAA4O,IAAA5O,IAgBA,OAfAF,GAAAiU,kBAAA,EACAjU,EAAAyb,MAAAC,GAAAnb,MACAP,EAAA0T,kBAAA,WACA,GAAAqF,GAAAvJ,GAAAxO,WAAA+f,cAEA,OADA/K,IAAA+C,EAAA,WAAAD,IACAC,GAEA/Y,EAAA2T,oBAAA,SAAA9K,EAAAQ,GACA,GAAAmY,GAAA3Y,EAAAgB,WACA2F,IAAAiS,OAAAW,kBAAAZ,GAAAa,SAAAxZ,EAAAkV,MACAvO,GAAAmS,UAAAH,EAAA,SAAAO,GAAwD,MAAA/hB,GAAA4hB,WAAAG,KACxDlZ,EAAAS,cAAAD,GACAmG,GAAAqS,QAAAL,EAAAxhB,EAAA8hB,YAEA9hB,EAAAwY,UACAxY,EAgHA,MAlIAoM,GAAA4M,EAAA4H,GAoBA5H,EAAAjY,UAAA+R,SAAA,WACA,MAAA5S,MAAAsY,QAAA1F,WAAA,MAEAkG,EAAAjY,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAAnK,GACA,MAAAkK,IAAArT,KAAAwJ,EAAA8B,EAAAgI,EAAAnK,EAAAnJ,KAAAwT,kBAAAxT,KAAAyT,sBAEAqF,EAAAjY,UAAAmL,YAAA,SAAArD,GACA,MAAAA,GAAAgB,YAAAyY,QAEAtJ,EAAAjY,UAAAiU,aAAA,SAAAnM,EAAAzK,GACA,GAAAmQ,GAAAgU,SAAAnkB,EAAA,GACA,OAAAmQ,GAAA1F,EAAAgB,YAAAxJ,OACAwI,EAAAgB,YAAA0E,GACAxF,GAAA,gBAAA3K,IAEA4a,EAAAjY,UAAA6gB,WAAA,SAAAG,GACA,GAAAlZ,GAAA7B,GAAA+a,EAAAhb,OACA8B,GAAAqW,gBACA,IAAAsD,GAAA3Z,EAAAqD,aACA,QAAA6V,EAAAhgB,MACA,aACA,GAAAggB,EAAAxI,WAAAwI,EAAAhb,OAAAgb,EAAAxT,OACA,WACAwT,GAAAxI,SAAAN,GAAApQ,EAAA3I,KAAAsY,SAAAgK,EAAAT,EAAAxT,SAAAwT,EAAAxI,WAAAwI,EAAAxT,QAAA,EACA,MACA,cACA,GAAAkU,GAAAV,EAAAxT,MAAAmU,EAAAX,EAAAW,aAAAC,EAAAZ,EAAAY,KACAZ,GAAAY,MAAA1J,GAAApQ,EAAA3I,KAAAsY,QAAAgK,EAAAnkB,MAAAokB,IAAAC,GAAAC,IAAAxf,IAAA,SAAAoS,EAAAzI,GAA+J,MAAA2V,GAAA3V,IAE/J,QAAAA,GAAA2V,EAAAC,EAAoD5V,EAAA0V,EAAAniB,OAAuByM,IAC3E0V,EAAA1V,GAAAkH,UAAAnL,EAAA,IAAAiE,EAAA6V,EAAAtiB,OAAAqiB,IAIA,MAAAX,IAEA/I,EAAAjY,UAAAqd,SAAA,SAAAvV,GACA,MAAAA,GAAAgB,aAEAmP,EAAAjY,UAAAsd,YAAA,SAAAxV,GACA,MAAAA,GAAAqD,cAAA/I,IAAA,SAAA6W,GAA4D,MAAAA,GAAA3Q,YAE5D2P,EAAAjY,UAAA+gB,UAAA,SAAAC,GACA,GAAAlZ,GAAA7B,GAAA+a,EAAAhb,OACA,QAAAgb,EAAAhgB,MACA,aACA,WAAA8G,GAAAkX,WACAnI,GAAA,UACA3N,KAAA,GAAA8X,EAAAxT,MACA1Q,MAAAkkB,EAAAxI,SAAAlQ,SACAwO,SAAAkK,EAAAlK,SAAAkK,EAAAlK,SAAAxO,SAAA5K,QACiBoK,EACjB,cACA,OAAAiE,GAAAiV,EAAAW,aAAA,EAAqD5V,GAAA,EAAQA,IAC7DjE,EAAAkX,WACAnI,GAAA,SACA3N,KAAA,IAAA8X,EAAAxT,MAAAzB,GACA+K,SAAAkK,EAAAa,QAAA9V,GAAAzD,UACqBR,EACrB,QAAAiE,GAAA,EAA+BA,EAAAiV,EAAAc,WAAuB/V,IACtDjE,EAAAkX,WACAnI,GAAA,MACA3N,KAAA,IAAA8X,EAAAxT,MAAAzB,GACAjP,MAAAgL,EAAAmM,aAAA,IAAA+M,EAAAxT,MAAAzB,IAAAzD,SACAwO,SAAApZ,QACqBoK,EACrB,UAGAmQ,EAAAjY,UAAA0e,kBAAA,SAAA5W,EAAA2C,EAAA9D,GACA,GAAAtK,GAAAyL,EAAAgB,YACA0E,EAAA,MAAA/C,EAAApO,EAAAiD,OAAAkiB,SAAA/W,EACA,QAAA9D,EAAAkQ,IACA,cACAxa,EAAAmR,GAAA7G,EAAA7J,KACA,MACA,WACAT,EAAAkZ,OAAA/H,EAAA,EAAA7G,EAAA7J,MACA,MACA,cACAT,EAAAkZ,OAAA/H,EAAA,KAIAyK,EAAAjY,UAAAuI,cAAA,SAAAT,EAAAQ,GACA+J,GAAAlT,KAAAmJ,EACA,IAAAjM,GAAAyL,EAAAgB,WACAzM,GAAA4a,QAAA3O,IAEA2P,EAAAjY,UAAAoG,aAAA,SAAA/I,GACA,MAAA8B,MAAAsY,SAEAQ,EAAAjY,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,GAAAyC,GAAAE,IACA,OAAA8O,IAAAnR,GAGAqV,GAAArV,EAAAsF,IAAA,SAAAgD,EAAAoI,GACA,MAAAvO,GAAAwY,QAAAlF,SAAAnN,EAAA4M,GAAAxV,EAAA,GAAAgR,EAAAvO,EAAAwY,aAHAvF,GAAA1V,EAAAM,EAAA,0BAMAmb,EAAAjY,UAAAwf,mBAAA,WACA,UAEAvH,EAAAjY,UAAAwK,YAAA,SAAA1C,EAAA2C,GACA3C,EAAAgB,YAAAyM,OAAAiM,SAAA/W,EAAA,QAEAuB,GACAyC,GAAArO,QACA6X,EAAAjY,UAAA,sBACAiY,GACCsH,IA6HDwC,GAAA,qBACAvI,IACAwI,YAAA,cACAC,YAAA,cACAC,oBAAA,sBACAC,aAAA,eACAC,cAAA,iBAKAC,IACAtU,KAAA,iBACAuL,cACAc,aAAAvJ,IA2CAiJ,GAAA,SAAA+F,GAEA,QAAA/F,GAAAwI,GACA,GAAArjB,GAAA4gB,EAAA7iB,KAAAmC,KAAAmjB,EAAAvU,MAAAsU,GAAAtU,OAAA5O,IACAF,GAAAyb,MAAAC,GAAAle,OACAwC,EAAAiU,kBAAA,EACAjU,EAAA0T,kBAAA,WACA,GAAA8N,GAAAhS,GAAAxO,WAAAsiB,cAAAvX,GAEA,OADAiK,IAAAwL,EAAA,WAAAtH,IACAsH,GAEAxhB,EAAA2T,oBAAA,SAAA9K,EAAAQ,GACA,GAAAmY,GAAA3Y,EAAAgB,WACA7J,GAAAujB,YAAA,SAAAzU,EAAA/M,GACAyN,GAAAgU,wBAAAhC,GAAAnZ,KACAA,EAAAyG,GAAAU,GAAAxO,WAAAiF,IAAAlE,EAAAkY,YAAApR,EAAAiG,EAAAjG,EAAAqC,aAAA7B,EAAAyF,KACAzG,IACAmH,GAAAiS,OAAAC,eAAAF,EAAA1S,EAAAjG,EAAAkV,MACA,IAAA1V,KAEArI,EAAAmb,aAAA5c,OAAA,SAAAyF,EAAAyM,GAA2D,MAAAA,GAAAzM,IAAmBwd,GAC9EhS,GAAAmS,UAAAH,EAAA,SAAAO,GAAwD,MAAA/hB,GAAA4hB,WAAAG,KACxDvS,GAAAqS,QAAAL,EAAAxhB,EAAA8hB,YAEA9hB,EAAA8hB,UAAA,SAAAC,GACA,GAAA/hB,EAAAqa,WAAA0H,EAAAjT,MAAA,CAIA,GAAAjG,GAAA7B,GAAA+a,EAAAhb,QACA8Q,EAAAkK,EAAAlK,SAAAkK,EAAAlK,SAAAxO,SAAA5K,MACAoK,GAAAkX,WACAnI,GAAA,UACA3N,KAAA6N,GAAAiK,EAAAjT,MACAjR,MAAAkkB,EAAAxI,SAAAlQ,SACAwO,YACahP,IAEb,IAAAiG,GAAAuU,EAAAvU,MAAAsU,GAAAtU,IASA,OAPA,eAAA2U,KAAA3U,IACA/F,GAAA,0CAAA+F,GACAtR,OAAAgd,OAAAxa,EAAAojB,GAAAC,GAEArjB,EAAAqa,WAAAD,GAAApa,EAAAqa,YACAra,EAAA0jB,gBAAAlmB,OAAA8c,KAAAta,EAAAqa,YACA7c,OAAA6jB,OAAArhB,EAAAqa,YACAra,EA4OA,MA1RAoM,GAAAyO,EAAA+F,GAgDA/F,EAAA9Z,UAAAma,gBAAA,SAAAmI,GACA,UAAAxI,IACA/L,KAAAuU,EAAAvU,MAAA5O,KAAA4O,KACAuL,WAAA7c,OAAAgd,UAAwCta,KAAAma,WAAAgJ,EAAAhJ,YACxCc,aAAAjb,KAAAib,aAAAva,OAAAyiB,EAAAlI,kBACAwI,aAAAN,EAAAM,cAAAzjB,KAAAyjB,gBAGA9I,EAAA9Z,UAAAgD,QAAA,SAAA0M,GACA,GAAAzQ,GAAAE,KACA0jB,EAAA,SAAA5f,GAEA,MADAhE,GAAA6jB,mBAAA7f,EAAAyM,EAAAzM,IACAA,EAEA,OAAA9D,MAAAgb,iBAAqCC,cAAAyI,MAErC/I,EAAA9Z,UAAA8iB,mBAAA,SAAA7f,EAAAD,GAEAgL,GAAAhL,IACAgF,GAAA,uEAEAvL,OAAA8c,KAAAvW,GAAA5F,QAAA,SAAA2Q,GAEA,GAAAA,IAAAgU,GACA,MAAA/Z,IAAA,yBAAA+Z,GAAA,sEAEA,IAAApT,GAAA3L,EAAA+K,GACAgV,EAAA9f,EAAA8K,EACA,IAAAA,IAAAyL,KAAAuJ,EAAA,CACA,GAAAC,GAAArU,CAEAA,GADAZ,IAAAyL,GAAA0I,oBACA,SAAA5Z,GAAqD,MAAA0a,GAAAD,EAAAza,KAErD,WACAya,EAAAnjB,MAAA,KAAAP,WACA2jB,EAAApjB,MAAA,KAAAP,YAGA4V,GAAAhS,EAAA8K,EAAAmC,EAAAjN,EAAA8K,EAAAY,OAIAmL,EAAA9Z,UAAAqa,MAAA,SAAAtM,GACA,MAAA5O,MAAAgb,iBAAqCpM,UAErC+L,EAAA9Z,UAAA+B,MAAA,SAAAuX,GACA,MAAAna,MAAAgb,iBAAqCb,gBAErCQ,EAAA9Z,UAAAijB,SAAA,SAAAvT,GACA,GAAAzQ,GAAAE,KACA+jB,EAAA,SAAAjgB,GAEA,MADAhE,GAAAkkB,yBAAAlgB,EAAAyM,EAAAzM,IACAA,EAEA,OAAA9D,MAAAgb,iBAAqCC,cAAA8I,MAErCpJ,EAAA9Z,UAAAmjB,yBAAA,SAAAlgB,EAAA2Z,GAEA5O,GAAA4O,IACA5U,GAAA,mEAEAyG,GAAAgU,wBAAAxf,EAAA2Z,IAEA9C,EAAA9Z,UAAA2U,OAAA,SAAAjF,GACA,GAAAzQ,GAAAE,KACApC,EAAA,SAAAkG,GACA,GAAAqE,GAAAoI,EAAAzM,GAAAD,EAAAsE,EAAAtE,QAAAG,EAAAmE,EAAAnE,MAAAyZ,EAAAtV,EAAAsV,MAAAwG,EAAA3X,EAAAnE,GAAA,2BACA,QAAAjK,KAAA+lB,GACApb,GAAA,gIAAA3K,EAAA,IAOA,OANAuf,IACA3d,EAAAkkB,yBAAAlgB,EAAA2Z,GACAzZ,GACAlE,EAAAokB,iBAAApgB,EAAAE,GACAH,GACA/D,EAAA6jB,mBAAA7f,EAAAD,GACAC,EAEA,OAAA9D,MAAAgb,iBAAqCC,cAAArd,MAErC+c,EAAA9Z,UAAAmD,MAAA,SAAAuM,GACA,GAAAzQ,GAAAE,KACAmkB,EAAA,SAAArgB,GAEA,MADAhE,GAAAokB,iBAAApgB,EAAAyM,EAAAzM,IACAA,EAEA,OAAA9D,MAAAgb,iBAAqCC,cAAAkJ,MAErCxJ,EAAA9Z,UAAAqjB,iBAAA,SAAApgB,EAAAE,GAEA6K,GAAA7K,IACA6E,GAAA,mEACAvL,OAAA8c,KAAApW,GAAA/F,QAAA,SAAAC,GAEA,GAAAd,GAAAE,OAAA4D,yBAAA8C,EAAA9F,GACAP,EAAAP,EAAAO,KACA,WAAAP,GAEA,GAAAkS,GAAA8U,WAAAtgB,EAAAugB,MAAAvD,OAAA5iB,IAGA4F,EAAAugB,MAAAvD,OAAA5iB,GAAAoR,GAAAvK,SAAA3H,EAAA0H,KACA8J,KAAA1Q,EACAomB,OAAAlnB,EAAAuQ,IACAtQ,QAAAyG,QAGA,CACA,GAAAygB,KACAjnB,QAAAC,eAAAgnB,EAAArmB,GACA4G,IAAA1H,EAAA0H,IACA6I,IAAAvQ,EAAAuQ,IACAnQ,YAAA,IAEA8R,GAAAgU,wBAAAxf,EAAAygB,OAGA,kBAAA5mB,GAEAmY,GAAAhS,EAAA5F,EAAAP,GAGAkL,GAAA,yEAIA8R,EAAA9Z,UAAA2jB,mBAAA,SAAAf,GACA,GAAAgB,GAAAzkB,KAAAyjB,YACA,OAAAgB,GAGAzkB,KAAAgb,iBACAyI,aAAA,SAAAta,GAAmD,MAAAsb,GAAAhB,EAAAta,OAHnDnJ,KAAAgb,iBAAyCyI,kBAMzC9I,EAAA9Z,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAAnK,GACA,MAAAkK,IAAArT,KAAAwJ,EAAA8B,EAAAgI,EAAAtT,KAAA0kB,0BAAAvb,GAAAnJ,KAAAwT,kBAAAxT,KAAAyT,sBAIAkH,EAAA9Z,UAAA6gB,WAAA,SAAAG,GACA,GAAAlZ,GAAA7B,GAAA+a,EAAAhb,OACA8B,GAAAqW,gBACA,IAAAnd,GAAA7B,KAAAma,WAAA0H,EAAAjT,KAMA,OAJA/M,KACAqR,GAAArR,EAAAggB,EAAAxI,UACAwI,EAAAxI,SAAAxX,EAAAgY,UAAAlR,EAAAmM,aAAA+M,EAAAjT,MAAAiT,EAAAxI,WAEAwI,GAEAlH,EAAA9Z,UAAAmL,YAAA,SAAArD,GACA,GAAA7I,GAAAE,KACA6N,IAIA,OAHA7N,MAAAqjB,YAAA,SAAAzU,EAAA/M,GACAgM,EAAA3J,KAAApE,EAAAgV,aAAAnM,EAAAiG,MAEAf,GAEA8M,EAAA9Z,UAAAiU,aAAA,SAAAnM,EAAAzK,GACA,KAAAA,IAAA8B,MAAAma,YACA,MAAAtR,IAAA,yBAAA3K,EACA,IAAA4b,GAAAnR,EAAAgB,YAAA0a,MAAAvD,OAAA5iB,GAAAP,KACA,OAAAmc,GAEAA,EADAjR,GAAA,mCAAA3K,IAGAyc,EAAA9Z,UAAAqd,SAAA,SAAAvV,GACA,MAAAA,GAAAgB,aAEAgR,EAAA9Z,UAAAsd,YAAA,SAAAxV,GACA,GAAA7I,GAAAE,KACA6N,IAOA,OANA7N,MAAAqjB,YAAA,SAAAzU,EAAA/M,GAGAyN,GAAAiS,OAAAoD,QAAAhc,EAAAgB,YAAAiF,GAAAgW,iBACA/W,EAAAe,GAAA9O,EAAAgV,aAAAnM,EAAAiG,GAAAzF,WAEA,kBAAAR,GAAAgB,YAAAoZ,oBACApa,EAAAgB,YAAAoZ,oBAAAllB,KAAA,KAAAgQ,GACAA,GAEA8M,EAAA9Z,UAAA0e,kBAAA,SAAA5W,EAAA2C,EAAA9D,GACA,YAAAA,EAAAkQ,IAAA,QAAAlQ,EAAAkQ,IACA7O,GAAA,qCAAArB,EAAAkQ,IACA/O,EAAAgB,YAAA2B,GAAA9D,EAAA7J,OAEAgd,EAAA9Z,UAAAuI,cAAA,SAAAT,EAAAQ,GACA,GAAAoD,GAAAvM,KAAA0kB,0BAAAvb,EACA+J,IAAAlT,KAAAuM,GACAvM,KAAAqjB,YAAA,SAAAzU,EAAA/M,GACA8G,EAAAgB,YAAAiF,GAAArC,EAAAqC,MAGA+L,EAAA9Z,UAAA6jB,0BAAA,SAAAvb,GACA,MAAAnJ,MAAAyjB,aACAzjB,KAAAyjB,aAAA5lB,KAAA,KAAAsL,GACAA,GAEAwR,EAAA9Z,UAAAoG,aAAA,SAAA/I,GACA,MAAA8B,MAAAma,WAAAjc,IAEAyc,EAAA9Z,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,GAAAyC,GAAAE,KACAmJ,EAAAnJ,KAAA0kB,0BAAA/mB,EACA,OAAAkR,IAAA1F,GAGA6J,GAAAhT,KAAAwjB,gBAAAvgB,IAAA,SAAA/E,GACA,MAAA4B,GAAAqa,WAAAjc,GAAAkV,SAAAjK,EAAAjL,GAAA2U,GAAAxV,EAAAa,EAAA4B,EAAAqa,WAAAjc,QAHA6U,GAAA1V,EAAA8L,EAAA,gCAMAwR,EAAA9Z,UAAAwiB,YAAA,SAAA9S,GACA,GAAAzQ,GAAAE,IACAA,MAAAwjB,gBAAAvlB,QAAA,SAAAC,GAAqD,MAAAqS,GAAArS,EAAA4B,EAAAqa,WAAAjc,OAErDyc,EAAA9Z,UAAA+R,SAAA,WACA,GAAA9S,GAAAE,IAEA,YACAA,KAAAwjB,gBACAvgB,IAAA,SAAA/E,GAAqC,MAAAA,GAAA,KAAA4B,EAAAqa,WAAAjc,GAAA0U,aACrCP,KAAA,MACA,MAEAsI,EAAA9Z,UAAAwf,mBAAA,WACA,UAEA1F,EAAA9Z,UAAAwK,YAAA,SAAA1C,EAAA2C,GACA3C,EAAAgB,YAAA2B,GAAA,MAEAuB,GACAyC,GAAArO,QACA0Z,EAAA9Z,UAAA,sBACA8Z,GACCyF,IAmDDyE,GAAA,SAAAnE,GAEA,QAAAmE,GAAAjW,EAAA2M,EAAAuJ,EAAAlnB,GACA,SAAAA,IAAqCA,EAAA8V,GACrC,IAAA5T,GAAA4gB,EAAA7iB,KAAAmC,KAAA4O,IAAA5O,IAKA,OAJAF,GAAAiU,kBAAA,EACAjU,EAAAyb,QACAzb,EAAAglB,UACAhlB,EAAAlC,cACAkC,EAeA,MAvBAoM,GAAA2Y,EAAAnE,GAUAmE,EAAAhkB,UAAA+R,SAAA,WACA,MAAA5S,MAAA4O,MAEAiW,EAAAhkB,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAAnK,GACA,MAAAkK,IAAArT,KAAAwJ,EAAA8B,EAAAgI,EAAAnK,EAAAnJ,KAAApC,cAEAinB,EAAAhkB,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,GAAAqR,GAAA/Q,IAAAqC,KAAA8kB,QAAAnnB,GACA,MAAAmV,KAEA,IAAA+H,GAAA,SAAA7a,KAAA4O,KAAA,wCAAA5O,KAAA4O,IACA,OAAAmE,IAAA1V,EAAAM,EAAA,kBAAAkd,IAEAgK,GACCpE,IAcDtF,GAAA,GAAA0J,IAAA,SAAArJ,GAAAC,OAAA,SAAA9L,GAA6E,sBAAAA,KAc7EyL,GAAA,GAAAyJ,IAAA,SAAArJ,GAAAE,OAAA,SAAA/L,GAA6E,sBAAAA,KAc7E0L,GAAA,GAAAwJ,IAAA,UAAArJ,GAAAG,QAAA,SAAAhM,GAAgF,uBAAAA,KAOhFoV,GAAA,GAAAF,IAAA,OAAArJ,GAAAwJ,KAAA,SAAArV,GAA2E,cAAAA,IAO3EsV,GAAA,GAAAJ,IAAA,YAAArJ,GAAA0J,UAAA,SAAAvV,GAA0F,MAAApR,UAAAoR,IAc1F2L,GAAA,GAAAuJ,IAAA,OAAArJ,GAAAjN,KAAA,SAAAoB,GAAgF,sBAAAA,gBAAApB,OAAqD,SAAAoB,GAAgB,MAAAA,aAAApB,MAAAoB,EAAA,GAAApB,MAAAoB,IACrJ2L,IAAA6C,YAAA,SAAAxV,GACA,MAAAA,GAAAgB,YAAA8E,UAsBA,IAAAoN,IAAA,SAAA6E,GAEA,QAAA7E,GAAAle,GACA,GAAAmC,GAAA4gB,EAAA7iB,KAAAmC,KAAA+O,KAAAC,UAAArR,KAAAqC,IAIA,OAHAF,GAAAiU,kBAAA,EACAjU,EAAAyb,MAAAC,GAAA2J,QACArlB,EAAAnC,QACAmC,EAcA,MApBAoM,GAAA2P,EAAA6E,GAQA7E,EAAAhb,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAAnK,GACA,MAAAkK,IAAArT,KAAAwJ,EAAA8B,EAAAgI,EAAAnK,IAEA0S,EAAAhb,UAAA+R,SAAA,WACA,MAAA7D,MAAAC,UAAAhP,KAAArC,QAEAke,EAAAhb,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,MAAAqR,IAAA/Q,QAAAqC,KAAArC,MACAmV,KAEAC,GAAA1V,EAAAM,EAAA,0BAAAoR,KAAAC,UAAAhP,KAAArC,SAEAke,GACC4E,IA2BDzE,GAAA,SAAA0E,GAEA,QAAA1E,GAAApN,EAAA/M,EAAAka,EAAArJ,GACA,GAAA5S,GAAA4gB,EAAA7iB,KAAAmC,KAAA4O,IAAA5O,IAIA,OAHAF,GAAA+B,OACA/B,EAAAic,YACAjc,EAAA4S,UACA5S,EAqCA,MA3CAoM,GAAA8P,EAAA0E,GAQApjB,OAAAC,eAAAye,EAAAnb,UAAA,SACAiE,IAAA,WACA,MAAA9E,MAAA6B,KAAA0Z,MAAAC,GAAA4J,YAEA5nB,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAAye,EAAAnb,UAAA,oBACAiE,IAAA,WACA,MAAA9E,MAAA6B,KAAAkS,kBAEAvW,YAAA,EACAC,cAAA,IAEAue,EAAAnb,UAAA+R,SAAA,WACA,MAAA5S,MAAA4O,MAEAoN,EAAAnb,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAA3V,GAEA,GAAA0nB,GAAArlB,KAAA6B,KAAAkY,YAAAvQ,EAAA8B,EAAAgI,EAAA3V,EACA,OAAA0nB,IAEArJ,EAAAnb,UAAAyf,iBAAA,SAAAze,GACA,MAAA7B,MAAA6B,KAAAye,iBAAAze,IAEAma,EAAAnb,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,GAAAioB,GAAAtlB,KAAA6B,KAAAuR,SAAAzV,EAAAN,EACA,IAAAioB,EAAAnlB,OAAA,EACA,MAAAmlB,EACA,IAAAnc,GAAA8C,GAAAtO,GAAAmJ,GAAAnJ,GAAAwL,SAAAxL,CACA,OAAAqC,MAAA+b,UAAA5S,GAGA2J,KAFAC,GAAA1V,EAAAM,EAAAqC,KAAA0S,QAAA/U,KAIAqe,GACCyE,IAqEDhE,GAAA,SAAAiE,GAEA,QAAAjE,GAAA7N,EAAApL,EAAAgZ,GACA,GAAA1c,GAAA4gB,EAAA7iB,KAAAmC,KAAA4O,IAAA5O,IAIA,OAHAF,GAAA0c,WAAA,KACA1c,EAAA0c,aACA1c,EAAA0D,QACA1D,EA0DA,MAhEAoM,GAAAuQ,EAAAiE,GAQApjB,OAAAC,eAAAkf,EAAA5b,UAAA,SACAiE,IAAA,WACA,GAAAygB,GAAA/J,GAAAgK,KAIA,OAHAxlB,MAAAwD,MAAAvF,QAAA,SAAA4D,GACA0jB,GAAA1jB,EAAA0Z,QAEAgK,GAEA/nB,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAAkf,EAAA5b,UAAA,oBACAiE,IAAA,WACA,MAAA9E,MAAAwD,MAAAiiB,KAAA,SAAA5jB,GAAoD,MAAAA,GAAAkS,oBAEpDvW,YAAA,EACAC,cAAA,IAEAgf,EAAA5b,UAAAyf,iBAAA,SAAAze,GACA,MAAA7B,MAAAwD,MAAAiiB,KAAA,SAAAnN,GAAmD,MAAAA,GAAAgI,iBAAAze,MAEnD4a,EAAA5b,UAAA+R,SAAA,WACA,UAAA5S,KAAAwD,MAAAP,IAAA,SAAAyiB,GAAwD,MAAAA,GAAA9S,aAA6BP,KAAA,YAErFoK,EAAA5b,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAA3V,GACA,MAAAqC,MAAA2lB,cAAAhoB,GAAAoc,YAAAvQ,EAAA8B,EAAAgI,EAAA3V,IAEA8e,EAAA5b,UAAAgZ,UAAA,SAAAhF,EAAAwE,GACA,MAAArZ,MAAA2lB,cAAAtM,GAAAQ,UAAAhF,EAAAwE,IAEAoD,EAAA5b,UAAA8kB,cAAA,SAAAhoB,GAEA,UAAAqC,KAAAwc,WACA,MAAAxc,MAAAwc,WAAA7e,EAGA,IAAAioB,GAAA5lB,KAAAwD,MAAAS,OAAA,SAAApC,GAAiE,MAAAA,GAAA4Q,GAAA9U,IACjE,OAAAioB,GAAAzlB,OAAA,EACA0I,GAAA,qBAAAkG,KAAAC,UAAArR,GAAA,cAAAqC,KACA4O,KAAA,yDACAgX,EAAA,IAEAnJ,EAAA5b,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,UAAA2C,KAAAwc,WACA,MAAAxc,MAAAwc,WAAA7e,GAAAyV,SAAAzV,EAAAN,EAEA,IAAA4V,GAAAjT,KAAAwD,MAAAP,IAAA,SAAApB,GAAqD,MAAAA,GAAAuR,SAAAzV,EAAAN,KACrDuoB,EAAA3S,EAAAhP,OAAA,SAAA4hB,GAAmE,WAAAA,EAAA1lB,QACnE,OAAAylB,GAAAzlB,OAAA,EACA4S,GAAA1V,EAAAM,EAAA,mFAEA,IAAAioB,EAAAzlB,OACA4S,GAAA1V,EAAAM,EAAA,uCAAA+C,OAAAsS,GAAAC,IAEAH,MAEA2J,GACCgE,IA8BD9D,GAAA,SAAA+D,GAEA,QAAA/D,GAAA9a,EAAAikB,GACA,GAAAhmB,GAAA4gB,EAAA7iB,KAAAmC,KAAA6B,EAAA+M,OAAA5O,IAGA,OAFAF,GAAA+B,OACA/B,EAAAgmB,eACAhmB,EAiDA,MAtDAoM,GAAAyQ,EAAA+D,GAOApjB,OAAAC,eAAAof,EAAA9b,UAAA,SACAiE,IAAA,WACA,MAAA9E,MAAA6B,KAAA0Z,MAAAC,GAAAuK,UAEAvoB,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAAof,EAAA9b,UAAA,oBACAiE,IAAA,WACA,MAAA9E,MAAA6B,KAAAkS,kBAEAvW,YAAA,EACAC,cAAA,IAEAkf,EAAA9b,UAAA+R,SAAA,WACA,MAAA5S,MAAA6B,KAAA+Q,WAAA,KAEA+J,EAAA9b,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAA3V,GACA,sBAAAA,GAAA,CACA,GAAAmoB,GAAA9lB,KAAAgmB,kBACAC,EAAAha,GAAA6Z,GACAhf,GAAAgf,GAAA3c,SACA2c,CACA,OAAA9lB,MAAA6B,KAAAkY,YAAAvQ,EAAA8B,EAAAgI,EAAA2S,GAEA,MAAAjmB,MAAA6B,KAAAkY,YAAAvQ,EAAA8B,EAAAgI,EAAA3V,IAEAgf,EAAA9b,UAAAgZ,UAAA,SAAAhF,EAAAwE,GACA,MAAArZ,MAAA6B,KAAAgY,UAAAhF,EAAA7U,KAAA6B,KAAA4Q,GAAA4G,KAAArZ,KAAAgmB,oBAEArJ,EAAA9b,UAAAmlB,gBAAA,WACA,GAAAF,GAAA,kBAAA9lB,MAAA8lB,aAAA9lB,KAAA8lB,eAAA9lB,KAAA8lB,YAGA,OAFA,kBAAA9lB,MAAA8lB,cACA5S,GAAAlT,KAAA8lB,GACAA,GAEAnJ,EAAA9b,UAAA0f,gBAAA,SAAA5iB,EAAAN,GAEA,MAAAkB,UAAAZ,EACAmV,KAGA9S,KAAA6B,KAAAuR,SAAAzV,EAAAN,IAEAsf,EAAA9b,UAAAyf,iBAAA,SAAAze,GACA,MAAA7B,MAAA6B,KAAAye,iBAAAze,IAEA8a,GACC8D,IAmCD5D,GAAAtC,GAAAwK,GAAA,MAsBA9H,GAAA,SAAAyD,GAEA,QAAAzD,GAAArO,EAAAsX,GACA,GAAApmB,GAAA4gB,EAAA7iB,KAAAmC,KAAA4O,IAAA5O,IAGA,OAFAF,GAAAqmB,SAAA,KACArmB,EAAAomB,aACApmB,EAyCA,MA9CAoM,GAAA+Q,EAAAyD,GAOApjB,OAAAC,eAAA0f,EAAApc,UAAA,SACAiE,IAAA,WACA,MAAA9E,MAAAsY,QAAAiD,MAAAC,GAAA4K,MAEA5oB,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAA0f,EAAApc,UAAA,oBACAiE,IAAA,WACA,MAAA9E,MAAAsY,QAAAvE,kBAEAvW,YAAA,EACAC,cAAA,IAEAH,OAAAC,eAAA0f,EAAApc,UAAA,WACAiE,IAAA,WAIA,MAHA,QAAA9E,KAAAmmB,WACAnmB,KAAAmmB,SAAAnmB,KAAAkmB,cAEAlmB,KAAAmmB,UAEA3oB,YAAA,EACAC,cAAA,IAEAwf,EAAApc,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAAnK,GACA,MAAAnJ,MAAAsY,QAAAyB,YAAAvQ,EAAA8B,EAAAgI,EAAAnK,IAEA8T,EAAApc,UAAAgZ,UAAA,SAAAhF,EAAAwE,GACA,MAAArZ,MAAAsY,QAAAuB,UAAAhF,EAAAwE,IAEA4D,EAAApc,UAAA+R,SAAA,WACA,MAAA5S,MAAAsY,QAAA1J,MAEAqO,EAAApc,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,MAAA2C,MAAAsY,QAAAlF,SAAAzV,EAAAN,IAEA4f,EAAApc,UAAAyf,iBAAA,SAAAze,GACA,MAAA7B,MAAAsY,QAAAgI,iBAAAze,IAEAob,GACCwD,IAoCD4F,GAAA,SAAA3F,GAEA,QAAA2F,KACA,GAAAvmB,GAAA4gB,EAAA7iB,KAAAmC,KAAA,WAAAA,IAGA,OAFAF,GAAAiU,kBAAA,EACAjU,EAAAyb,MAAAC,GAAA8K,OACAxmB,EAiBA,MAtBAoM,GAAAma,EAAA3F,GAOA2F,EAAAxlB,UAAA+R,SAAA,WACA,+BAEAyT,EAAAxlB,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAA3V,GAEA,GAAA4oB,GAAA5oB,CAEA,OAAA0V,IAAArT,KAAAwJ,EAAA8B,EAAAgI,EAAAiT,IAEAF,EAAAxlB,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,MAAAwY,IAAAlY,GAGAmV,KAFAC,GAAA1V,EAAAM,EAAA,mDAIA0oB,GACC5F,IA0BD+F,GAAA,GAAAH,IAEAI,GAAA,WACA,QAAAA,GAAAC,EAAA/oB,GAGA,GAFAqC,KAAA0mB,OACA1mB,KAAArC,QACA,WAAA+oB,EAAA,CACA,IAAAza,GAAAtO,GACA,MAAAkL,IAAA,kDAAAlL,EAAA,IACA,IAAAiW,GAAA9M,GAAAnJ,EACA,KAAAiW,EAAA2E,oBACA,MAAA1P,IAAA,mEAGA,MAAA4d,MAEAE,GAAA,SAAAjG,GAEA,QAAAiG,GAAAtO,GACA,GAAAvY,GAAA4gB,EAAA7iB,KAAAmC,KAAA,aAAAqY,EAAAzJ,KAAA,MAAA5O,IAGA,OAFAF,GAAAuY,aACAvY,EAAAyb,MAAAC,GAAAoL,UACA9mB,EAaA,MAlBAoM,GAAAya,EAAAjG,GAOAiG,EAAA9lB,UAAA+R,SAAA,WACA,MAAA5S,MAAA4O,MAEA+X,EAAA9lB,UAAAyf,iBAAA,SAAAze,GACA,MAAA7B,MAAAqY,WAAAiI,iBAAAze,IAEA8kB,EAAA9lB,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,sBAAAM,IAAA,gBAAAA,GACAmV,KACAC,GAAA1V,EAAAM,EAAA,mEAEAgpB,GACClG,IACDrD,GAAA,SAAAsD,GAEA,QAAAtD,GAAA/E,GACA,GAAAvY,GAAA4gB,EAAA7iB,KAAAmC,KAAAqY,IAAArY,IAEA,OADAF,GAAAiU,kBAAA,EACAjU,EAuCA,MA3CAoM,GAAAkR,EAAAsD,GAMAtD,EAAAvc,UAAAqd,SAAA,SAAAvV,GACA,GAAAA,EAAA6C,QAAA,CAEA,GAAAzF,GAAA4C,EAAAgB,WAEA,eAAA5D,EAAA2gB,KACA,MAAA3gB,GAAApI,KAEA,IAAAT,GAAAyL,EAAAkB,KAAAU,gBAAAC,QAAAxK,KAAAqY,WAAAtS,EAAApI,MACA,OAAAT,GAGAA,EAAAS,MAFAkL,GAAA,uCAAA7I,KAAAqY,WACAzJ,KAAA,MAAA7I,EAAApI,MAAA,UAAAgL,EAAAoB,KAAA,OAGAqT,EAAAvc,UAAAsd,YAAA,SAAAxV,GACA,GAAA5C,GAAA4C,EAAAgB,WACA,QAAA5D,EAAA2gB,MACA,iBACA,MAAA3gB,GAAApI,KACA,cACA,MAAAmJ,IAAAf,EAAApI,OAAA6a,aAGA4E,EAAAvc,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAAnK,GACA,MAAAkK,IAAArT,KAAAwJ,EAAA8B,EAAAgI,EAAA,GAAAmT,IAAAxa,GAAA9C,GAAA,sBAAAA,KAEAiU,EAAAvc,UAAAgZ,UAAA,SAAAhF,EAAAwE,GACA,GAAAxE,EAAAhT,OAAA7B,KAAA,CACA,GAAA6mB,GAAA5a,GAAAoN,GAAA,sBACAtT,EAAA8O,EAAAlL,WACA,IAAAkd,IAAA9gB,EAAA2gB,MAAA3gB,EAAApI,QAAA0b,EACA,MAAAxE,GAEA,GAAA2L,GAAAxgB,KAAA+Z,YAAAlF,EAAArL,OAAAqL,EAAAvJ,QAAAuJ,EAAA7J,aAAAqO,EAEA,OADAxE,GAAAzJ,MACAoV,GAEApD,GACCuJ,IACDxJ,GAAA,SAAAuD,GAEA,QAAAvD,GAAA9E,EAAA6D,GACA,GAAApc,GAAA4gB,EAAA7iB,KAAAmC,KAAAqY,IAAArY,IAGA,OAFAF,GAAAoc,UACApc,EAAAiU,kBAAA,EACAjU,EA4BA,MAjCAoM,GAAAiR,EAAAuD,GAOAvD,EAAAtc,UAAAqd,SAAA,SAAAvV,GACA,GAAAA,EAAA6C,QAEA,MAAAxL,MAAAkc,QAAApX,IAAA6D,EAAAgB,YAAAhB,EAAAa,OAAAb,EAAAa,OAAAG,YAAA,OAEAwT,EAAAtc,UAAAsd,YAAA,SAAAxV,GACA,MAAAA,GAAAgB,aAEAwT,EAAAtc,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAAnK,GACA,GAAAmB,GAAA2B,GAAA9C,GACAnJ,KAAAkc,QAAAvO,IAAAxE,EAAAK,IAAAG,YAAA,MACAR,CACA,OAAAkK,IAAArT,KAAAwJ,EAAA8B,EAAAgI,EAAAhJ,IAEA6S,EAAAtc,UAAAgZ,UAAA,SAAAhF,EAAA1L,GACA,GAAA2d,GAAA7a,GAAA9C,GACAnJ,KAAAkc,QAAAvO,IAAAxE,EAAA0L,IAAAlL,YAAA,MACAR,CACA,IAAA0L,EAAAhT,OAAA7B,MACA6U,EAAAlL,cAAAmd,EACA,MAAAjS,EAEA,IAAA2L,GAAAxgB,KAAA+Z,YAAAlF,EAAArL,OAAAqL,EAAAvJ,QAAAuJ,EAAA7J,aAAA8b,EAEA,OADAjS,GAAAzJ,MACAoV,GAEArD,GACCwJ,IAsBDtJ,GAAA,SAAAqD,GAEA,QAAArD,GAAA0J,GACA,GAAAjnB,GAAA4gB,EAAA7iB,KAAAmC,KAAA,cAAA+mB,EAAAnY,KAAA,MAAA5O,IAIA,OAHAF,GAAAinB,iBACAjnB,EAAAiU,kBAAA,EACAjU,EAAAyb,MAAAC,GAAAwL,WACAlnB,EA0BA,MAhCAoM,GAAAmR,EAAAqD,GAQArD,EAAAxc,UAAAkZ,YAAA,SAAAvQ,EAAA8B,EAAAgI,EAAAnK,GACA,MAAAK,IAAAyC,GAAAzC,EAAAG,cAEAH,EAAA+O,qBACA1P,GAAA,2BAAAyC,EAAA,qCAAA9B,EAAA+O,oBAAA,+CACA/O,EAAA+O,oBAAAjN,EACA+H,GAAArT,KAAAwJ,EAAA8B,EAAAgI,EAAAnK,IAJAN,GAAA,8EAMAwU,EAAAxc,UAAAgZ,UAAA,SAAAhF,EAAAwE,GACA,MAAAxE,GAAAlL,cAAA0P,EACAxQ,GAAA,oCAAAgM,EAAAlL,YAAA,SAAA0P,EAAA,2CACAxE,GAEAwI,EAAAxc,UAAA+R,SAAA,WACA,oBAAA5S,KAAA+mB,eAAAnU,WAAA,KAEAyK,EAAAxc,UAAA0f,gBAAA,SAAA5iB,EAAAN,GACA,MAAAkB,UAAAZ,GACA,OAAAA,GACA,gBAAAA,IACA,gBAAAA,GACAqC,KAAA+mB,eAAA3T,SAAAzV,EAAAN,GACA0V,GAAA1V,EAAAM,EAAA,mEAEA0f,GACCoD,IAoCDjd,IACAyjB,YAAAhL,GACAxY,MAAAgX,GACAyM,QAAAtM,GACAuM,UAAAjK,GACAkK,MAAAhL,GACA1Y,SAAA6W,GACA8M,QAAAzL,GACA0L,MAAA1K,GACA2K,WAAAzL,GACAlY,OAAAuX,GACAqM,QAAAnM,GACA1X,OAAAyX,GACA7M,KAAA+M,GACArY,IAAAwV,GACA1U,MAAA8U,GACA4O,OAAAjB,GACAhO,WAAAlO,GACAod,KAAA5K,GACAve,UAAA0mB,GACA0C,KAAA5C,GAGApoB,GAAA6G,SACA7G,EAAAirB,UAAAzU,GACAxW,EAAAkrB,eAAAjQ,GACAjb,EAAAmrB,iBAAA/P,GACApb,EAAAsQ,SAAAoE,EACA1U,EAAAorB,cAAA5X,EACAxT,EAAAqrB,QAAAjT,GACApY,EAAAsrB,gBAAAhc,GACAtP,EAAAwY,QACAxY,EAAAurB,YAAA7Y,EACA1S,EAAAwrB,SAAAtY,EACAlT,EAAAyrB,cAAAxY,EACAjT,EAAAyQ,iCACAzQ,EAAA0rB,QAAAzhB,EACAjK,EAAAsK,aAAAF,EACApK,EAAAyK,QAAAF,EACAvK,EAAA2K,WAAAD,EACA1K,EAAA2rB,WAAA/gB,EACA5K,EAAA4rB,cAAA5gB,EACAhL,EAAA6rB,QAAA9f,EACA/L,EAAA8rB,UAAA1f,EACApM,EAAAsM,YAAAD,EACArM,EAAAyM,cAAAF,EACAvM,EAAAwhB,YAAA9U,EACA1M,EAAA+rB,UAAApf,EACA3M,EAAAgsB,UAAAlf,EACA9M,EAAAisB,QAAAhf,EACAjN,EAAAksB,QAAA/e,EACAnN,EAAAmsB,aAAA9e,EACArN,EAAAiM,OAAAsB,EACAvN,EAAAosB,YAAA5e,EACAxN,EAAAqsB,kBAAA3e,EACA1N,EAAAssB,WAAAxe,EACA9N,EAAAusB,gBAAAxe,EACA/N,EAAAwsB,MAAAte,EACAlO,EAAAuO,OAAAD,EACAtO,EAAAysB,QAAAje,EACAxO,EAAA6O,QAAAD,EACA5O,EAAA+O,YAAAD,EACA9O,EAAA0sB,OAAA1d,EACAhP,EAAA2sB,KAAAxd,ITiqB8BjO,KAAKlB,EAASC,EAAoB,KAAK6J,eAI/D8iB,KACA,SAAU7sB,EAAQC,EAASC,GU3iJjCF,EAAAC,SACA6sB,QAAA;AACAC,SACAC,4BACAC,OAEA,2+BAEAC,UAAA,EACAC,UAAA,OAEA,IAGA,g3BAEAD,UAAA,EACAC,UAAA,OAEA,IAGAC,KACAC,MAAAntB,EAAA,GACAotB,YAAAptB,EAAA,IACA0S,KAAA1S,EAAA,IACAqtB,aAAArtB,EAAA,KACAstB,mCAAAttB,EAAA,KACAutB,sCAAAvtB,EAAA,KACAwtB,gBAAAxtB,EAAA,IACAytB,0BAAAztB,EAAA,KACA0tB,sBAAA1tB,EAAA,SVqjJM2tB,KACA,SAAU7tB,EAAQC,EAASC,IWtlJjC,SAAAqI,EAAA+iB,IAAA,SAAA/iB,EAAA1G,GACA,YAYA,SAAAkI,GAAAU,GAEA,kBAAAA,KACAA,EAAA,GAAA7B,UAAA,GAAA6B,GAIA,QADA/G,GAAA,GAAAC,OAAAH,UAAAC,OAAA,GACAyM,EAAA,EAAqBA,EAAAxM,EAAAD,OAAiByM,IACtCxM,EAAAwM,GAAA1M,UAAA0M,EAAA,EAGA,IAAA4d,IAAkBrjB,WAAA/G,OAGlB,OAFAqqB,GAAAC,GAAAF,EACAG,EAAAD,GACAA,IAGA,QAAAhkB,GAAAkkB,SACAH,GAAAG,GAGA,QAAAC,GAAAL,GACA,GAAArjB,GAAAqjB,EAAArjB,SACA/G,EAAAoqB,EAAApqB,IACA,QAAAA,EAAAD,QACA,OACAgH,GACA,MACA,QACAA,EAAA/G,EAAA,GACA,MACA,QACA+G,EAAA/G,EAAA,GAAAA,EAAA,GACA,MACA,QACA+G,EAAA/G,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACA,MACA,SACA+G,EAAA1G,MAAAlC,EAAA6B,IAKA,QAAA0qB,GAAAF,GAGA,GAAAG,EAGAxlB,WAAAulB,EAAA,EAAAF,OACS,CACT,GAAAJ,GAAAC,EAAAG,EACA,IAAAJ,EAAA,CACAO,GAAA,CACA,KACAF,EAAAL,GACiB,QACjB9jB,EAAAkkB,GACAG,GAAA,KAMA,QAAAC,KACAL,EAAA,SAAAC,GACA5C,EAAAiD,SAAA,WAA0CH,EAAAF,MAI1C,QAAAM,KAGA,GAAAjmB,EAAAkmB,cAAAlmB,EAAAmmB,cAAA,CACA,GAAAC,IAAA,EACAC,EAAArmB,EAAAsmB,SAMA,OALAtmB,GAAAsmB,UAAA,WACAF,GAAA,GAEApmB,EAAAkmB,YAAA,QACAlmB,EAAAsmB,UAAAD,EACAD,GAIA,QAAAG,KAKA,GAAAC,GAAA,gBAAA1qB,KAAAC,SAAA,IACA0qB,EAAA,SAAAC,GACAA,EAAA7gB,SAAA7F,GACA,gBAAA0mB,GAAAC,MACA,IAAAD,EAAAC,KAAAlf,QAAA+e,IACAX,GAAAa,EAAAC,KAAAztB,MAAAstB,EAAAtrB,SAIA8E,GAAA4mB,iBACA5mB,EAAA4mB,iBAAA,UAAAH,GAAA,GAEAzmB,EAAA6mB,YAAA,YAAAJ,GAGAf,EAAA,SAAAC,GACA3lB,EAAAkmB,YAAAM,EAAAb,EAAA,MAIA,QAAAmB,KACA,GAAAC,GAAA,GAAAC,eACAD,GAAAE,MAAAX,UAAA,SAAAI,GACA,GAAAf,GAAAe,EAAAC,IACAd,GAAAF,IAGAD,EAAA,SAAAC,GACAoB,EAAAG,MAAAhB,YAAAP,IAIA,QAAAwB,KACA,GAAAC,GAAAC,EAAAC,eACA5B,GAAA,SAAAC,GAGA,GAAA4B,GAAAF,EAAA1qB,cAAA,SACA4qB,GAAAC,mBAAA,WACA3B,EAAAF,GACA4B,EAAAC,mBAAA,KACAJ,EAAAhhB,YAAAmhB,GACAA,EAAA,MAEAH,EAAAK,YAAAF,IAIA,QAAAG,KACAhC,EAAA,SAAAC,GACArlB,WAAAulB,EAAA,EAAAF,IAtJA,IAAA3lB,EAAAwB,aAAA,CAIA,GAIAkkB,GAJAD,EAAA,EACAD,KACAM,GAAA,EACAuB,EAAArnB,EAAA2nB,SAoJAC,EAAAvvB,OAAAkD,gBAAAlD,OAAAkD,eAAAyE,EACA4nB,QAAAtnB,WAAAsnB,EAAA5nB,EAGU,wBAAAgV,SAAApc,KAAAoH,EAAA+iB,SAEVgD,IAEKE,IAELM,IAEKvmB,EAAAgnB,eAELF,IAEKO,GAAA,sBAAAA,GAAA1qB,cAAA,UAELwqB,IAIAO,IAGAE,EAAApmB,eACAomB,EAAAnmB,mBACC,mBAAA5C,MAAA,mBAAAmB,GAAAjF,KAAAiF,EAAAnB,QX0lJ6BjG,KAAKlB,EAAU,WAAa,MAAOqD,SAAYpD,EAAoB","file":"guide/contrast.js","sourcesContent":["webpackJsonp([0,15],{\n\n/***/ 241:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(11);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(16);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(13);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(12);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _dec, _class, _desc, _value, _class2, _descriptor, _descriptor2, _descriptor3;\n\t\n\tvar _reactMobxVm = __webpack_require__(19);\n\t\n\tvar _View = __webpack_require__(373);\n\t\n\tvar _View2 = _interopRequireDefault(_View);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _initDefineProp(target, property, descriptor, context) {\n\t  if (!descriptor) return;\n\t  Object.defineProperty(target, property, {\n\t    enumerable: descriptor.enumerable,\n\t    configurable: descriptor.configurable,\n\t    writable: descriptor.writable,\n\t    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n\t  });\n\t}\n\t\n\tfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n\t  var desc = {};\n\t  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n\t    desc[key] = descriptor[key];\n\t  });\n\t  desc.enumerable = !!desc.enumerable;\n\t  desc.configurable = !!desc.configurable;\n\t\n\t  if ('value' in desc || desc.initializer) {\n\t    desc.writable = true;\n\t  }\n\t\n\t  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n\t    return decorator(target, property, desc) || desc;\n\t  }, desc);\n\t\n\t  if (context && desc.initializer !== void 0) {\n\t    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n\t    desc.initializer = undefined;\n\t  }\n\t\n\t  if (desc.initializer === void 0) {\n\t    Object['define' + 'Property'](target, property, desc);\n\t    desc = null;\n\t  }\n\t\n\t  return desc;\n\t}\n\t\n\tfunction _initializerWarningHelper(descriptor, context) {\n\t  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');\n\t}\n\t\n\tvar Todo = (_dec = (0, _reactMobxVm.bindView)(_View2.default), _dec(_class = (_class2 = function (_Root) {\n\t  (0, _inherits3.default)(Todo, _Root);\n\t\n\t  function Todo() {\n\t    var _ref;\n\t\n\t    var _temp, _this, _ret;\n\t\n\t    (0, _classCallCheck3.default)(this, Todo);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Todo.__proto__ || Object.getPrototypeOf(Todo)).call.apply(_ref, [this].concat(args))), _this), _initDefineProp(_this, 'id', _descriptor, _this), _initDefineProp(_this, 'title', _descriptor2, _this), _initDefineProp(_this, 'finished', _descriptor3, _this), _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t\n\t  (0, _createClass3.default)(Todo, [{\n\t    key: 'toggle',\n\t    value: function toggle() {\n\t      this.finished = !this.finished;\n\t    }\n\t  }]);\n\t  return Todo;\n\t}(_reactMobxVm.Root), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'id', [_reactMobxVm.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return Math.random();\n\t  }\n\t}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'title', [_reactMobxVm.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return '';\n\t  }\n\t}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, 'finished', [_reactMobxVm.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return false;\n\t  }\n\t}), _applyDecoratedDescriptor(_class2.prototype, 'toggle', [_reactMobxVm.action], Object.getOwnPropertyDescriptor(_class2.prototype, 'toggle'), _class2.prototype)), _class2)) || _class);\n\texports.default = Todo;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 370:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Todo = undefined;\n\t\n\tvar _mobxReact = __webpack_require__(112);\n\t\n\tvar _react = __webpack_require__(3);\n\t\n\tvar React = _interopRequireWildcard(_react);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar Todo = exports.Todo = (0, _mobxReact.observer)(function (_ref) {\n\t  var todo = _ref.todo;\n\t  return React.createElement(\n\t    'li',\n\t    null,\n\t    React.createElement('input', {\n\t      type: 'checkbox',\n\t      checked: todo.finished,\n\t      onClick: todo.toggle\n\t    }),\n\t    todo.title\n\t  );\n\t});\n\n/***/ }),\n\n/***/ 371:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.TodoList = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(11);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(16);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(13);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(12);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _class, _desc, _value, _class2, _descriptor;\n\t\n\tvar _mobx = __webpack_require__(94);\n\t\n\tvar _mobxReact = __webpack_require__(112);\n\t\n\tvar _react = __webpack_require__(3);\n\t\n\tvar React = _interopRequireWildcard(_react);\n\t\n\tvar _Todo = __webpack_require__(370);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _initDefineProp(target, property, descriptor, context) {\n\t  if (!descriptor) return;\n\t  Object.defineProperty(target, property, {\n\t    enumerable: descriptor.enumerable,\n\t    configurable: descriptor.configurable,\n\t    writable: descriptor.writable,\n\t    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n\t  });\n\t}\n\t\n\tfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n\t  var desc = {};\n\t  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n\t    desc[key] = descriptor[key];\n\t  });\n\t  desc.enumerable = !!desc.enumerable;\n\t  desc.configurable = !!desc.configurable;\n\t\n\t  if ('value' in desc || desc.initializer) {\n\t    desc.writable = true;\n\t  }\n\t\n\t  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n\t    return decorator(target, property, desc) || desc;\n\t  }, desc);\n\t\n\t  if (context && desc.initializer !== void 0) {\n\t    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n\t    desc.initializer = undefined;\n\t  }\n\t\n\t  if (desc.initializer === void 0) {\n\t    Object['define' + 'Property'](target, property, desc);\n\t    desc = null;\n\t  }\n\t\n\t  return desc;\n\t}\n\t\n\tfunction _initializerWarningHelper(descriptor, context) {\n\t  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');\n\t}\n\t\n\tvar TodoList = exports.TodoList = (0, _mobxReact.observer)(_class = (_class2 = function (_React$Component) {\n\t  (0, _inherits3.default)(TodoList, _React$Component);\n\t\n\t  function TodoList() {\n\t    var _ref;\n\t\n\t    var _temp, _this, _ret;\n\t\n\t    (0, _classCallCheck3.default)(this, TodoList);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = TodoList.__proto__ || Object.getPrototypeOf(TodoList)).call.apply(_ref, [this].concat(args))), _this), _initDefineProp(_this, 'newTodoTitle', _descriptor, _this), _this.handleChange = function (e) {\n\t      _this.newTodoTitle = e.target.value;\n\t    }, _this.handleNewTodoClick = function (e) {\n\t      e.stopPropagation();\n\t      _this.props.todoStore.addTodo(_this.newTodoTitle);\n\t      _this.newTodoTitle = '';\n\t    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t\n\t  (0, _createClass3.default)(TodoList, [{\n\t    key: 'render',\n\t    value: function render() {\n\t      var todoStore = this.props.todoStore;\n\t\n\t      return React.createElement(\n\t        'div',\n\t        null,\n\t        React.createElement('input', { value: this.newTodoTitle, onChange: this.handleChange }),\n\t        React.createElement(\n\t          'button',\n\t          { onClick: this.handleNewTodoClick },\n\t          'Add'\n\t        ),\n\t        React.createElement(\n\t          'ul',\n\t          null,\n\t          todoStore.todos.map(function (todo) {\n\t            return React.createElement(_Todo.Todo, { todo: todo, key: todo.id });\n\t          })\n\t        ),\n\t        'Tasks left: ',\n\t        todoStore.unfinishedTodoCount\n\t      );\n\t    }\n\t  }]);\n\t  return TodoList;\n\t}(React.Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'newTodoTitle', [_mobx.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return '';\n\t  }\n\t})), _class2)) || _class;\n\n/***/ }),\n\n/***/ 372:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.TodoStore = exports.Todo = undefined;\n\t\n\tvar _mobxStateTree = __webpack_require__(996);\n\t\n\tvar Todo = exports.Todo = _mobxStateTree.types.model('Todo', {\n\t  id: _mobxStateTree.types.optional(_mobxStateTree.types.number, function () {\n\t    return Math.random();\n\t  }),\n\t  title: _mobxStateTree.types.string,\n\t  finished: false\n\t}).actions(function (self) {\n\t  return {\n\t    toggle: function toggle() {\n\t      self.finished = !self.finished;\n\t    }\n\t  };\n\t});\n\t\n\tvar TodoStore = exports.TodoStore = _mobxStateTree.types.model('TodoStore', {\n\t  todos: _mobxStateTree.types.array(Todo)\n\t}).views(function (self) {\n\t  return {\n\t    get unfinishedTodoCount() {\n\t      return self.todos.filter(function (todo) {\n\t        return !todo.finished;\n\t      }).length;\n\t    }\n\t  };\n\t}).actions(function (self) {\n\t  return {\n\t    addTodo: function addTodo(title) {\n\t      self.todos.push({ title: title });\n\t    }\n\t  };\n\t});\n\n/***/ }),\n\n/***/ 373:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _reactMobxVm = __webpack_require__(19);\n\t\n\tvar _react = __webpack_require__(3);\n\t\n\tvar React = _interopRequireWildcard(_react);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\texports.default = (0, _reactMobxVm.stateless)(function (local) {\n\t  return React.createElement(\n\t    'li',\n\t    null,\n\t    React.createElement('input', {\n\t      type: 'checkbox',\n\t      checked: local.finished,\n\t      onClick: local.toggle.bind(local)\n\t    }),\n\t    local.title\n\t  );\n\t});\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 374:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(11);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(16);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(13);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(12);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _class;\n\t\n\tvar _reactMobxVm = __webpack_require__(19);\n\t\n\tvar _react = __webpack_require__(3);\n\t\n\tvar React = _interopRequireWildcard(_react);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar TodoList = (0, _reactMobxVm.binding)(_class = function (_React$Component) {\n\t  (0, _inherits3.default)(TodoList, _React$Component);\n\t\n\t  function TodoList() {\n\t    var _ref;\n\t\n\t    var _temp, _this, _ret;\n\t\n\t    (0, _classCallCheck3.default)(this, TodoList);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = TodoList.__proto__ || Object.getPrototypeOf(TodoList)).call.apply(_ref, [this].concat(args))), _this), _this.handleNewTodoClick = function (e) {\n\t      e.stopPropagation();\n\t      _this.local.addTodo(_this.newTodoTitle);\n\t      _this.local.newTodoTitle = '';\n\t    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t\n\t  (0, _createClass3.default)(TodoList, [{\n\t    key: 'render',\n\t    value: function render() {\n\t      var todoStore = this.local;\n\t      return React.createElement(\n\t        'div',\n\t        null,\n\t        React.createElement('input', { 'data-bind': 'newTodoTitle' }),\n\t        React.createElement(\n\t          'button',\n\t          { onClick: this.handleNewTodoClick },\n\t          'Add'\n\t        ),\n\t        React.createElement(\n\t          'ul',\n\t          null,\n\t          todoStore.todos.map(function (todo) {\n\t            return (0, _reactMobxVm.h)(todo, { key: todo.id });\n\t          })\n\t        ),\n\t        'Tasks left: ',\n\t        todoStore.unfinishedTodoCount\n\t      );\n\t    }\n\t  }]);\n\t  return TodoList;\n\t}(React.Component)) || _class;\n\t\n\texports.default = TodoList;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 375:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(11);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(16);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(13);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(12);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _dec, _class, _desc, _value, _class2, _descriptor, _descriptor2;\n\t\n\tvar _reactMobxVm = __webpack_require__(19);\n\t\n\tvar _View = __webpack_require__(374);\n\t\n\tvar _View2 = _interopRequireDefault(_View);\n\t\n\tvar _Todo = __webpack_require__(241);\n\t\n\tvar _Todo2 = _interopRequireDefault(_Todo);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _initDefineProp(target, property, descriptor, context) {\n\t  if (!descriptor) return;\n\t  Object.defineProperty(target, property, {\n\t    enumerable: descriptor.enumerable,\n\t    configurable: descriptor.configurable,\n\t    writable: descriptor.writable,\n\t    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n\t  });\n\t}\n\t\n\tfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n\t  var desc = {};\n\t  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n\t    desc[key] = descriptor[key];\n\t  });\n\t  desc.enumerable = !!desc.enumerable;\n\t  desc.configurable = !!desc.configurable;\n\t\n\t  if ('value' in desc || desc.initializer) {\n\t    desc.writable = true;\n\t  }\n\t\n\t  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n\t    return decorator(target, property, desc) || desc;\n\t  }, desc);\n\t\n\t  if (context && desc.initializer !== void 0) {\n\t    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n\t    desc.initializer = undefined;\n\t  }\n\t\n\t  if (desc.initializer === void 0) {\n\t    Object['define' + 'Property'](target, property, desc);\n\t    desc = null;\n\t  }\n\t\n\t  return desc;\n\t}\n\t\n\tfunction _initializerWarningHelper(descriptor, context) {\n\t  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');\n\t}\n\t\n\tvar TodoList = (_dec = (0, _reactMobxVm.bindView)(_View2.default), _dec(_class = (_class2 = function (_Root) {\n\t  (0, _inherits3.default)(TodoList, _Root);\n\t\n\t  function TodoList() {\n\t    var _ref;\n\t\n\t    var _temp, _this, _ret;\n\t\n\t    (0, _classCallCheck3.default)(this, TodoList);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = TodoList.__proto__ || Object.getPrototypeOf(TodoList)).call.apply(_ref, [this].concat(args))), _this), _initDefineProp(_this, 'todos', _descriptor, _this), _initDefineProp(_this, 'newTodoTitle', _descriptor2, _this), _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t\n\t  (0, _createClass3.default)(TodoList, [{\n\t    key: 'addTodo',\n\t    value: function addTodo() {\n\t      this.todos.push(_Todo2.default.create({ title: this.newTodoTitle }));\n\t    }\n\t  }, {\n\t    key: 'unfinishedTodoCount',\n\t    get: function get() {\n\t      return this.todos.filter(function (todo) {\n\t        return !todo.finished;\n\t      }).length;\n\t    }\n\t  }]);\n\t  return TodoList;\n\t}(_reactMobxVm.Root), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, 'todos', [_reactMobxVm.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return [];\n\t  }\n\t}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, 'newTodoTitle', [_reactMobxVm.observable], {\n\t  enumerable: true,\n\t  initializer: function initializer() {\n\t    return '';\n\t  }\n\t}), _applyDecoratedDescriptor(_class2.prototype, 'unfinishedTodoCount', [_reactMobxVm.computed], Object.getOwnPropertyDescriptor(_class2.prototype, 'unfinishedTodoCount'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'addTodo', [_reactMobxVm.action], Object.getOwnPropertyDescriptor(_class2.prototype, 'addTodo'), _class2.prototype)), _class2)) || _class);\n\texports.default = TodoList;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 391:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t\n\tvar apply = Function.prototype.apply;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function () {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function () {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout = exports.clearInterval = function (timeout) {\n\t  if (timeout) {\n\t    timeout.close();\n\t  }\n\t};\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\tTimeout.prototype.close = function () {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function (item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function (item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function (item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout) item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// setimmediate attaches itself to the global object\n\t__webpack_require__(1113);\n\t// On some exotic environments, it's not clear which object `setimmeidate` was\n\t// able to install onto.  Search each possibility in the same order as the\n\t// `setimmediate` library.\n\texports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || undefined && undefined.setImmediate;\n\texports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || undefined && undefined.clearImmediate;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n\n/***/ 996:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate) {'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tvar mobx = __webpack_require__(94);\n\t\n\t/**\n\t * Returns the _actual_ type of the given tree node. (Or throws)\n\t *\n\t * @export\n\t * @param {IStateTreeNode} object\n\t * @returns {IType<S, T>}\n\t */\n\tfunction getType$$1(object) {\n\t    return getStateTreeNode$$1(object).type;\n\t}\n\t/**\n\t * Returns the _declared_ type of the given sub property of an object, array or map.\n\t *\n\t * @example\n\t * const Box = types.model({ x: 0, y: 0 })\n\t * const box = Box.create()\n\t *\n\t * console.log(getChildType(box, \"x\").name) // 'number'\n\t *\n\t * @export\n\t * @param {IStateTreeNode} object\n\t * @param {string} child\n\t * @returns {IType<any, any>}\n\t */\n\tfunction getChildType$$1(object, child) {\n\t    return getStateTreeNode$$1(object).getChildType(child);\n\t}\n\t/**\n\t * Registers a function that will be invoked for each mutation that is applied to the provided model instance, or to any of its children.\n\t * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details. onPatch events are emitted immediately and will not await the end of a transaction.\n\t * Patches can be used to deep observe a model tree.\n\t *\n\t * @export\n\t * @param {Object} target the model instance from which to receive patches\n\t * @param {(patch: IJsonPatch, reversePatch) => void} callback the callback that is invoked for each patch. The reversePatch is a patch that would actually undo the emitted patch\n\t * @param {includeOldValue} boolean if oldValue is included in the patches, they can be inverted. However patches will become much bigger and might not be suitable for efficient transport\n\t * @returns {IDisposer} function to remove the listener\n\t */\n\tfunction onPatch$$1(target, callback) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (typeof callback !== \"function\")\n\t            fail(\"expected second argument to be a function, got \" + callback + \" instead\");\n\t    }\n\t    return getStateTreeNode$$1(target).onPatch(callback);\n\t}\n\t/**\n\t * Registers a function that is invoked whenever a new snapshot for the given model instance is available.\n\t * The listener will only be fire at the and of the current MobX (trans)action.\n\t * See [snapshots](https://github.com/mobxjs/mobx-state-tree#snapshots) for more details.\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @param {(snapshot: any) => void} callback\n\t * @returns {IDisposer}\n\t */\n\tfunction onSnapshot$$1(target, callback) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (typeof callback !== \"function\")\n\t            fail(\"expected second argument to be a function, got \" + callback + \" instead\");\n\t    }\n\t    return getStateTreeNode$$1(target).onSnapshot(callback);\n\t}\n\t/**\n\t * Applies a JSON-patch to the given model instance or bails out if the patch couldn't be applied\n\t * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details.\n\t *\n\t * Can apply a single past, or an array of patches.\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @param {IJsonPatch} patch\n\t * @returns\n\t */\n\tfunction applyPatch$$1(target, patch) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (typeof patch !== \"object\")\n\t            fail(\"expected second argument to be an object or array, got \" + patch + \" instead\");\n\t    }\n\t    getStateTreeNode$$1(target).applyPatches(asArray(patch));\n\t}\n\t/**\n\t * Small abstraction around `onPatch` and `applyPatch`, attaches a patch listener to a tree and records all the patches.\n\t * Returns an recorder object with the following signature:\n\t *\n\t * @example\n\t * export interface IPatchRecorder {\n\t *      // the recorded patches\n\t *      patches: IJsonPatch[]\n\t *      // the inverse of the recorded patches\n\t *      inversePatches: IJsonPatch[]\n\t *      // stop recording patches\n\t *      stop(target?: IStateTreeNode): any\n\t *      // resume recording patches\n\t *      resume()\n\t *      // apply all the recorded patches on the given target (the original subject if omitted)\n\t *      replay(target?: IStateTreeNode): any\n\t *      // reverse apply the recorded patches on the given target  (the original subject if omitted)\n\t *      // stops the recorder if not already stopped\n\t *      undo(): void\n\t * }\n\t *\n\t * @export\n\t * @param {IStateTreeNode} subject\n\t * @returns {IPatchRecorder}\n\t */\n\tfunction recordPatches$$1(subject) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(subject))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + subject + \" instead\");\n\t    }\n\t    var disposer = null;\n\t    function resume() {\n\t        if (disposer)\n\t            return;\n\t        disposer = onPatch$$1(subject, function (patch, inversePatch) {\n\t            recorder.rawPatches.push([patch, inversePatch]);\n\t        });\n\t    }\n\t    var recorder = {\n\t        rawPatches: [],\n\t        get patches() {\n\t            return this.rawPatches.map(function (_a) {\n\t                var a = _a[0];\n\t                return a;\n\t            });\n\t        },\n\t        get inversePatches() {\n\t            return this.rawPatches.map(function (_a) {\n\t                var _ = _a[0], b = _a[1];\n\t                return b;\n\t            });\n\t        },\n\t        stop: function () {\n\t            if (disposer)\n\t                disposer();\n\t            disposer = null;\n\t        },\n\t        resume: resume,\n\t        replay: function (target) {\n\t            applyPatch$$1(target || subject, recorder.patches);\n\t        },\n\t        undo: function (target) {\n\t            applyPatch$$1(target || subject, recorder.inversePatches.slice().reverse());\n\t        }\n\t    };\n\t    resume();\n\t    return recorder;\n\t}\n\t/**\n\t * The inverse of `unprotect`\n\t *\n\t * @export\n\t * @param {IStateTreeNode} target\n\t *\n\t */\n\tfunction protect$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    var node = getStateTreeNode$$1(target);\n\t    if (!node.isRoot)\n\t        fail(\"`protect` can only be invoked on root nodes\");\n\t    node.isProtectionEnabled = true;\n\t}\n\t/**\n\t * By default it is not allowed to directly modify a model. Models can only be modified through actions.\n\t * However, in some cases you don't care about the advantages (like replayability, traceability, etc) this yields.\n\t * For example because you are building a PoC or don't have any middleware attached to your tree.\n\t *\n\t * In that case you can disable this protection by calling `unprotect` on the root of your tree.\n\t *\n\t * @example\n\t * const Todo = types.model({\n\t *     done: false\n\t * }).actions(self => ({\n\t *     toggle() {\n\t *         self.done = !self.done\n\t *     }\n\t * }))\n\t *\n\t * const todo = Todo.create()\n\t * todo.done = true // throws!\n\t * todo.toggle() // OK\n\t * unprotect(todo)\n\t * todo.done = false // OK\n\t */\n\tfunction unprotect$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    var node = getStateTreeNode$$1(target);\n\t    if (!node.isRoot)\n\t        fail(\"`unprotect` can only be invoked on root nodes\");\n\t    node.isProtectionEnabled = false;\n\t}\n\t/**\n\t * Returns true if the object is in protected mode, @see protect\n\t */\n\tfunction isProtected$$1(target) {\n\t    return getStateTreeNode$$1(target).isProtected;\n\t}\n\t/**\n\t * Applies a snapshot to a given model instances. Patch and snapshot listeners will be invoked as usual.\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @param {Object} snapshot\n\t * @returns\n\t */\n\tfunction applySnapshot$$1(target, snapshot) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    return getStateTreeNode$$1(target).applySnapshot(snapshot);\n\t}\n\t/**\n\t * Calculates a snapshot from the given model instance. The snapshot will always reflect the latest state but use\n\t * structural sharing where possible. Doesn't require MobX transactions to be completed.\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @returns {*}\n\t */\n\tfunction getSnapshot$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    return getStateTreeNode$$1(target).snapshot;\n\t}\n\t/**\n\t * Given a model instance, returns `true` if the object has a parent, that is, is part of another object, map or array\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @param {number} depth = 1, how far should we look upward?\n\t * @returns {boolean}\n\t */\n\tfunction hasParent$$1(target, depth) {\n\t    if (depth === void 0) { depth = 1; }\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (typeof depth !== \"number\")\n\t            fail(\"expected second argument to be a number, got \" + depth + \" instead\");\n\t        if (depth < 0)\n\t            fail(\"Invalid depth: \" + depth + \", should be >= 1\");\n\t    }\n\t    var parent = getStateTreeNode$$1(target).parent;\n\t    while (parent) {\n\t        if (--depth === 0)\n\t            return true;\n\t        parent = parent.parent;\n\t    }\n\t    return false;\n\t}\n\t/**\n\t * Returns the immediate parent of this object, or null.\n\t *\n\t * Note that the immediate parent can be either an object, map or array, and\n\t * doesn't necessarily refer to the parent model\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @param {number} depth = 1, how far should we look upward?\n\t * @returns {*}\n\t */\n\tfunction getParent$$1(target, depth) {\n\t    if (depth === void 0) { depth = 1; }\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (typeof depth !== \"number\")\n\t            fail(\"expected second argument to be a number, got \" + depth + \" instead\");\n\t        if (depth < 0)\n\t            fail(\"Invalid depth: \" + depth + \", should be >= 1\");\n\t    }\n\t    var d = depth;\n\t    var parent = getStateTreeNode$$1(target).parent;\n\t    while (parent) {\n\t        if (--d === 0)\n\t            return parent.storedValue;\n\t        parent = parent.parent;\n\t    }\n\t    return fail(\"Failed to find the parent of \" + getStateTreeNode$$1(target) + \" at depth \" + depth);\n\t}\n\t/**\n\t * Given an object in a model tree, returns the root object of that tree\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @returns {*}\n\t */\n\tfunction getRoot$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    return getStateTreeNode$$1(target).root.storedValue;\n\t}\n\t/**\n\t * Returns the path of the given object in the model tree\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @returns {string}\n\t */\n\tfunction getPath$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    return getStateTreeNode$$1(target).path;\n\t}\n\t/**\n\t * Returns the path of the given object as unescaped string array\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @returns {string[]}\n\t */\n\tfunction getPathParts$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    return splitJsonPath$$1(getStateTreeNode$$1(target).path);\n\t}\n\t/**\n\t * Returns true if the given object is the root of a model tree\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @returns {boolean}\n\t */\n\tfunction isRoot$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    return getStateTreeNode$$1(target).isRoot;\n\t}\n\t/**\n\t * Resolves a path relatively to a given object.\n\t * Returns undefined if no value can be found.\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @param {string} path - escaped json path\n\t * @returns {*}\n\t */\n\tfunction resolvePath$$1(target, path) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (typeof path !== \"string\")\n\t            fail(\"expected second argument to be a number, got \" + path + \" instead\");\n\t    }\n\t    var node = resolveNodeByPath$$1(getStateTreeNode$$1(target), path);\n\t    return node ? node.value : undefined;\n\t}\n\t/**\n\t * Resolves a model instance given a root target, the type and the identifier you are searching for.\n\t * Returns undefined if no value can be found.\n\t *\n\t * @export\n\t * @param {IType<any, any>} type\n\t * @param {IStateTreeNode} target\n\t * @param {(string | number)} identifier\n\t * @returns {*}\n\t */\n\tfunction resolveIdentifier$$1(type, target, identifier$$1) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isType$$1(type))\n\t            fail(\"expected first argument to be a mobx-state-tree type, got \" + type + \" instead\");\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected second argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (!(typeof identifier$$1 === \"string\" || typeof identifier$$1 === \"number\"))\n\t            fail(\"expected third argument to be a string or number, got \" + identifier$$1 + \" instead\");\n\t    }\n\t    var node = getStateTreeNode$$1(target).root.identifierCache.resolve(type, \"\" + identifier$$1);\n\t    return node ? node.value : undefined;\n\t}\n\t/**\n\t *\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @param {string} path\n\t * @returns {*}\n\t */\n\tfunction tryResolve$$1(target, path) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (typeof path !== \"string\")\n\t            fail(\"expected second argument to be a string, got \" + path + \" instead\");\n\t    }\n\t    var node = resolveNodeByPath$$1(getStateTreeNode$$1(target), path, false);\n\t    if (node === undefined)\n\t        return undefined;\n\t    return node ? node.value : undefined;\n\t}\n\t/**\n\t * Given two state tree nodes that are part of the same tree,\n\t * returns the shortest jsonpath needed to navigate from the one to the other\n\t *\n\t * @export\n\t * @param {IStateTreeNode} base\n\t * @param {IStateTreeNode} target\n\t * @returns {string}\n\t */\n\tfunction getRelativePath$$1(base, target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected second argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (!isStateTreeNode$$1(base))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + base + \" instead\");\n\t    }\n\t    return getRelativePathBetweenNodes$$1(getStateTreeNode$$1(base), getStateTreeNode$$1(target));\n\t}\n\t/**\n\t * Returns a deep copy of the given state tree node as new tree.\n\t * Short hand for `snapshot(x) = getType(x).create(getSnapshot(x))`\n\t *\n\t * _Tip: clone will create a literal copy, including the same identifiers. To modify identifiers etc during cloning, don't use clone but take a snapshot of the tree, modify it, and create new instance_\n\t *\n\t * @export\n\t * @template T\n\t * @param {T} source\n\t * @param {boolean | any} keepEnvironment indicates whether the clone should inherit the same environment (`true`, the default), or not have an environment (`false`). If an object is passed in as second argument, that will act as the environment for the cloned tree.\n\t * @returns {T}\n\t */\n\tfunction clone$$1(source, keepEnvironment) {\n\t    if (keepEnvironment === void 0) { keepEnvironment = true; }\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(source))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + source + \" instead\");\n\t    }\n\t    var node = getStateTreeNode$$1(source);\n\t    return node.type.create(node.snapshot, keepEnvironment === true\n\t        ? node.root._environment\n\t        : keepEnvironment === false ? undefined : keepEnvironment); // it's an object or something else\n\t}\n\t/**\n\t * Removes a model element from the state tree, and let it live on as a new state tree\n\t */\n\tfunction detach$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    getStateTreeNode$$1(target).detach();\n\t    return target;\n\t}\n\t/**\n\t * Removes a model element from the state tree, and mark it as end-of-life; the element should not be used anymore\n\t */\n\tfunction destroy$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    var node = getStateTreeNode$$1(target);\n\t    if (node.isRoot)\n\t        node.die();\n\t    else\n\t        node.parent.removeChild(node.subpath);\n\t}\n\t/**\n\t * Returns true if the given state tree node is not killed yet.\n\t * This means that the node is still a part of a tree, and that `destroy`\n\t * has not been called. If a node is not alive anymore, the only thing one can do with it\n\t * is requesting it's last path and snapshot\n\t *\n\t * @export\n\t * @param {IStateTreeNode} target\n\t * @returns {boolean}\n\t */\n\tfunction isAlive$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    return getStateTreeNode$$1(target).isAlive;\n\t}\n\t/**\n\t * Use this utility to register a function that should be called whenever the\n\t * targeted state tree node is destroyed. This is a useful alternative to managing\n\t * cleanup methods yourself using the `beforeDestroy` hook.\n\t *\n\t * @example\n\t * const Todo = types.model({\n\t *   title: types.string\n\t * }).actions(self => ({\n\t *   afterCreate() {\n\t *     const autoSaveDisposer = reaction(\n\t *       () => getSnapshot(self),\n\t *       snapshot => sendSnapshotToServerSomehow(snapshot)\n\t *     )\n\t *     // stop sending updates to server if this\n\t *     // instance is destroyed\n\t *     addDisposer(self, autoSaveDisposer)\n\t *   }\n\t * }))\n\t *\n\t * @export\n\t * @param {IStateTreeNode} target\n\t * @param {() => void} disposer\n\t */\n\tfunction addDisposer$$1(target, disposer) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (typeof disposer !== \"function\")\n\t            fail(\"expected second argument to be a function, got \" + disposer + \" instead\");\n\t    }\n\t    getStateTreeNode$$1(target).addDisposer(disposer);\n\t}\n\t/**\n\t * Returns the environment of the current state tree. For more info on environments,\n\t * see [Dependency injection](https://github.com/mobxjs/mobx-state-tree#dependency-injection)\n\t *\n\t * Returns an empty environment if the tree wasn't initialized with an environment\n\t *\n\t * @export\n\t * @param {IStateTreeNode} target\n\t * @returns {*}\n\t */\n\tfunction getEnv$$1(target) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t    }\n\t    var node = getStateTreeNode$$1(target);\n\t    var env = node.root._environment;\n\t    if (!!!env)\n\t        return EMPTY_OBJECT;\n\t    return env;\n\t}\n\t/**\n\t * Performs a depth first walk through a tree\n\t */\n\tfunction walk$$1(target, processor) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (typeof processor !== \"function\")\n\t            fail(\"expected second argument to be a function, got \" + processor + \" instead\");\n\t    }\n\t    var node = getStateTreeNode$$1(target);\n\t    // tslint:disable-next-line:no_unused-variable\n\t    node.getChildren().forEach(function (child) {\n\t        if (isStateTreeNode$$1(child.storedValue))\n\t            walk$$1(child.storedValue, processor);\n\t    });\n\t    processor(node.storedValue);\n\t}\n\t\n\t/*! *****************************************************************************\r\n\tCopyright (c) Microsoft Corporation. All rights reserved.\r\n\tLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n\tthis file except in compliance with the License. You may obtain a copy of the\r\n\tLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\t\r\n\tTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n\tKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n\tWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n\tMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\t\r\n\tSee the Apache Version 2.0 License for specific language governing permissions\r\n\tand limitations under the License.\r\n\t***************************************************************************** */\r\n\t/* global Reflect, Promise */\r\n\t\r\n\tvar extendStatics = Object.setPrototypeOf ||\r\n\t    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\t\r\n\tfunction __extends(d, b) {\r\n\t    extendStatics(d, b);\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\tfunction __rest(s, e) {\r\n\t    var t = {};\r\n\t    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n\t        t[p] = s[p];\r\n\t    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n\t        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n\t            t[p[i]] = s[p[i]];\r\n\t    return t;\r\n\t}\r\n\t\r\n\tfunction __decorate(decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t}\n\t\n\tvar ScalarNode$$1 = /** @class */ (function () {\n\t    function ScalarNode$$1(type, parent, subpath, environment, initialValue, storedValue, canAttachTreeNode, finalizeNewInstance) {\n\t        if (finalizeNewInstance === void 0) { finalizeNewInstance = noop; }\n\t        this.subpath = \"\";\n\t        this._environment = undefined;\n\t        this._autoUnbox = true; // unboxing is disabled when reading child nodes\n\t        this.state = NodeLifeCycle$$1.INITIALIZING;\n\t        this.type = type;\n\t        this.storedValue = storedValue;\n\t        this._parent = parent;\n\t        this.subpath = subpath;\n\t        this.storedValue = storedValue;\n\t        this._environment = environment;\n\t        this.unbox = this.unbox.bind(this);\n\t        if (canAttachTreeNode)\n\t            addHiddenFinalProp(this.storedValue, \"$treenode\", this);\n\t        var sawException = true;\n\t        try {\n\t            if (canAttachTreeNode)\n\t                addHiddenFinalProp(this.storedValue, \"toJSON\", toJSON$$1);\n\t            finalizeNewInstance(this, initialValue);\n\t            this.state = NodeLifeCycle$$1.CREATED;\n\t            sawException = false;\n\t        }\n\t        finally {\n\t            if (sawException) {\n\t                // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n\t                this.state = NodeLifeCycle$$1.DEAD;\n\t            }\n\t        }\n\t    }\n\t    Object.defineProperty(ScalarNode$$1.prototype, \"path\", {\n\t        /*\n\t         * Returnes (escaped) path representation as string\n\t         */\n\t        get: function () {\n\t            if (!this.parent)\n\t                return \"\";\n\t            return this.parent.path + \"/\" + escapeJsonPath$$1(this.subpath);\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ScalarNode$$1.prototype, \"isRoot\", {\n\t        get: function () {\n\t            return this.parent === null;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ScalarNode$$1.prototype, \"parent\", {\n\t        get: function () {\n\t            return this._parent;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ScalarNode$$1.prototype, \"root\", {\n\t        get: function () {\n\t            // future optimization: store root ref in the node and maintain it\n\t            if (!this._parent)\n\t                return fail(\"This scalar node is not part of a tree\");\n\t            return this._parent.root;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ScalarNode$$1.prototype.setParent = function (newParent, subpath) {\n\t        if (subpath === void 0) { subpath = null; }\n\t        if (this.parent !== newParent)\n\t            fail(\"Cannot change parent of immutable node\");\n\t        if (this.subpath === subpath)\n\t            return;\n\t        this.subpath = subpath || \"\";\n\t    };\n\t    Object.defineProperty(ScalarNode$$1.prototype, \"value\", {\n\t        get: function () {\n\t            return this.type.getValue(this);\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ScalarNode$$1.prototype, \"snapshot\", {\n\t        get: function () {\n\t            var snapshot = this.type.getSnapshot(this);\n\t            // avoid any external modification in dev mode\n\t            if (false) {\n\t                return freeze(snapshot);\n\t            }\n\t            return snapshot;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ScalarNode$$1.prototype, \"isAlive\", {\n\t        get: function () {\n\t            return this.state !== NodeLifeCycle$$1.DEAD;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ScalarNode$$1.prototype.unbox = function (childNode) {\n\t        if (childNode && this._autoUnbox === true)\n\t            return childNode.value;\n\t        return childNode;\n\t    };\n\t    ScalarNode$$1.prototype.toString = function () {\n\t        return this.type.name + \"@\" + (this.path || \"<root>\") + (this.isAlive ? \"\" : \"[dead]\");\n\t    };\n\t    ScalarNode$$1.prototype.die = function () {\n\t        this.state = NodeLifeCycle$$1.DEAD;\n\t    };\n\t    __decorate([\n\t        mobx.observable\n\t    ], ScalarNode$$1.prototype, \"subpath\", void 0);\n\t    return ScalarNode$$1;\n\t}());\n\t\n\tvar nextNodeId = 1;\n\tvar ObjectNode$$1 = /** @class */ (function () {\n\t    function ObjectNode$$1(type, parent, subpath, environment, initialValue, storedValue, canAttachTreeNode, finalizeNewInstance) {\n\t        if (finalizeNewInstance === void 0) { finalizeNewInstance = noop; }\n\t        var _this = this;\n\t        this.nodeId = ++nextNodeId;\n\t        this.subpath = \"\";\n\t        this._parent = null;\n\t        this._isRunningAction = false; // only relevant for root\n\t        this.isProtectionEnabled = true;\n\t        this.identifierAttribute = undefined; // not to be modified directly, only through model initialization\n\t        this._environment = undefined;\n\t        this._autoUnbox = true; // unboxing is disabled when reading child nodes\n\t        this.state = NodeLifeCycle$$1.INITIALIZING;\n\t        this.middlewares = EMPTY_ARRAY;\n\t        this.type = type;\n\t        this.storedValue = storedValue;\n\t        this._parent = parent;\n\t        this.subpath = subpath;\n\t        this._environment = environment;\n\t        this.unbox = this.unbox.bind(this);\n\t        this.preboot();\n\t        if (!parent)\n\t            this.identifierCache = new IdentifierCache$$1();\n\t        if (canAttachTreeNode)\n\t            addHiddenFinalProp(this.storedValue, \"$treenode\", this);\n\t        var sawException = true;\n\t        try {\n\t            if (canAttachTreeNode)\n\t                addHiddenFinalProp(this.storedValue, \"toJSON\", toJSON$$1);\n\t            this._isRunningAction = true;\n\t            finalizeNewInstance(this, initialValue);\n\t            this._isRunningAction = false;\n\t            if (parent)\n\t                parent.root.identifierCache.addNodeToCache(this);\n\t            else\n\t                this.identifierCache.addNodeToCache(this);\n\t            this.fireHook(\"afterCreate\");\n\t            this.state = NodeLifeCycle$$1.CREATED;\n\t            sawException = false;\n\t        }\n\t        finally {\n\t            if (sawException) {\n\t                // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n\t                this.state = NodeLifeCycle$$1.DEAD;\n\t            }\n\t        }\n\t        var snapshotDisposer = mobx.reaction(function () { return _this.snapshot; }, function (snapshot) {\n\t            _this.emitSnapshot(snapshot);\n\t        });\n\t        snapshotDisposer.onError(function (e) {\n\t            throw e;\n\t        });\n\t        this.addDisposer(snapshotDisposer);\n\t    }\n\t    Object.defineProperty(ObjectNode$$1.prototype, \"path\", {\n\t        /*\n\t         * Returnes (escaped) path representation as string\n\t         */\n\t        get: function () {\n\t            if (!this.parent)\n\t                return \"\";\n\t            return this.parent.path + \"/\" + escapeJsonPath$$1(this.subpath);\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ObjectNode$$1.prototype, \"isRoot\", {\n\t        get: function () {\n\t            return this.parent === null;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ObjectNode$$1.prototype, \"parent\", {\n\t        get: function () {\n\t            return this._parent;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ObjectNode$$1.prototype, \"root\", {\n\t        // Optimization: make computed\n\t        get: function () {\n\t            var p, r = this;\n\t            while ((p = r.parent))\n\t                r = p;\n\t            return r;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ObjectNode$$1.prototype.setParent = function (newParent, subpath) {\n\t        if (subpath === void 0) { subpath = null; }\n\t        if (this.parent === newParent && this.subpath === subpath)\n\t            return;\n\t        if (newParent) {\n\t            if (this._parent && newParent !== this._parent) {\n\t                fail(\"A node cannot exists twice in the state tree. Failed to add \" + this + \" to path '\" + newParent.path + \"/\" + subpath + \"'.\");\n\t            }\n\t            if (!this._parent && newParent.root === this) {\n\t                fail(\"A state tree is not allowed to contain itself. Cannot assign \" + this + \" to path '\" + newParent.path + \"/\" + subpath + \"'\");\n\t            }\n\t            if (!this._parent &&\n\t                !!this.root._environment &&\n\t                this.root._environment !== newParent.root._environment) {\n\t                fail(\"A state tree cannot be made part of another state tree as long as their environments are different.\");\n\t            }\n\t        }\n\t        if (this.parent && !newParent) {\n\t            this.die();\n\t        }\n\t        else {\n\t            this.subpath = subpath || \"\";\n\t            if (newParent && newParent !== this._parent) {\n\t                newParent.root.identifierCache.mergeCache(this);\n\t                this._parent = newParent;\n\t                this.fireHook(\"afterAttach\");\n\t            }\n\t        }\n\t    };\n\t    ObjectNode$$1.prototype.fireHook = function (name) {\n\t        var fn = this.storedValue && typeof this.storedValue === \"object\" && this.storedValue[name];\n\t        if (typeof fn === \"function\")\n\t            fn.apply(this.storedValue);\n\t    };\n\t    Object.defineProperty(ObjectNode$$1.prototype, \"value\", {\n\t        get: function () {\n\t            if (!this.isAlive)\n\t                return undefined;\n\t            return this.type.getValue(this);\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ObjectNode$$1.prototype, \"snapshot\", {\n\t        get: function () {\n\t            if (!this.isAlive)\n\t                return undefined;\n\t            // advantage of using computed for a snapshot is that nicely respects transactions etc.\n\t            var snapshot = this.type.getSnapshot(this);\n\t            // avoid any external modification in dev mode\n\t            if (false) {\n\t                return freeze(snapshot);\n\t            }\n\t            return snapshot;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ObjectNode$$1.prototype.isRunningAction = function () {\n\t        if (this._isRunningAction)\n\t            return true;\n\t        if (this.isRoot)\n\t            return false;\n\t        return this.parent.isRunningAction();\n\t    };\n\t    Object.defineProperty(ObjectNode$$1.prototype, \"identifier\", {\n\t        get: function () {\n\t            return this.identifierAttribute ? this.storedValue[this.identifierAttribute] : null;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ObjectNode$$1.prototype, \"isAlive\", {\n\t        get: function () {\n\t            return this.state !== NodeLifeCycle$$1.DEAD;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ObjectNode$$1.prototype.assertAlive = function () {\n\t        if (!this.isAlive)\n\t            fail(this + \" cannot be used anymore as it has died; it has been removed from a state tree. If you want to remove an element from a tree and let it live on, use 'detach' or 'clone' the value\");\n\t    };\n\t    ObjectNode$$1.prototype.getChildNode = function (subpath) {\n\t        this.assertAlive();\n\t        this._autoUnbox = false;\n\t        var res = this.type.getChildNode(this, subpath);\n\t        this._autoUnbox = true;\n\t        return res;\n\t    };\n\t    ObjectNode$$1.prototype.getChildren = function () {\n\t        this.assertAlive();\n\t        this._autoUnbox = false;\n\t        var res = this.type.getChildren(this);\n\t        this._autoUnbox = true;\n\t        return res;\n\t    };\n\t    ObjectNode$$1.prototype.getChildType = function (key) {\n\t        return this.type.getChildType(key);\n\t    };\n\t    Object.defineProperty(ObjectNode$$1.prototype, \"isProtected\", {\n\t        get: function () {\n\t            return this.root.isProtectionEnabled;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ObjectNode$$1.prototype.assertWritable = function () {\n\t        this.assertAlive();\n\t        if (!this.isRunningAction() && this.isProtected) {\n\t            fail(\"Cannot modify '\" + this + \"', the object is protected and can only be modified by using an action.\");\n\t        }\n\t    };\n\t    ObjectNode$$1.prototype.removeChild = function (subpath) {\n\t        this.type.removeChild(this, subpath);\n\t    };\n\t    ObjectNode$$1.prototype.unbox = function (childNode) {\n\t        if (childNode && this._autoUnbox === true)\n\t            return childNode.value;\n\t        return childNode;\n\t    };\n\t    ObjectNode$$1.prototype.toString = function () {\n\t        var identifier$$1 = this.identifier ? \"(id: \" + this.identifier + \")\" : \"\";\n\t        return this.type.name + \"@\" + (this.path || \"<root>\") + identifier$$1 + (this.isAlive\n\t            ? \"\"\n\t            : \"[dead]\");\n\t    };\n\t    ObjectNode$$1.prototype.finalizeCreation = function () {\n\t        // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already\n\t        if (this.state === NodeLifeCycle$$1.CREATED) {\n\t            if (this.parent) {\n\t                if (this.parent.state !== NodeLifeCycle$$1.FINALIZED) {\n\t                    // parent not ready yet, postpone\n\t                    return;\n\t                }\n\t                this.fireHook(\"afterAttach\");\n\t            }\n\t            this.state = NodeLifeCycle$$1.FINALIZED;\n\t            for (var _i = 0, _a = this.getChildren(); _i < _a.length; _i++) {\n\t                var child = _a[_i];\n\t                if (child instanceof ObjectNode$$1)\n\t                    child.finalizeCreation();\n\t            }\n\t        }\n\t    };\n\t    ObjectNode$$1.prototype.detach = function () {\n\t        if (!this.isAlive)\n\t            fail(\"Error while detaching, node is not alive.\");\n\t        if (this.isRoot)\n\t            return;\n\t        else {\n\t            this.fireHook(\"beforeDetach\");\n\t            this._environment = this.root._environment; // make backup of environment\n\t            this.state = NodeLifeCycle$$1.DETACHING;\n\t            this.identifierCache = this.root.identifierCache.splitCache(this);\n\t            this.parent.removeChild(this.subpath);\n\t            this._parent = null;\n\t            this.subpath = \"\";\n\t            this.state = NodeLifeCycle$$1.FINALIZED;\n\t        }\n\t    };\n\t    ObjectNode$$1.prototype.preboot = function () {\n\t        var _this = this;\n\t        this.disposers = [];\n\t        this.middlewares = [];\n\t        this.snapshotSubscribers = [];\n\t        this.patchSubscribers = [];\n\t        // Optimization: this does not need to be done per instance\n\t        // if some pieces from createActionInvoker are extracted\n\t        this.applyPatches = createActionInvoker$$1(this.storedValue, \"@APPLY_PATCHES\", function (patches) {\n\t            patches.forEach(function (patch) {\n\t                var parts = splitJsonPath$$1(patch.path);\n\t                var node = resolveNodeByPathParts$$1(_this, parts.slice(0, -1));\n\t                node.applyPatchLocally(parts[parts.length - 1], patch);\n\t            });\n\t        }).bind(this.storedValue);\n\t        this.applySnapshot = createActionInvoker$$1(this.storedValue, \"@APPLY_SNAPSHOT\", function (snapshot) {\n\t            // if the snapshot is the same as the current one, avoid performing a reconcile\n\t            if (snapshot === _this.snapshot)\n\t                return;\n\t            // else, apply it by calling the type logic\n\t            return _this.type.applySnapshot(_this, snapshot);\n\t        }).bind(this.storedValue);\n\t    };\n\t    ObjectNode$$1.prototype.die = function () {\n\t        if (this.state === NodeLifeCycle$$1.DETACHING)\n\t            return;\n\t        if (isStateTreeNode$$1(this.storedValue)) {\n\t            // optimization: don't use walk, but getChildNodes for more efficiency\n\t            walk$$1(this.storedValue, function (child) {\n\t                var node = getStateTreeNode$$1(child);\n\t                if (node instanceof ObjectNode$$1)\n\t                    node.aboutToDie();\n\t            });\n\t            walk$$1(this.storedValue, function (child) {\n\t                var node = getStateTreeNode$$1(child);\n\t                if (node instanceof ObjectNode$$1)\n\t                    node.finalizeDeath();\n\t            });\n\t        }\n\t    };\n\t    ObjectNode$$1.prototype.aboutToDie = function () {\n\t        this.disposers.splice(0).forEach(function (f) { return f(); });\n\t        this.fireHook(\"beforeDestroy\");\n\t    };\n\t    ObjectNode$$1.prototype.finalizeDeath = function () {\n\t        // invariant: not called directly but from \"die\"\n\t        this.root.identifierCache.notifyDied(this);\n\t        var self = this;\n\t        var oldPath = this.path;\n\t        addReadOnlyProp(this, \"snapshot\", this.snapshot); // kill the computed prop and just store the last snapshot\n\t        this.patchSubscribers.splice(0);\n\t        this.snapshotSubscribers.splice(0);\n\t        this.patchSubscribers.splice(0);\n\t        this.state = NodeLifeCycle$$1.DEAD;\n\t        this._parent = null;\n\t        this.subpath = \"\";\n\t        // This is quite a hack, once interceptable objects / arrays / maps are extracted from mobx,\n\t        // we could express this in a much nicer way\n\t        // TODO: should be possible to obtain id's still...\n\t        Object.defineProperty(this.storedValue, \"$mobx\", {\n\t            get: function () {\n\t                fail(\"This object has died and is no longer part of a state tree. It cannot be used anymore. The object (of type '\" + self\n\t                    .type\n\t                    .name + \"') used to live at '\" + oldPath + \"'. It is possible to access the last snapshot of this object using 'getSnapshot', or to create a fresh copy using 'clone'. If you want to remove an object from the tree without killing it, use 'detach' instead.\");\n\t            }\n\t        });\n\t    };\n\t    ObjectNode$$1.prototype.onSnapshot = function (onChange) {\n\t        return registerEventHandler(this.snapshotSubscribers, onChange);\n\t    };\n\t    ObjectNode$$1.prototype.emitSnapshot = function (snapshot) {\n\t        this.snapshotSubscribers.forEach(function (f) { return f(snapshot); });\n\t    };\n\t    ObjectNode$$1.prototype.onPatch = function (handler) {\n\t        return registerEventHandler(this.patchSubscribers, handler);\n\t    };\n\t    ObjectNode$$1.prototype.emitPatch = function (basePatch, source) {\n\t        if (this.patchSubscribers.length) {\n\t            var localizedPatch = extend({}, basePatch, {\n\t                path: source.path.substr(this.path.length) + \"/\" + basePatch.path // calculate the relative path of the patch\n\t            });\n\t            var _a = splitPatch$$1(localizedPatch), patch_1 = _a[0], reversePatch_1 = _a[1];\n\t            this.patchSubscribers.forEach(function (f) { return f(patch_1, reversePatch_1); });\n\t        }\n\t        if (this.parent)\n\t            this.parent.emitPatch(basePatch, source);\n\t    };\n\t    ObjectNode$$1.prototype.addDisposer = function (disposer) {\n\t        this.disposers.unshift(disposer);\n\t    };\n\t    ObjectNode$$1.prototype.addMiddleWare = function (handler) {\n\t        return registerEventHandler(this.middlewares, handler);\n\t    };\n\t    ObjectNode$$1.prototype.applyPatchLocally = function (subpath, patch) {\n\t        this.assertWritable();\n\t        this.type.applyPatchLocally(this, subpath, patch);\n\t    };\n\t    __decorate([\n\t        mobx.observable\n\t    ], ObjectNode$$1.prototype, \"subpath\", void 0);\n\t    __decorate([\n\t        mobx.observable\n\t    ], ObjectNode$$1.prototype, \"_parent\", void 0);\n\t    __decorate([\n\t        mobx.computed\n\t    ], ObjectNode$$1.prototype, \"path\", null);\n\t    __decorate([\n\t        mobx.computed\n\t    ], ObjectNode$$1.prototype, \"value\", null);\n\t    __decorate([\n\t        mobx.computed\n\t    ], ObjectNode$$1.prototype, \"snapshot\", null);\n\t    return ObjectNode$$1;\n\t}());\n\t\n\tvar TypeFlags$$1;\n\t(function (TypeFlags$$1) {\n\t    TypeFlags$$1[TypeFlags$$1[\"String\"] = 1] = \"String\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Number\"] = 2] = \"Number\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Boolean\"] = 4] = \"Boolean\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Date\"] = 8] = \"Date\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Literal\"] = 16] = \"Literal\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Array\"] = 32] = \"Array\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Map\"] = 64] = \"Map\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Object\"] = 128] = \"Object\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Frozen\"] = 256] = \"Frozen\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Optional\"] = 512] = \"Optional\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Reference\"] = 1024] = \"Reference\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Identifier\"] = 2048] = \"Identifier\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Late\"] = 4096] = \"Late\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Refinement\"] = 8192] = \"Refinement\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Union\"] = 16384] = \"Union\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Null\"] = 32768] = \"Null\";\n\t    TypeFlags$$1[TypeFlags$$1[\"Undefined\"] = 65536] = \"Undefined\";\n\t})(TypeFlags$$1 || (TypeFlags$$1 = {}));\n\t/*\n\t * A complex type produces a MST node (Node in the state tree)\n\t */\n\tvar ComplexType$$1 = /** @class */ (function () {\n\t    function ComplexType$$1(name) {\n\t        this.isType = true;\n\t        this.name = name;\n\t    }\n\t    ComplexType$$1.prototype.create = function (snapshot, environment) {\n\t        if (snapshot === void 0) { snapshot = this.getDefaultSnapshot(); }\n\t        typecheck$$1(this, snapshot);\n\t        return this.instantiate(null, \"\", environment, snapshot).value;\n\t    };\n\t    ComplexType$$1.prototype.isAssignableFrom = function (type) {\n\t        return type === this;\n\t    };\n\t    ComplexType$$1.prototype.validate = function (value, context) {\n\t        if (isStateTreeNode$$1(value)) {\n\t            return getType$$1(value) === this || this.isAssignableFrom(getType$$1(value))\n\t                ? typeCheckSuccess$$1()\n\t                : typeCheckFailure$$1(context, value);\n\t            // it is tempting to compare snapshots, but in that case we should always clone on assignments...\n\t        }\n\t        return this.isValidSnapshot(value, context);\n\t    };\n\t    ComplexType$$1.prototype.is = function (value) {\n\t        return this.validate(value, [{ path: \"\", type: this }]).length === 0;\n\t    };\n\t    ComplexType$$1.prototype.reconcile = function (current, newValue) {\n\t        if (current.snapshot === newValue)\n\t            // newValue is the current snapshot of the node, noop\n\t            return current;\n\t        if (isStateTreeNode$$1(newValue) && getStateTreeNode$$1(newValue) === current)\n\t            // the current node is the same as the new one\n\t            return current;\n\t        if (current.type === this &&\n\t            isMutable(newValue) &&\n\t            !isStateTreeNode$$1(newValue) &&\n\t            (!current.identifierAttribute ||\n\t                current.identifier === newValue[current.identifierAttribute])) {\n\t            // the newValue has no node, so can be treated like a snapshot\n\t            // we can reconcile\n\t            current.applySnapshot(newValue);\n\t            return current;\n\t        }\n\t        // current node cannot be recycled in any way\n\t        var parent = current.parent, subpath = current.subpath;\n\t        current.die();\n\t        // attempt to reuse the new one\n\t        if (isStateTreeNode$$1(newValue) && this.isAssignableFrom(getType$$1(newValue))) {\n\t            // newValue is a Node as well, move it here..\n\t            var newNode = getStateTreeNode$$1(newValue);\n\t            newNode.setParent(parent, subpath);\n\t            return newNode;\n\t        }\n\t        // nothing to do, we have to create a new node\n\t        return this.instantiate(parent, subpath, current._environment, newValue);\n\t    };\n\t    Object.defineProperty(ComplexType$$1.prototype, \"Type\", {\n\t        get: function () {\n\t            return fail(\"Factory.Type should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.Type`\");\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(ComplexType$$1.prototype, \"SnapshotType\", {\n\t        get: function () {\n\t            return fail(\"Factory.SnapshotType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.SnapshotType`\");\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    __decorate([\n\t        mobx.action\n\t    ], ComplexType$$1.prototype, \"create\", null);\n\t    return ComplexType$$1;\n\t}());\n\tvar Type$$1 = /** @class */ (function (_super) {\n\t    __extends(Type$$1, _super);\n\t    function Type$$1(name) {\n\t        return _super.call(this, name) || this;\n\t    }\n\t    Type$$1.prototype.getValue = function (node) {\n\t        return node.storedValue;\n\t    };\n\t    Type$$1.prototype.getSnapshot = function (node) {\n\t        return node.storedValue;\n\t    };\n\t    Type$$1.prototype.getDefaultSnapshot = function () {\n\t        return undefined;\n\t    };\n\t    Type$$1.prototype.applySnapshot = function (node, snapshot) {\n\t        fail(\"Immutable types do not support applying snapshots\");\n\t    };\n\t    Type$$1.prototype.applyPatchLocally = function (node, subpath, patch) {\n\t        fail(\"Immutable types do not support applying patches\");\n\t    };\n\t    Type$$1.prototype.getChildren = function (node) {\n\t        return EMPTY_ARRAY;\n\t    };\n\t    Type$$1.prototype.getChildNode = function (node, key) {\n\t        return fail(\"No child '\" + key + \"' available in type: \" + this.name);\n\t    };\n\t    Type$$1.prototype.getChildType = function (key) {\n\t        return fail(\"No child '\" + key + \"' available in type: \" + this.name);\n\t    };\n\t    Type$$1.prototype.reconcile = function (current, newValue) {\n\t        // reconcile only if type and value are still the same\n\t        if (current.type === this && current.storedValue === newValue)\n\t            return current;\n\t        var res = this.instantiate(current.parent, current.subpath, current._environment, newValue);\n\t        current.die();\n\t        return res;\n\t    };\n\t    Type$$1.prototype.removeChild = function (node, subpath) {\n\t        return fail(\"No child '\" + subpath + \"' available in type: \" + this.name);\n\t    };\n\t    return Type$$1;\n\t}(ComplexType$$1));\n\tfunction isType$$1(value) {\n\t    return typeof value === \"object\" && value && value.isType === true;\n\t}\n\t\n\t/**\n\t * Convenience utility to create action based middleware that supports async processes more easily.\n\t * All hooks are called for both synchronous and asynchronous actions. Except that either `onSuccess` or `onFail` is called\n\t *\n\t * The create middleware tracks the process of an action (assuming it passes the `filter`).\n\t * `onResume` can return any value, which will be passed as second argument to any other hook. This makes it possible to keep state during a process.\n\t *\n\t * See the `atomic` middleware for an example\n\t *\n\t * @export\n\t * @template T\n\t * @template any\n\t * @param {{\n\t *     filter?: (call: IMiddlewareEvent) => boolean\n\t *     onStart: (call: IMiddlewareEvent) => T\n\t *     onResume: (call: IMiddlewareEvent, context: T) => void\n\t *     onSuspend: (call: IMiddlewareEvent, context: T) => void\n\t *     onSuccess: (call: IMiddlewareEvent, context: T, result: any) => void\n\t *     onFail: (call: IMiddlewareEvent, context: T, error: any) => void\n\t * }} hooks\n\t * @returns {IMiddlewareHandler}\n\t */\n\tfunction createActionTrackingMiddleware(hooks) {\n\t    var runningActions = new Map();\n\t    return function actionTrackingMiddleware(call, next) {\n\t        switch (call.type) {\n\t            case \"action\": {\n\t                if (!hooks.filter || hooks.filter(call) === true) {\n\t                    var context = hooks.onStart(call);\n\t                    hooks.onResume(call, context);\n\t                    runningActions.set(call.id, {\n\t                        call: call,\n\t                        context: context,\n\t                        async: false\n\t                    });\n\t                    try {\n\t                        var res = next(call);\n\t                        hooks.onSuspend(call, context);\n\t                        if (runningActions.get(call.id).async === false) {\n\t                            hooks.onSuccess(call, context, res);\n\t                        }\n\t                        return res;\n\t                    }\n\t                    catch (e) {\n\t                        hooks.onFail(call, context, e);\n\t                        throw e;\n\t                    }\n\t                }\n\t                else {\n\t                    return next(call);\n\t                }\n\t            }\n\t            case \"flow_spawn\": {\n\t                var root = runningActions.get(call.rootId);\n\t                root.async = true;\n\t                return next(call);\n\t            }\n\t            case \"flow_resume\":\n\t            case \"flow_resume_error\": {\n\t                var root = runningActions.get(call.rootId);\n\t                hooks.onResume(call, root.context);\n\t                try {\n\t                    return next(call);\n\t                }\n\t                finally {\n\t                    hooks.onSuspend(call, root.context);\n\t                }\n\t            }\n\t            case \"flow_throw\": {\n\t                var root = runningActions.get(call.rootId);\n\t                runningActions.delete(call.id);\n\t                hooks.onFail(call, root.context, call.args[0]);\n\t                return next(call);\n\t            }\n\t            case \"flow_return\": {\n\t                var root = runningActions.get(call.rootId);\n\t                runningActions.delete(call.id);\n\t                hooks.onSuccess(call, root.context, call.args[0]);\n\t                return next(call);\n\t            }\n\t        }\n\t    };\n\t}\n\t\n\tfunction serializeArgument(node, actionName, index, arg) {\n\t    if (arg instanceof Date)\n\t        return { $MST_DATE: arg.getTime() };\n\t    if (isPrimitive(arg))\n\t        return arg;\n\t    // We should not serialize MST nodes, even if we can, because we don't know if the receiving party can handle a raw snapshot instead of an\n\t    // MST type instance. So if one wants to serialize a MST node that was pass in, either explitly pass: 1: an id, 2: a (relative) path, 3: a snapshot\n\t    if (isStateTreeNode$$1(arg))\n\t        return serializeTheUnserializable(\"[MSTNode: \" + getType$$1(arg).name + \"]\");\n\t    if (typeof arg === \"function\")\n\t        return serializeTheUnserializable(\"[function]\");\n\t    if (typeof arg === \"object\" && !isPlainObject(arg) && !isArray(arg))\n\t        return serializeTheUnserializable(\"[object \" + ((arg && arg.constructor && arg.constructor.name) || \"Complex Object\") + \"]\");\n\t    try {\n\t        // Check if serializable, cycle free etc...\n\t        // MWE: there must be a better way....\n\t        JSON.stringify(arg); // or throws\n\t        return arg;\n\t    }\n\t    catch (e) {\n\t        return serializeTheUnserializable(\"\" + e);\n\t    }\n\t}\n\tfunction deserializeArgument(adm, value) {\n\t    if (value && typeof value === \"object\" && \"$MST_DATE\" in value)\n\t        return new Date(value[\"$MST_DATE\"]);\n\t    return value;\n\t}\n\tfunction serializeTheUnserializable(baseType) {\n\t    return {\n\t        $MST_UNSERIALIZABLE: true,\n\t        type: baseType\n\t    };\n\t}\n\t/**\n\t * Applies an action or a series of actions in a single MobX transaction.\n\t * Does not return any value\n\t * Takes an action description as produced by the `onAction` middleware.\n\t *\n\t * @export\n\t * @param {Object} target\n\t * @param {IActionCall[]} actions\n\t * @param {IActionCallOptions} [options]\n\t */\n\tfunction applyAction$$1(target, actions) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (typeof actions !== \"object\")\n\t            fail(\"expected second argument to be an object or array, got \" + actions + \" instead\");\n\t    }\n\t    mobx.runInAction(function () {\n\t        asArray(actions).forEach(function (action$$1) { return baseApplyAction(target, action$$1); });\n\t    });\n\t}\n\tfunction baseApplyAction(target, action$$1) {\n\t    var resolvedTarget = tryResolve$$1(target, action$$1.path || \"\");\n\t    if (!resolvedTarget)\n\t        return fail(\"Invalid action path: \" + (action$$1.path || \"\"));\n\t    var node = getStateTreeNode$$1(resolvedTarget);\n\t    // Reserved functions\n\t    if (action$$1.name === \"@APPLY_PATCHES\") {\n\t        return applyPatch$$1.call(null, resolvedTarget, action$$1.args[0]);\n\t    }\n\t    if (action$$1.name === \"@APPLY_SNAPSHOT\") {\n\t        return applySnapshot$$1.call(null, resolvedTarget, action$$1.args[0]);\n\t    }\n\t    if (!(typeof resolvedTarget[action$$1.name] === \"function\"))\n\t        fail(\"Action '\" + action$$1.name + \"' does not exist in '\" + node.path + \"'\");\n\t    return resolvedTarget[action$$1.name].apply(resolvedTarget, action$$1.args ? action$$1.args.map(function (v) { return deserializeArgument(node, v); }) : []);\n\t}\n\t/**\n\t * Small abstraction around `onAction` and `applyAction`, attaches an action listener to a tree and records all the actions emitted.\n\t * Returns an recorder object with the following signature:\n\t *\n\t * @example\n\t * export interface IActionRecorder {\n\t *      // the recorded actions\n\t *      actions: ISerializedActionCall[]\n\t *      // stop recording actions\n\t *      stop(): any\n\t *      // apply all the recorded actions on the given object\n\t *      replay(target: IStateTreeNode): any\n\t * }\n\t *\n\t * @export\n\t * @param {IStateTreeNode} subject\n\t * @returns {IPatchRecorder}\n\t */\n\tfunction recordActions$$1(subject) {\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(subject))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + subject + \" instead\");\n\t    }\n\t    var recorder = {\n\t        actions: [],\n\t        stop: function () { return disposer(); },\n\t        replay: function (target) {\n\t            applyAction$$1(target, recorder.actions);\n\t        }\n\t    };\n\t    var disposer = onAction$$1(subject, recorder.actions.push.bind(recorder.actions));\n\t    return recorder;\n\t}\n\t/**\n\t * Registers a function that will be invoked for each action that is called on the provided model instance, or to any of its children.\n\t * See [actions](https://github.com/mobxjs/mobx-state-tree#actions) for more details. onAction events are emitted only for the outermost called action in the stack.\n\t * Action can also be intercepted by middleware using addMiddleware to change the function call before it will be run.\n\t *\n\t * Not all action arguments might be serializable. For unserializable arguments, a struct like `{ $MST_UNSERIALIZABLE: true, type: \"someType\" }` will be generated.\n\t * MST Nodes are considered non-serializable as well (they could be serialized as there snapshot, but it is uncertain whether an replaying party will be able to handle such a non-instantiated snapshot).\n\t * Rather, when using `onAction` middleware, one should consider in passing arguments which are 1: an id, 2: a (relative) path, or 3: a snapshot. Instead of a real MST node.\n\t *\n\t * @example\n\t * const Todo = types.model({\n\t *   task: types.string\n\t * })\n\t *\n\t * const TodoStore = types.model({\n\t *   todos: types.array(Todo)\n\t * }).actions(self => ({\n\t *   add(todo) {\n\t *     self.todos.push(todo);\n\t *   }\n\t * }))\n\t *\n\t * const s = TodoStore.create({ todos: [] })\n\t *\n\t * let disposer = onAction(s, (call) => {\n\t *   console.log(call);\n\t * })\n\t *\n\t * s.add({ task: \"Grab a coffee\" })\n\t * // Logs: { name: \"add\", path: \"\", args: [{ task: \"Grab a coffee\" }] }\n\t *\n\t * @export\n\t * @param {IStateTreeNode} target\n\t * @param {(call: ISerializedActionCall) => void} listener\n\t * @param attachAfter {boolean} (default false) fires the listener *after* the action has executed instead of before.\n\t * @returns {IDisposer}\n\t */\n\tfunction onAction$$1(target, listener, attachAfter) {\n\t    if (attachAfter === void 0) { attachAfter = false; }\n\t    // check all arguments\n\t    if (false) {\n\t        if (!isStateTreeNode$$1(target))\n\t            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n\t        if (!isRoot$$1(target))\n\t            console.warn(\"[mobx-state-tree] Warning: Attaching onAction listeners to non root nodes is dangerous: No events will be emitted for actions initiated higher up in the tree.\");\n\t        if (!isProtected$$1(target))\n\t            console.warn(\"[mobx-state-tree] Warning: Attaching onAction listeners to non protected nodes is dangerous: No events will be emitted for direct modifications without action.\");\n\t    }\n\t    function fireListener(rawCall) {\n\t        if (rawCall.type === \"action\" && rawCall.id === rawCall.rootId) {\n\t            var sourceNode_1 = getStateTreeNode$$1(rawCall.context);\n\t            listener({\n\t                name: rawCall.name,\n\t                path: getRelativePathBetweenNodes$$1(getStateTreeNode$$1(target), sourceNode_1),\n\t                args: rawCall.args.map(function (arg, index) {\n\t                    return serializeArgument(sourceNode_1, rawCall.name, index, arg);\n\t                })\n\t            });\n\t        }\n\t    }\n\t    return addMiddleware$$1(target, attachAfter\n\t        ? function onActionMiddleware(rawCall, next) {\n\t            var res = next(rawCall);\n\t            fireListener(rawCall);\n\t            return res;\n\t        }\n\t        : function onActionMiddleware(rawCall, next) {\n\t            fireListener(rawCall);\n\t            return next(rawCall);\n\t        });\n\t}\n\t\n\tvar nextActionId = 1;\n\tvar currentActionContext = null;\n\tfunction getNextActionId$$1() {\n\t    return nextActionId++;\n\t}\n\tfunction runWithActionContext$$1(context, fn) {\n\t    var node = getStateTreeNode$$1(context.context);\n\t    var baseIsRunningAction = node._isRunningAction;\n\t    var prevContext = currentActionContext;\n\t    node.assertAlive();\n\t    node._isRunningAction = true;\n\t    currentActionContext = context;\n\t    try {\n\t        return runMiddleWares(node, context, fn);\n\t    }\n\t    finally {\n\t        currentActionContext = prevContext;\n\t        node._isRunningAction = baseIsRunningAction;\n\t    }\n\t}\n\tfunction getActionContext$$1() {\n\t    if (!currentActionContext)\n\t        return fail(\"Not running an action!\");\n\t    return currentActionContext;\n\t}\n\tfunction createActionInvoker$$1(target, name, fn) {\n\t    return function () {\n\t        var id = getNextActionId$$1();\n\t        return runWithActionContext$$1({\n\t            type: \"action\",\n\t            name: name,\n\t            id: id,\n\t            args: argsToArray(arguments),\n\t            context: target,\n\t            tree: getRoot$$1(target),\n\t            rootId: currentActionContext ? currentActionContext.rootId : id,\n\t            parentId: currentActionContext ? currentActionContext.id : 0\n\t        }, fn);\n\t    };\n\t}\n\t/**\n\t * Middleware can be used to intercept any action is invoked on the subtree where it is attached.\n\t * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.\n\t *\n\t * For more details, see the [middleware docs](docs/middleware.md)\n\t *\n\t * @export\n\t * @param {IStateTreeNode} target\n\t * @param {(action: IRawActionCall, next: (call: IRawActionCall) => any) => any} middleware\n\t * @returns {IDisposer}\n\t */\n\tfunction addMiddleware$$1(target, middleware) {\n\t    var node = getStateTreeNode$$1(target);\n\t    if (false) {\n\t        if (!node.isProtectionEnabled)\n\t            console.warn(\"It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`\");\n\t    }\n\t    return node.addMiddleWare(middleware);\n\t}\n\t/**\n\t * Binds middleware to a specific action\n\t *\n\t * @example\n\t * type.actions(self => {\n\t *   function takeA____() {\n\t *       self.toilet.donate()\n\t *       self.wipe()\n\t *       self.wipe()\n\t *       self.toilet.flush()\n\t *   }\n\t *   return {\n\t *     takeA____: decorate(atomic, takeA____)\n\t *   }\n\t * })\n\t *\n\t * @export\n\t * @template T\n\t * @param {IMiddlewareHandler} middleware\n\t * @param Function} fn\n\t * @returns the original function\n\t */\n\tfunction decorate$$1(middleware, fn) {\n\t    if (fn.$mst_middleware)\n\t        fn.$mst_middleware.push(middleware);\n\t    else\n\t        fn.$mst_middleware = [middleware];\n\t    return fn;\n\t}\n\tfunction collectMiddlewareHandlers(node, baseCall, fn) {\n\t    var handlers = fn.$mst_middleware || EMPTY_ARRAY;\n\t    var n = node;\n\t    // Find all middlewares. Optimization: cache this?\n\t    while (n) {\n\t        if (n.middlewares)\n\t            handlers = handlers.concat(n.middlewares);\n\t        n = n.parent;\n\t    }\n\t    return handlers;\n\t}\n\tfunction runMiddleWares(node, baseCall, originalFn) {\n\t    var handlers = collectMiddlewareHandlers(node, baseCall, originalFn);\n\t    // Short circuit\n\t    if (!handlers.length)\n\t        return mobx.action(originalFn).apply(null, baseCall.args);\n\t    var index = 0;\n\t    function runNextMiddleware(call) {\n\t        var handler = handlers[index++];\n\t        if (handler)\n\t            return handler(call, runNextMiddleware);\n\t        else\n\t            return mobx.action(originalFn).apply(null, baseCall.args);\n\t    }\n\t    return runNextMiddleware(baseCall);\n\t}\n\t\n\tfunction safeStringify(value) {\n\t    try {\n\t        return JSON.stringify(value);\n\t    }\n\t    catch (e) {\n\t        return \"<Unserializable: \" + e + \">\";\n\t    }\n\t}\n\tfunction prettyPrintValue$$1(value) {\n\t    return typeof value === \"function\"\n\t        ? \"<function\" + (value.name ? \" \" + value.name : \"\") + \">\"\n\t        : isStateTreeNode$$1(value) ? \"<\" + value + \">\" : \"`\" + safeStringify(value) + \"`\";\n\t}\n\tfunction toErrorString(error) {\n\t    var value = error.value;\n\t    var type = error.context[error.context.length - 1].type;\n\t    var fullPath = error.context\n\t        .map(function (_a) {\n\t        var path = _a.path;\n\t        return path;\n\t    })\n\t        .filter(function (path) { return path.length > 0; })\n\t        .join(\"/\");\n\t    var pathPrefix = fullPath.length > 0 ? \"at path \\\"/\" + fullPath + \"\\\" \" : \"\";\n\t    var currentTypename = isStateTreeNode$$1(value)\n\t        ? \"value of type \" + getStateTreeNode$$1(value).type.name + \":\"\n\t        : isPrimitive(value) ? \"value\" : \"snapshot\";\n\t    var isSnapshotCompatible = type && isStateTreeNode$$1(value) && type.is(getStateTreeNode$$1(value).snapshot);\n\t    return (\"\" + pathPrefix + currentTypename + \" \" + prettyPrintValue$$1(value) + \" is not assignable \" + (type\n\t        ? \"to type: `\" + type.name + \"`\"\n\t        : \"\") +\n\t        (error.message ? \" (\" + error.message + \")\" : \"\") +\n\t        (type\n\t            ? isPrimitiveType$$1(type)\n\t                ? \".\"\n\t                : \", expected an instance of `\" + type.name + \"` or a snapshot like `\" + type.describe() + \"` instead.\" +\n\t                    (isSnapshotCompatible\n\t                        ? \" (Note that a snapshot of the provided value is compatible with the targeted type)\"\n\t                        : \"\")\n\t            : \".\"));\n\t}\n\t\n\tfunction getContextForPath$$1(context, path, type) {\n\t    return context.concat([{ path: path, type: type }]);\n\t}\n\tfunction typeCheckSuccess$$1() {\n\t    return EMPTY_ARRAY;\n\t}\n\tfunction typeCheckFailure$$1(context, value, message) {\n\t    return [{ context: context, value: value, message: message }];\n\t}\n\tfunction flattenTypeErrors$$1(errors) {\n\t    return errors.reduce(function (a, i) { return a.concat(i); }, []);\n\t}\n\t// TODO; doublecheck: typecheck should only needed to be invoked from: type.create and array / map / value.property will change\n\tfunction typecheck$$1(type, value) {\n\t    // if not in dev-mode, do not even try to run typecheck. Everything is developer fault!\n\t    if (true)\n\t        return;\n\t    typecheckPublic$$1(type, value);\n\t}\n\t/**\n\t * Run's the typechecker on the given type.\n\t * Throws if the given value is not according the provided type specification.\n\t * Use this if you need typechecks even in a production build (by default all automatic runtime type checks will be skipped in production builds)\n\t *\n\t * @alias typecheck\n\t * @export\n\t * @param {IType<any, any>} type\n\t * @param {*} value\n\t */\n\tfunction typecheckPublic$$1(type, value) {\n\t    var errors = type.validate(value, [{ path: \"\", type: type }]);\n\t    if (errors.length > 0) {\n\t        fail(\"Error while converting \" + prettyPrintValue$$1(value) + \" to `\" + type.name + \"`:\\n\" +\n\t            errors.map(toErrorString).join(\"\\n\"));\n\t    }\n\t}\n\t\n\tvar IdentifierCache$$1 = /** @class */ (function () {\n\t    function IdentifierCache$$1() {\n\t        this.cache = mobx.observable.map();\n\t    }\n\t    IdentifierCache$$1.prototype.addNodeToCache = function (node) {\n\t        if (node.identifierAttribute) {\n\t            var identifier$$1 = node.identifier;\n\t            if (!this.cache.has(identifier$$1)) {\n\t                this.cache.set(identifier$$1, mobx.observable.shallowArray());\n\t            }\n\t            var set = this.cache.get(identifier$$1);\n\t            if (set.indexOf(node) !== -1)\n\t                fail(\"Already registered\");\n\t            set.push(node);\n\t        }\n\t        return this;\n\t    };\n\t    IdentifierCache$$1.prototype.mergeCache = function (node) {\n\t        var _this = this;\n\t        node.identifierCache.cache.values().forEach(function (nodes) {\n\t            return nodes.forEach(function (child) {\n\t                _this.addNodeToCache(child);\n\t            });\n\t        });\n\t    };\n\t    IdentifierCache$$1.prototype.notifyDied = function (node) {\n\t        if (node.identifierAttribute) {\n\t            var set = this.cache.get(node.identifier);\n\t            if (set)\n\t                set.remove(node);\n\t        }\n\t    };\n\t    IdentifierCache$$1.prototype.splitCache = function (node) {\n\t        var res = new IdentifierCache$$1();\n\t        var basePath = node.path;\n\t        this.cache.values().forEach(function (nodes) {\n\t            for (var i = nodes.length - 1; i >= 0; i--) {\n\t                if (nodes[i].path.indexOf(basePath) === 0) {\n\t                    res.addNodeToCache(nodes[i]);\n\t                    nodes.splice(i, 1);\n\t                }\n\t            }\n\t        });\n\t        return res;\n\t    };\n\t    IdentifierCache$$1.prototype.resolve = function (type, identifier$$1) {\n\t        var set = this.cache.get(identifier$$1);\n\t        if (!set)\n\t            return null;\n\t        var matches = set.filter(function (candidate) { return type.isAssignableFrom(candidate.type); });\n\t        switch (matches.length) {\n\t            case 0:\n\t                return null;\n\t            case 1:\n\t                return matches[0];\n\t            default:\n\t                return fail(\"Cannot resolve a reference to type '\" + type.name + \"' with id: '\" + identifier$$1 + \"' unambigously, there are multiple candidates: \" + matches\n\t                    .map(function (n) { return n.path; })\n\t                    .join(\", \"));\n\t        }\n\t    };\n\t    return IdentifierCache$$1;\n\t}());\n\t\n\t// TODO: split into object and scalar node?\n\tfunction createNode$$1(type, parent, subpath, environment, initialValue, createNewInstance, finalizeNewInstance) {\n\t    if (createNewInstance === void 0) { createNewInstance = identity; }\n\t    if (finalizeNewInstance === void 0) { finalizeNewInstance = noop; }\n\t    if (isStateTreeNode$$1(initialValue)) {\n\t        var targetNode = initialValue.$treenode;\n\t        if (!targetNode.isRoot)\n\t            fail(\"Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '\" + (parent\n\t                ? parent.path\n\t                : \"\") + \"/\" + subpath + \"', but it lives already at '\" + targetNode.path + \"'\");\n\t        targetNode.setParent(parent, subpath);\n\t        return targetNode;\n\t    }\n\t    var storedValue = createNewInstance(initialValue);\n\t    if (type.shouldAttachNode) {\n\t        var node = new ObjectNode$$1(type, parent, subpath, environment, initialValue, storedValue, type.shouldAttachNode, finalizeNewInstance);\n\t        node.finalizeCreation();\n\t        return node;\n\t    }\n\t    return new ScalarNode$$1(type, parent, subpath, environment, initialValue, storedValue, type.shouldAttachNode, finalizeNewInstance);\n\t}\n\tfunction isNode$$1(value) {\n\t    return value instanceof ScalarNode$$1 || value instanceof ObjectNode$$1;\n\t}\n\t\n\tvar NodeLifeCycle$$1;\n\t(function (NodeLifeCycle$$1) {\n\t    NodeLifeCycle$$1[NodeLifeCycle$$1[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n\t    NodeLifeCycle$$1[NodeLifeCycle$$1[\"CREATED\"] = 1] = \"CREATED\";\n\t    NodeLifeCycle$$1[NodeLifeCycle$$1[\"FINALIZED\"] = 2] = \"FINALIZED\";\n\t    NodeLifeCycle$$1[NodeLifeCycle$$1[\"DETACHING\"] = 3] = \"DETACHING\";\n\t    NodeLifeCycle$$1[NodeLifeCycle$$1[\"DEAD\"] = 4] = \"DEAD\"; // no coming back from this one\n\t})(NodeLifeCycle$$1 || (NodeLifeCycle$$1 = {}));\n\t/**\n\t * Returns true if the given value is a node in a state tree.\n\t * More precisely, that is, if the value is an instance of a\n\t * `types.model`, `types.array` or `types.map`.\n\t *\n\t * @export\n\t * @param {*} value\n\t * @returns {value is IStateTreeNode}\n\t */\n\tfunction isStateTreeNode$$1(value) {\n\t    return !!(value && value.$treenode);\n\t}\n\tfunction getStateTreeNode$$1(value) {\n\t    if (isStateTreeNode$$1(value))\n\t        return value.$treenode;\n\t    else\n\t        return fail(\"Value \" + value + \" is no MST Node\");\n\t}\n\t\n\tfunction toJSON$$1() {\n\t    return getStateTreeNode$$1(this).snapshot;\n\t}\n\tvar doubleDot = function (_) { return \"..\"; };\n\tfunction getRelativePathBetweenNodes$$1(base, target) {\n\t    // PRE condition target is (a child of) base!\n\t    if (base.root !== target.root)\n\t        fail(\"Cannot calculate relative path: objects '\" + base + \"' and '\" + target + \"' are not part of the same object tree\");\n\t    var baseParts = splitJsonPath$$1(base.path);\n\t    var targetParts = splitJsonPath$$1(target.path);\n\t    var common = 0;\n\t    for (; common < baseParts.length; common++) {\n\t        if (baseParts[common] !== targetParts[common])\n\t            break;\n\t    }\n\t    // TODO: assert that no targetParts paths are \"..\", \".\" or \"\"!\n\t    return (baseParts\n\t        .slice(common)\n\t        .map(doubleDot)\n\t        .join(\"/\") + joinJsonPath$$1(targetParts.slice(common)));\n\t}\n\tfunction resolveNodeByPath$$1(base, path, failIfResolveFails) {\n\t    if (failIfResolveFails === void 0) { failIfResolveFails = true; }\n\t    return resolveNodeByPathParts$$1(base, splitJsonPath$$1(path), failIfResolveFails);\n\t}\n\tfunction resolveNodeByPathParts$$1(base, pathParts, failIfResolveFails) {\n\t    if (failIfResolveFails === void 0) { failIfResolveFails = true; }\n\t    // counter part of getRelativePath\n\t    // note that `../` is not part of the JSON pointer spec, which is actually a prefix format\n\t    // in json pointer: \"\" = current, \"/a\", attribute a, \"/\" is attribute \"\" etc...\n\t    // so we treat leading ../ apart...\n\t    var current = base;\n\t    for (var i = 0; i < pathParts.length; i++) {\n\t        if (pathParts[i] === \"\")\n\t            current = current.root;\n\t        else if (pathParts[i] === \"..\")\n\t            current = current.parent;\n\t        else if (pathParts[i] === \".\" || pathParts[i] === \"\")\n\t            // '/bla' or 'a//b' splits to empty strings\n\t            continue;\n\t        else if (current) {\n\t            if (current instanceof ObjectNode$$1)\n\t                current = current.getChildNode(pathParts[i]);\n\t            else\n\t                return fail(\"Illegal state\");\n\t            continue;\n\t        }\n\t        if (!current) {\n\t            if (failIfResolveFails)\n\t                return fail(\"Could not resolve '\" + pathParts[i] + \"' in '\" + joinJsonPath$$1(pathParts.slice(0, i - 1)) + \"', path of the patch does not resolve\");\n\t            else\n\t                return undefined;\n\t        }\n\t    }\n\t    return current;\n\t}\n\t\n\t// based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts\n\t/*\n\t    All contents of this file are deprecated.\n\t\n\t    The term `process` has been replaced with `flow` to avoid conflicts with the\n\t    global `process` object.\n\t\n\t    Refer to `flow.ts` for any further changes to this implementation.\n\t*/\n\tvar DEPRECATION_MESSAGE = \"See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information. \" +\n\t    \"Note that the middleware event types starting with `process` now start with `flow`.\";\n\t/**\n\t * @deprecated has been renamed to `flow()`.\n\t * See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information.\n\t * Note that the middleware event types starting with `process` now start with `flow`.\n\t *\n\t * @export\n\t * @alias process\n\t * @returns {Promise}\n\t */\n\tfunction process$1$$1(asyncAction) {\n\t    deprecated(\"process\", \"`process()` has been renamed to `flow()`. \" + DEPRECATION_MESSAGE);\n\t    return flow(asyncAction);\n\t}\n\t\n\tvar EMPTY_ARRAY = Object.freeze([]);\n\tvar EMPTY_OBJECT = Object.freeze({});\n\tfunction fail(message) {\n\t    if (message === void 0) { message = \"Illegal state\"; }\n\t    throw new Error(\"[mobx-state-tree] \" + message);\n\t}\n\tfunction identity(_) {\n\t    return _;\n\t}\n\t\n\tfunction noop() { }\n\tfunction isArray(val) {\n\t    return !!(Array.isArray(val) || mobx.isObservableArray(val));\n\t}\n\tfunction asArray(val) {\n\t    if (!val)\n\t        return EMPTY_ARRAY;\n\t    if (isArray(val))\n\t        return val;\n\t    return [val];\n\t}\n\tfunction extend(a) {\n\t    var b = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        b[_i - 1] = arguments[_i];\n\t    }\n\t    for (var i = 0; i < b.length; i++) {\n\t        var current = b[i];\n\t        for (var key in current)\n\t            a[key] = current[key];\n\t    }\n\t    return a;\n\t}\n\t\n\tfunction isPlainObject(value) {\n\t    if (value === null || typeof value !== \"object\")\n\t        return false;\n\t    var proto = Object.getPrototypeOf(value);\n\t    return proto === Object.prototype || proto === null;\n\t}\n\tfunction isMutable(value) {\n\t    return (value !== null &&\n\t        typeof value === \"object\" &&\n\t        !(value instanceof Date) &&\n\t        !(value instanceof RegExp));\n\t}\n\tfunction isPrimitive(value) {\n\t    if (value === null || value === undefined)\n\t        return true;\n\t    if (typeof value === \"string\" ||\n\t        typeof value === \"number\" ||\n\t        typeof value === \"boolean\" ||\n\t        value instanceof Date)\n\t        return true;\n\t    return false;\n\t}\n\tfunction freeze(value) {\n\t    return isPrimitive(value) ? value : Object.freeze(value);\n\t}\n\tfunction deepFreeze(value) {\n\t    freeze(value);\n\t    if (isPlainObject(value)) {\n\t        Object.keys(value).forEach(function (propKey) {\n\t            if (!isPrimitive(value[propKey]) &&\n\t                !Object.isFrozen(value[propKey])) {\n\t                deepFreeze(value[propKey]);\n\t            }\n\t        });\n\t    }\n\t    return value;\n\t}\n\tfunction isSerializable(value) {\n\t    return typeof value !== \"function\";\n\t}\n\tfunction addHiddenFinalProp(object, propName, value) {\n\t    Object.defineProperty(object, propName, {\n\t        enumerable: false,\n\t        writable: false,\n\t        configurable: true,\n\t        value: value\n\t    });\n\t}\n\t\n\tfunction addReadOnlyProp(object, propName, value) {\n\t    Object.defineProperty(object, propName, {\n\t        enumerable: true,\n\t        writable: false,\n\t        configurable: true,\n\t        value: value\n\t    });\n\t}\n\tfunction remove(collection, item) {\n\t    var idx = collection.indexOf(item);\n\t    if (idx !== -1)\n\t        collection.splice(idx, 1);\n\t}\n\tfunction registerEventHandler(handlers, handler) {\n\t    handlers.push(handler);\n\t    return function () {\n\t        remove(handlers, handler);\n\t    };\n\t}\n\t\n\tfunction argsToArray(args) {\n\t    var res = new Array(args.length);\n\t    for (var i = 0; i < args.length; i++)\n\t        res[i] = args[i];\n\t    return res;\n\t}\n\tvar deprecated = function () { };\n\tdeprecated = function (id, message) {\n\t    // skip if running production\n\t    if (true)\n\t        return;\n\t    // warn if hasn't been warned before\n\t    if (deprecated.ids && !deprecated.ids.hasOwnProperty(id)) {\n\t        console.warn(\"[mobx-state-tree] Deprecation warning: \" + message);\n\t    }\n\t    // mark as warned to avoid duplicate warn message\n\t    if (deprecated.ids)\n\t        deprecated.ids[id] = true;\n\t};\n\tdeprecated.ids = {};\n\t\n\t// based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts\n\t/**\n\t * See [asynchronous actions](https://github.com/mobxjs/mobx-state-tree/blob/master/docs/async-actions.md).\n\t *\n\t * @export\n\t * @alias flow\n\t * @returns {Promise}\n\t */\n\tfunction flow(asyncAction) {\n\t    return createFlowSpawner(asyncAction.name, asyncAction);\n\t}\n\tfunction createFlowSpawner(name, generator) {\n\t    var spawner = function flowSpawner() {\n\t        // Implementation based on https://github.com/tj/co/blob/master/index.js\n\t        var runId = getNextActionId$$1();\n\t        var baseContext = getActionContext$$1();\n\t        var args = arguments;\n\t        function wrap(fn, type, arg) {\n\t            fn.$mst_middleware = spawner.$mst_middleware; // pick up any middleware attached to the flow\n\t            runWithActionContext$$1({\n\t                name: name,\n\t                type: type,\n\t                id: runId,\n\t                args: [arg],\n\t                tree: baseContext.tree,\n\t                context: baseContext.context,\n\t                parentId: baseContext.id,\n\t                rootId: baseContext.rootId\n\t            }, fn);\n\t        }\n\t        return new Promise(function (resolve, reject) {\n\t            var gen;\n\t            var init = function asyncActionInit() {\n\t                gen = generator.apply(null, arguments);\n\t                onFulfilled(undefined); // kick off the flow\n\t            };\n\t            init.$mst_middleware = spawner.$mst_middleware;\n\t            runWithActionContext$$1({\n\t                name: name,\n\t                type: \"flow_spawn\",\n\t                id: runId,\n\t                args: argsToArray(args),\n\t                tree: baseContext.tree,\n\t                context: baseContext.context,\n\t                parentId: baseContext.id,\n\t                rootId: baseContext.rootId\n\t            }, init);\n\t            function onFulfilled(res) {\n\t                var ret;\n\t                try {\n\t                    // prettier-ignore\n\t                    wrap(function (r) { ret = gen.next(r); }, \"flow_resume\", res);\n\t                }\n\t                catch (e) {\n\t                    // prettier-ignore\n\t                    setImmediate(function () {\n\t                        wrap(function (r) { reject(e); }, \"flow_throw\", e);\n\t                    });\n\t                    return;\n\t                }\n\t                next(ret);\n\t                return;\n\t            }\n\t            function onRejected(err) {\n\t                var ret;\n\t                try {\n\t                    // prettier-ignore\n\t                    wrap(function (r) { ret = gen.throw(r); }, \"flow_resume_error\", err); // or yieldError?\n\t                }\n\t                catch (e) {\n\t                    // prettier-ignore\n\t                    setImmediate(function () {\n\t                        wrap(function (r) { reject(e); }, \"flow_throw\", e);\n\t                    });\n\t                    return;\n\t                }\n\t                next(ret);\n\t            }\n\t            function next(ret) {\n\t                if (ret.done) {\n\t                    // prettier-ignore\n\t                    setImmediate(function () {\n\t                        wrap(function (r) { resolve(r); }, \"flow_return\", ret.value);\n\t                    });\n\t                    return;\n\t                }\n\t                // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100\n\t                if (!ret.value || typeof ret.value.then !== \"function\")\n\t                    fail(\"Only promises can be yielded to `async`, got: \" + ret);\n\t                return ret.value.then(onFulfilled, onRejected);\n\t            }\n\t        });\n\t    };\n\t    return spawner;\n\t}\n\t\n\tfunction splitPatch$$1(patch) {\n\t    if (!(\"oldValue\" in patch))\n\t        fail(\"Patches without `oldValue` field cannot be inversed\");\n\t    return [stripPatch$$1(patch), invertPatch(patch)];\n\t}\n\tfunction stripPatch$$1(patch) {\n\t    // strips `oldvalue` information from the patch, so that it becomes a patch conform the json-patch spec\n\t    // this removes the ability to undo the patch\n\t    switch (patch.op) {\n\t        case \"add\":\n\t            return { op: \"add\", path: patch.path, value: patch.value };\n\t        case \"remove\":\n\t            return { op: \"remove\", path: patch.path };\n\t        case \"replace\":\n\t            return { op: \"replace\", path: patch.path, value: patch.value };\n\t    }\n\t}\n\tfunction invertPatch(patch) {\n\t    switch (patch.op) {\n\t        case \"add\":\n\t            return {\n\t                op: \"remove\",\n\t                path: patch.path\n\t            };\n\t        case \"remove\":\n\t            return {\n\t                op: \"add\",\n\t                path: patch.path,\n\t                value: patch.oldValue\n\t            };\n\t        case \"replace\":\n\t            return {\n\t                op: \"replace\",\n\t                path: patch.path,\n\t                value: patch.oldValue\n\t            };\n\t    }\n\t}\n\t/**\n\t * escape slashes and backslashes\n\t * http://tools.ietf.org/html/rfc6901\n\t */\n\tfunction escapeJsonPath$$1(str) {\n\t    return str.replace(/~/g, \"~1\").replace(/\\//g, \"~0\");\n\t}\n\t/**\n\t * unescape slashes and backslashes\n\t */\n\tfunction unescapeJsonPath$$1(str) {\n\t    return str.replace(/~0/g, \"/\").replace(/~1/g, \"~\");\n\t}\n\tfunction joinJsonPath$$1(path) {\n\t    // `/` refers to property with an empty name, while `` refers to root itself!\n\t    if (path.length === 0)\n\t        return \"\";\n\t    return \"/\" + path.map(escapeJsonPath$$1).join(\"/\");\n\t}\n\tfunction splitJsonPath$$1(path) {\n\t    // `/` refers to property with an empty name, while `` refers to root itself!\n\t    var parts = path.split(\"/\").map(unescapeJsonPath$$1);\n\t    // path '/a/b/c' -> a b c\n\t    // path '../../b/c -> .. .. b c\n\t    return parts[0] === \"\" ? parts.slice(1) : parts;\n\t}\n\t\n\tfunction mapToString$$1() {\n\t    return getStateTreeNode$$1(this) + \"(\" + this.size + \" items)\";\n\t}\n\tfunction put(value) {\n\t    if (!!!value)\n\t        fail(\"Map.put cannot be used to set empty values\");\n\t    var node;\n\t    if (isStateTreeNode$$1(value)) {\n\t        node = getStateTreeNode$$1(value);\n\t    }\n\t    else if (isMutable(value)) {\n\t        var targetType = getStateTreeNode$$1(this).type\n\t            .subType;\n\t        node = getStateTreeNode$$1(targetType.create(value));\n\t    }\n\t    else {\n\t        return fail(\"Map.put can only be used to store complex values\");\n\t    }\n\t    if (!node.identifierAttribute)\n\t        fail(\"Map.put can only be used to store complex values that have an identifier type attribute\");\n\t    this.set(node.identifier, node.value);\n\t    return this;\n\t}\n\tvar MapType$$1 = /** @class */ (function (_super) {\n\t    __extends(MapType$$1, _super);\n\t    function MapType$$1(name, subType) {\n\t        var _this = _super.call(this, name) || this;\n\t        _this.shouldAttachNode = true;\n\t        _this.flags = TypeFlags$$1.Map;\n\t        _this.createNewInstance = function () {\n\t            // const identifierAttr = getIdentifierAttribute(this.subType)\n\t            var map$$1 = mobx.observable.shallowMap();\n\t            addHiddenFinalProp(map$$1, \"put\", put);\n\t            addHiddenFinalProp(map$$1, \"toString\", mapToString$$1);\n\t            return map$$1;\n\t        };\n\t        _this.finalizeNewInstance = function (node, snapshot) {\n\t            var instance = node.storedValue;\n\t            mobx.extras.interceptReads(instance, node.unbox);\n\t            mobx.intercept(instance, function (c) { return _this.willChange(c); });\n\t            node.applySnapshot(snapshot);\n\t            mobx.observe(instance, _this.didChange);\n\t        };\n\t        _this.subType = subType;\n\t        return _this;\n\t    }\n\t    MapType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n\t        return createNode$$1(this, parent, subpath, environment, snapshot, this.createNewInstance, this.finalizeNewInstance);\n\t    };\n\t    MapType$$1.prototype.describe = function () {\n\t        return \"Map<string, \" + this.subType.describe() + \">\";\n\t    };\n\t    MapType$$1.prototype.getChildren = function (node) {\n\t        return node.storedValue.values();\n\t    };\n\t    MapType$$1.prototype.getChildNode = function (node, key) {\n\t        var childNode = node.storedValue.get(key);\n\t        if (!childNode)\n\t            fail(\"Not a child \" + key);\n\t        return childNode;\n\t    };\n\t    MapType$$1.prototype.willChange = function (change) {\n\t        var node = getStateTreeNode$$1(change.object);\n\t        node.assertWritable();\n\t        switch (change.type) {\n\t            case \"update\":\n\t                {\n\t                    var newValue = change.newValue;\n\t                    var oldValue = change.object.get(change.name);\n\t                    if (newValue === oldValue)\n\t                        return null;\n\t                    typecheck$$1(this.subType, newValue);\n\t                    change.newValue = this.subType.reconcile(node.getChildNode(change.name), change.newValue);\n\t                    this.verifyIdentifier(change.name, change.newValue);\n\t                }\n\t                break;\n\t            case \"add\":\n\t                {\n\t                    typecheck$$1(this.subType, change.newValue);\n\t                    change.newValue = this.subType.instantiate(node, change.name, undefined, change.newValue);\n\t                    this.verifyIdentifier(change.name, change.newValue);\n\t                }\n\t                break;\n\t        }\n\t        return change;\n\t    };\n\t    MapType$$1.prototype.verifyIdentifier = function (expected, node) {\n\t        if (node instanceof ObjectNode$$1) {\n\t            var identifier$$1 = node.identifier;\n\t            if (identifier$$1 !== null && \"\" + identifier$$1 !== \"\" + expected)\n\t                fail(\"A map of objects containing an identifier should always store the object under their own identifier. Trying to store key '\" + identifier$$1 + \"', but expected: '\" + expected + \"'\");\n\t        }\n\t    };\n\t    MapType$$1.prototype.getValue = function (node) {\n\t        return node.storedValue;\n\t    };\n\t    MapType$$1.prototype.getSnapshot = function (node) {\n\t        var res = {};\n\t        node.getChildren().forEach(function (childNode) {\n\t            res[childNode.subpath] = childNode.snapshot;\n\t        });\n\t        return res;\n\t    };\n\t    MapType$$1.prototype.didChange = function (change) {\n\t        var node = getStateTreeNode$$1(change.object);\n\t        switch (change.type) {\n\t            case \"update\":\n\t                return void node.emitPatch({\n\t                    op: \"replace\",\n\t                    path: escapeJsonPath$$1(change.name),\n\t                    value: change.newValue.snapshot,\n\t                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n\t                }, node);\n\t            case \"add\":\n\t                return void node.emitPatch({\n\t                    op: \"add\",\n\t                    path: escapeJsonPath$$1(change.name),\n\t                    value: change.newValue.snapshot,\n\t                    oldValue: undefined\n\t                }, node);\n\t            case \"delete\":\n\t                // a node got deleted, get the old snapshot and make the node die\n\t                var oldSnapshot = change.oldValue.snapshot;\n\t                change.oldValue.die();\n\t                // emit the patch\n\t                return void node.emitPatch({ op: \"remove\", path: escapeJsonPath$$1(change.name), oldValue: oldSnapshot }, node);\n\t        }\n\t    };\n\t    MapType$$1.prototype.applyPatchLocally = function (node, subpath, patch) {\n\t        var target = node.storedValue;\n\t        switch (patch.op) {\n\t            case \"add\":\n\t            case \"replace\":\n\t                target.set(subpath, patch.value);\n\t                break;\n\t            case \"remove\":\n\t                target.delete(subpath);\n\t                break;\n\t        }\n\t    };\n\t    MapType$$1.prototype.applySnapshot = function (node, snapshot) {\n\t        typecheck$$1(this, snapshot);\n\t        var target = node.storedValue;\n\t        var currentKeys = {};\n\t        target.keys().forEach(function (key) {\n\t            currentKeys[key] = false;\n\t        });\n\t        // Don't use target.replace, as it will throw all existing items first\n\t        Object.keys(snapshot).forEach(function (key) {\n\t            target.set(key, snapshot[key]);\n\t            currentKeys[key] = true;\n\t        });\n\t        Object.keys(currentKeys).forEach(function (key) {\n\t            if (currentKeys[key] === false)\n\t                target.delete(key);\n\t        });\n\t    };\n\t    MapType$$1.prototype.getChildType = function (key) {\n\t        return this.subType;\n\t    };\n\t    MapType$$1.prototype.isValidSnapshot = function (value, context) {\n\t        var _this = this;\n\t        if (!isPlainObject(value)) {\n\t            return typeCheckFailure$$1(context, value, \"Value is not a plain object\");\n\t        }\n\t        return flattenTypeErrors$$1(Object.keys(value).map(function (path) {\n\t            return _this.subType.validate(value[path], getContextForPath$$1(context, path, _this.subType));\n\t        }));\n\t    };\n\t    MapType$$1.prototype.getDefaultSnapshot = function () {\n\t        return {};\n\t    };\n\t    MapType$$1.prototype.removeChild = function (node, subpath) {\n\t        \n\t        node.storedValue.delete(subpath);\n\t    };\n\t    __decorate([\n\t        mobx.action\n\t    ], MapType$$1.prototype, \"applySnapshot\", null);\n\t    return MapType$$1;\n\t}(ComplexType$$1));\n\t/**\n\t * Creates a key based collection type who's children are all of a uniform declared type.\n\t * If the type stored in a map has an identifier, it is mandatory to store the child under that identifier in the map.\n\t *\n\t * This type will always produce [observable maps](https://mobx.js.org/refguide/map.html)\n\t *\n\t * @example\n\t * const Todo = types.model({\n\t *   id: types.identifier(types.number),\n\t *   task: types.string\n\t * })\n\t *\n\t * const TodoStore = types.model({\n\t *   todos: types.map(Todo)\n\t * })\n\t *\n\t * const s = TodoStore.create({ todos: {} })\n\t * unprotect(s)\n\t * s.todos.set(17, { task: \"Grab coffee\", id: 17 })\n\t * s.todos.put({ task: \"Grab cookie\", id: 18 }) // put will infer key from the identifier\n\t * console.log(s.todos.get(17).task) // prints: \"Grab coffee\"\n\t *\n\t * @export\n\t * @alias types.map\n\t * @param {IType<S, T>} subtype\n\t * @returns {IComplexType<S[], IObservableArray<T>>}\n\t */\n\tfunction map$$1(subtype) {\n\t    return new MapType$$1(\"map<string, \" + subtype.name + \">\", subtype);\n\t}\n\t\n\tfunction arrayToString$$1() {\n\t    return getStateTreeNode$$1(this) + \"(\" + this.length + \" items)\";\n\t}\n\tvar ArrayType$$1 = /** @class */ (function (_super) {\n\t    __extends(ArrayType$$1, _super);\n\t    function ArrayType$$1(name, subType) {\n\t        var _this = _super.call(this, name) || this;\n\t        _this.shouldAttachNode = true;\n\t        _this.flags = TypeFlags$$1.Array;\n\t        _this.createNewInstance = function () {\n\t            var array$$1 = mobx.observable.shallowArray();\n\t            addHiddenFinalProp(array$$1, \"toString\", arrayToString$$1);\n\t            return array$$1;\n\t        };\n\t        _this.finalizeNewInstance = function (node, snapshot) {\n\t            var instance = node.storedValue;\n\t            mobx.extras.getAdministration(instance).dehancer = node.unbox;\n\t            mobx.intercept(instance, function (change) { return _this.willChange(change); });\n\t            node.applySnapshot(snapshot);\n\t            mobx.observe(instance, _this.didChange);\n\t        };\n\t        _this.subType = subType;\n\t        return _this;\n\t    }\n\t    ArrayType$$1.prototype.describe = function () {\n\t        return this.subType.describe() + \"[]\";\n\t    };\n\t    ArrayType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n\t        return createNode$$1(this, parent, subpath, environment, snapshot, this.createNewInstance, this.finalizeNewInstance);\n\t    };\n\t    ArrayType$$1.prototype.getChildren = function (node) {\n\t        return node.storedValue.peek();\n\t    };\n\t    ArrayType$$1.prototype.getChildNode = function (node, key) {\n\t        var index = parseInt(key, 10);\n\t        if (index < node.storedValue.length)\n\t            return node.storedValue[index];\n\t        return fail(\"Not a child: \" + key);\n\t    };\n\t    ArrayType$$1.prototype.willChange = function (change) {\n\t        var node = getStateTreeNode$$1(change.object);\n\t        node.assertWritable();\n\t        var childNodes = node.getChildren();\n\t        switch (change.type) {\n\t            case \"update\":\n\t                if (change.newValue === change.object[change.index])\n\t                    return null;\n\t                change.newValue = reconcileArrayChildren(node, this.subType, [childNodes[change.index]], [change.newValue], [change.index])[0];\n\t                break;\n\t            case \"splice\":\n\t                var index_1 = change.index, removedCount = change.removedCount, added = change.added;\n\t                change.added = reconcileArrayChildren(node, this.subType, childNodes.slice(index_1, index_1 + removedCount), added, added.map(function (_, i) { return index_1 + i; }));\n\t                // update paths of remaining items\n\t                for (var i = index_1 + removedCount; i < childNodes.length; i++) {\n\t                    childNodes[i].setParent(node, \"\" + (i + added.length - removedCount));\n\t                }\n\t                break;\n\t        }\n\t        return change;\n\t    };\n\t    ArrayType$$1.prototype.getValue = function (node) {\n\t        return node.storedValue;\n\t    };\n\t    ArrayType$$1.prototype.getSnapshot = function (node) {\n\t        return node.getChildren().map(function (childNode) { return childNode.snapshot; });\n\t    };\n\t    ArrayType$$1.prototype.didChange = function (change) {\n\t        var node = getStateTreeNode$$1(change.object);\n\t        switch (change.type) {\n\t            case \"update\":\n\t                return void node.emitPatch({\n\t                    op: \"replace\",\n\t                    path: \"\" + change.index,\n\t                    value: change.newValue.snapshot,\n\t                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n\t                }, node);\n\t            case \"splice\":\n\t                for (var i = change.removedCount - 1; i >= 0; i--)\n\t                    node.emitPatch({\n\t                        op: \"remove\",\n\t                        path: \"\" + (change.index + i),\n\t                        oldValue: change.removed[i].snapshot\n\t                    }, node);\n\t                for (var i = 0; i < change.addedCount; i++)\n\t                    node.emitPatch({\n\t                        op: \"add\",\n\t                        path: \"\" + (change.index + i),\n\t                        value: node.getChildNode(\"\" + (change.index + i)).snapshot,\n\t                        oldValue: undefined\n\t                    }, node);\n\t                return;\n\t        }\n\t    };\n\t    ArrayType$$1.prototype.applyPatchLocally = function (node, subpath, patch) {\n\t        var target = node.storedValue;\n\t        var index = subpath === \"-\" ? target.length : parseInt(subpath);\n\t        switch (patch.op) {\n\t            case \"replace\":\n\t                target[index] = patch.value;\n\t                break;\n\t            case \"add\":\n\t                target.splice(index, 0, patch.value);\n\t                break;\n\t            case \"remove\":\n\t                target.splice(index, 1);\n\t                break;\n\t        }\n\t    };\n\t    ArrayType$$1.prototype.applySnapshot = function (node, snapshot) {\n\t        typecheck$$1(this, snapshot);\n\t        var target = node.storedValue;\n\t        target.replace(snapshot);\n\t    };\n\t    ArrayType$$1.prototype.getChildType = function (key) {\n\t        return this.subType;\n\t    };\n\t    ArrayType$$1.prototype.isValidSnapshot = function (value, context) {\n\t        var _this = this;\n\t        if (!isArray(value)) {\n\t            return typeCheckFailure$$1(context, value, \"Value is not an array\");\n\t        }\n\t        return flattenTypeErrors$$1(value.map(function (item, index) {\n\t            return _this.subType.validate(item, getContextForPath$$1(context, \"\" + index, _this.subType));\n\t        }));\n\t    };\n\t    ArrayType$$1.prototype.getDefaultSnapshot = function () {\n\t        return [];\n\t    };\n\t    ArrayType$$1.prototype.removeChild = function (node, subpath) {\n\t        node.storedValue.splice(parseInt(subpath, 10), 1);\n\t    };\n\t    __decorate([\n\t        mobx.action\n\t    ], ArrayType$$1.prototype, \"applySnapshot\", null);\n\t    return ArrayType$$1;\n\t}(ComplexType$$1));\n\t/**\n\t * Creates an index based collection type who's children are all of a uniform declared type.\n\t *\n\t * This type will always produce [observable arrays](https://mobx.js.org/refguide/array.html)\n\t *\n\t * @example\n\t * const Todo = types.model({\n\t *   task: types.string\n\t * })\n\t *\n\t * const TodoStore = types.model({\n\t *   todos: types.array(Todo)\n\t * })\n\t *\n\t * const s = TodoStore.create({ todos: [] })\n\t * unprotect(s) // needed to allow modifying outside of an action\n\t * s.todos.push({ task: \"Grab coffee\" })\n\t * console.log(s.todos[0]) // prints: \"Grab coffee\"\n\t *\n\t * @export\n\t * @alias types.array\n\t * @param {IType<S, T>} subtype\n\t * @returns {IComplexType<S[], IObservableArray<T>>}\n\t */\n\tfunction array$$1(subtype) {\n\t    if (false) {\n\t        if (!isType$$1(subtype))\n\t            fail(\"expected a mobx-state-tree type as first argument, got \" + subtype + \" instead\");\n\t    }\n\t    return new ArrayType$$1(subtype.name + \"[]\", subtype);\n\t}\n\tfunction reconcileArrayChildren(parent, childType, oldNodes, newValues, newPaths) {\n\t    var oldNode, newValue, hasNewNode = false, oldMatch = undefined;\n\t    for (var i = 0;; i++) {\n\t        hasNewNode = i <= newValues.length - 1;\n\t        oldNode = oldNodes[i];\n\t        newValue = hasNewNode ? newValues[i] : undefined;\n\t        // for some reason, instead of newValue we got a node, fallback to the storedValue\n\t        // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681\n\t        if (isNode$$1(newValue))\n\t            newValue = newValue.storedValue;\n\t        // both are empty, end\n\t        if (!oldNode && !hasNewNode) {\n\t            break;\n\t            // new one does not exists, old one dies\n\t        }\n\t        else if (!hasNewNode) {\n\t            oldNode.die();\n\t            oldNodes.splice(i, 1);\n\t            i--;\n\t            // there is no old node, create it\n\t        }\n\t        else if (!oldNode) {\n\t            // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.\n\t            if (isStateTreeNode$$1(newValue) && getStateTreeNode$$1(newValue).parent === parent) {\n\t                // this node is owned by this parent, but not in the reconcilable set, so it must be double\n\t                fail(\"Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '\" + parent.path + \"/\" + newPaths[i] + \"', but it lives already at '\" + getStateTreeNode$$1(newValue).path + \"'\");\n\t            }\n\t            oldNodes.splice(i, 0, valueAsNode(childType, parent, \"\" + newPaths[i], newValue));\n\t            // both are the same, reconcile\n\t        }\n\t        else if (areSame(oldNode, newValue)) {\n\t            oldNodes[i] = valueAsNode(childType, parent, \"\" + newPaths[i], newValue, oldNode);\n\t            // nothing to do, try to reorder\n\t        }\n\t        else {\n\t            oldMatch = undefined;\n\t            // find a possible candidate to reuse\n\t            for (var j = i; j < oldNodes.length; j++) {\n\t                if (areSame(oldNodes[j], newValue)) {\n\t                    oldMatch = oldNodes.splice(j, 1)[0];\n\t                    break;\n\t                }\n\t            }\n\t            oldNodes.splice(i, 0, valueAsNode(childType, parent, \"\" + newPaths[i], newValue, oldMatch));\n\t        }\n\t    }\n\t    return oldNodes;\n\t}\n\t// convert a value to a node at given parent and subpath. attempts to reuse old node if possible and given\n\tfunction valueAsNode(childType, parent, subpath, newValue, oldNode) {\n\t    // ensure the value is valid-ish\n\t    typecheck$$1(childType, newValue);\n\t    // the new value has a MST node\n\t    if (isStateTreeNode$$1(newValue)) {\n\t        var childNode_1 = getStateTreeNode$$1(newValue);\n\t        childNode_1.assertAlive();\n\t        // the node lives here\n\t        if (childNode_1.parent !== null && childNode_1.parent === parent) {\n\t            childNode_1.setParent(parent, subpath);\n\t            if (oldNode && oldNode !== childNode_1)\n\t                oldNode.die();\n\t            return childNode_1;\n\t        }\n\t    }\n\t    // there is old node and new one is a value/snapshot\n\t    if (oldNode) {\n\t        var childNode_2 = childType.reconcile(oldNode, newValue);\n\t        childNode_2.setParent(parent, subpath);\n\t        return childNode_2;\n\t    }\n\t    // nothing to do, create from scratch\n\t    var childNode = childType.instantiate(parent, subpath, parent._environment, newValue);\n\t    return childNode;\n\t}\n\t// given a value\n\tfunction areSame(oldNode, newValue) {\n\t    // the new value has the same node\n\t    if (isStateTreeNode$$1(newValue)) {\n\t        return getStateTreeNode$$1(newValue) === oldNode;\n\t    }\n\t    // the provided value is the snapshot of the old node\n\t    if (isMutable(newValue) && oldNode.snapshot === newValue)\n\t        return true;\n\t    // new value is a snapshot with the correct identifier\n\t    if (oldNode instanceof ObjectNode$$1 &&\n\t        oldNode.identifier !== null &&\n\t        oldNode.identifierAttribute &&\n\t        isPlainObject(newValue) &&\n\t        newValue[oldNode.identifierAttribute] === oldNode.identifier)\n\t        return true;\n\t    return false;\n\t}\n\t\n\tvar PRE_PROCESS_SNAPSHOT = \"preProcessSnapshot\";\n\tvar HOOK_NAMES = {\n\t    afterCreate: \"afterCreate\",\n\t    afterAttach: \"afterAttach\",\n\t    postProcessSnapshot: \"postProcessSnapshot\",\n\t    beforeDetach: \"beforeDetach\",\n\t    beforeDestroy: \"beforeDestroy\"\n\t};\n\tfunction objectTypeToString() {\n\t    return getStateTreeNode$$1(this).toString();\n\t}\n\tvar defaultObjectOptions = {\n\t    name: \"AnonymousModel\",\n\t    properties: {},\n\t    initializers: EMPTY_ARRAY\n\t};\n\tfunction toPropertiesObject(properties) {\n\t    // loop through properties and ensures that all items are types\n\t    return Object.keys(properties).reduce(function (properties, key) {\n\t        // warn if user intended a HOOK\n\t        if (key in HOOK_NAMES)\n\t            return fail(\"Hook '\" + key + \"' was defined as property. Hooks should be defined as part of the actions\");\n\t        // the user intended to use a view\n\t        var descriptor = Object.getOwnPropertyDescriptor(properties, key);\n\t        if (\"get\" in descriptor) {\n\t            fail(\"Getters are not supported as properties. Please use views instead\");\n\t        }\n\t        // undefined and null are not valid\n\t        var value = descriptor.value;\n\t        if (value === null || undefined) {\n\t            fail(\"The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?\");\n\t            // its a primitive, convert to its type\n\t        }\n\t        else if (isPrimitive(value)) {\n\t            return Object.assign({}, properties, (_a = {},\n\t                _a[key] = optional$$1(getPrimitiveFactoryFromValue$$1(value), value),\n\t                _a));\n\t            // its already a type\n\t        }\n\t        else if (isType$$1(value)) {\n\t            return properties;\n\t            // its a function, maybe the user wanted a view?\n\t        }\n\t        else if (typeof value === \"function\") {\n\t            fail(\"Functions are not supported as properties, use views instead\");\n\t            // no other complex values\n\t        }\n\t        else if (typeof value === \"object\") {\n\t            fail(\"In property '\" + key + \"': base model's should not contain complex values: '\" + value + \"'\");\n\t            // WTF did you passed in mate?\n\t        }\n\t        else {\n\t            fail(\"Unexpected value for property '\" + key + \"'\");\n\t        }\n\t        var _a;\n\t    }, properties);\n\t}\n\tvar ModelType$$1 = /** @class */ (function (_super) {\n\t    __extends(ModelType$$1, _super);\n\t    function ModelType$$1(opts) {\n\t        var _this = _super.call(this, opts.name || defaultObjectOptions.name) || this;\n\t        _this.flags = TypeFlags$$1.Object;\n\t        _this.shouldAttachNode = true;\n\t        _this.createNewInstance = function () {\n\t            var instance = mobx.observable.shallowObject(EMPTY_OBJECT);\n\t            addHiddenFinalProp(instance, \"toString\", objectTypeToString);\n\t            return instance;\n\t        };\n\t        _this.finalizeNewInstance = function (node, snapshot) {\n\t            var instance = node.storedValue;\n\t            _this.forAllProps(function (name, type) {\n\t                mobx.extendShallowObservable(instance, (_a = {},\n\t                    _a[name] = mobx.observable.ref(type.instantiate(node, name, node._environment, snapshot[name])),\n\t                    _a));\n\t                mobx.extras.interceptReads(instance, name, node.unbox);\n\t                var _a;\n\t            });\n\t            _this.initializers.reduce(function (self, fn) { return fn(self); }, instance);\n\t            mobx.intercept(instance, function (change) { return _this.willChange(change); });\n\t            mobx.observe(instance, _this.didChange);\n\t        };\n\t        _this.didChange = function (change) {\n\t            if (!_this.properties[change.name]) {\n\t                // don't emit patches for volatile state\n\t                return;\n\t            }\n\t            var node = getStateTreeNode$$1(change.object);\n\t            var oldValue = change.oldValue ? change.oldValue.snapshot : undefined;\n\t            node.emitPatch({\n\t                op: \"replace\",\n\t                path: escapeJsonPath$$1(change.name),\n\t                value: change.newValue.snapshot,\n\t                oldValue: oldValue\n\t            }, node);\n\t        };\n\t        var name = opts.name || defaultObjectOptions.name;\n\t        // TODO: this test still needed?\n\t        if (!/^\\w[\\w\\d_]*$/.test(name))\n\t            fail(\"Typename should be a valid identifier: \" + name);\n\t        Object.assign(_this, defaultObjectOptions, opts);\n\t        // ensures that any default value gets converted to its related type\n\t        _this.properties = toPropertiesObject(_this.properties);\n\t        _this.propertiesNames = Object.keys(_this.properties);\n\t        Object.freeze(_this.properties); // make sure nobody messes with it\n\t        return _this;\n\t    }\n\t    ModelType$$1.prototype.cloneAndEnhance = function (opts) {\n\t        return new ModelType$$1({\n\t            name: opts.name || this.name,\n\t            properties: Object.assign({}, this.properties, opts.properties),\n\t            initializers: this.initializers.concat(opts.initializers || []),\n\t            preProcessor: opts.preProcessor || this.preProcessor\n\t        });\n\t    };\n\t    ModelType$$1.prototype.actions = function (fn) {\n\t        var _this = this;\n\t        var actionInitializer = function (self) {\n\t            _this.instantiateActions(self, fn(self));\n\t            return self;\n\t        };\n\t        return this.cloneAndEnhance({ initializers: [actionInitializer] });\n\t    };\n\t    ModelType$$1.prototype.instantiateActions = function (self, actions) {\n\t        // check if return is correct\n\t        if (!isPlainObject(actions))\n\t            fail(\"actions initializer should return a plain object containing actions\");\n\t        // bind actions to the object created\n\t        Object.keys(actions).forEach(function (name) {\n\t            // warn if preprocessor was given\n\t            if (name === PRE_PROCESS_SNAPSHOT)\n\t                return fail(\"Cannot define action '\" + PRE_PROCESS_SNAPSHOT + \"', it should be defined using 'type.preProcessSnapshot(fn)' instead\");\n\t            // apply hook composition\n\t            var action$$1 = actions[name];\n\t            var baseAction = self[name];\n\t            if (name in HOOK_NAMES && baseAction) {\n\t                var specializedAction_1 = action$$1;\n\t                if (name === HOOK_NAMES.postProcessSnapshot)\n\t                    action$$1 = function (snapshot) { return specializedAction_1(baseAction(snapshot)); };\n\t                else\n\t                    action$$1 = function () {\n\t                        baseAction.apply(null, arguments);\n\t                        specializedAction_1.apply(null, arguments);\n\t                    };\n\t            }\n\t            addHiddenFinalProp(self, name, createActionInvoker$$1(self, name, action$$1));\n\t            return;\n\t        });\n\t    };\n\t    ModelType$$1.prototype.named = function (name) {\n\t        return this.cloneAndEnhance({ name: name });\n\t    };\n\t    ModelType$$1.prototype.props = function (properties) {\n\t        return this.cloneAndEnhance({ properties: properties });\n\t    };\n\t    ModelType$$1.prototype.volatile = function (fn) {\n\t        var _this = this;\n\t        var stateInitializer = function (self) {\n\t            _this.instantiateVolatileState(self, fn(self));\n\t            return self;\n\t        };\n\t        return this.cloneAndEnhance({ initializers: [stateInitializer] });\n\t    };\n\t    ModelType$$1.prototype.instantiateVolatileState = function (self, state) {\n\t        // check views return\n\t        if (!isPlainObject(state))\n\t            fail(\"state initializer should return a plain object containing views\");\n\t        // TODO: typecheck & namecheck members of state?\n\t        mobx.extendShallowObservable(self, state);\n\t    };\n\t    ModelType$$1.prototype.extend = function (fn) {\n\t        var _this = this;\n\t        var initializer = function (self) {\n\t            var _a = fn(self), actions = _a.actions, views = _a.views, state = _a.state, rest = __rest(_a, [\"actions\", \"views\", \"state\"]);\n\t            for (var key in rest)\n\t                fail(\"The `extend` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '\" + key + \"'\");\n\t            if (state)\n\t                _this.instantiateVolatileState(self, state);\n\t            if (views)\n\t                _this.instantiateViews(self, views);\n\t            if (actions)\n\t                _this.instantiateActions(self, actions);\n\t            return self;\n\t        };\n\t        return this.cloneAndEnhance({ initializers: [initializer] });\n\t    };\n\t    ModelType$$1.prototype.views = function (fn) {\n\t        var _this = this;\n\t        var viewInitializer = function (self) {\n\t            _this.instantiateViews(self, fn(self));\n\t            return self;\n\t        };\n\t        return this.cloneAndEnhance({ initializers: [viewInitializer] });\n\t    };\n\t    ModelType$$1.prototype.instantiateViews = function (self, views) {\n\t        // check views return\n\t        if (!isPlainObject(views))\n\t            fail(\"views initializer should return a plain object containing views\");\n\t        Object.keys(views).forEach(function (key) {\n\t            // is this a computed property?\n\t            var descriptor = Object.getOwnPropertyDescriptor(views, key);\n\t            var value = descriptor.value;\n\t            if (\"get\" in descriptor) {\n\t                // TODO: mobx currently does not allow redefining computes yet, pending #1121\n\t                if (mobx.isComputed(self.$mobx.values[key])) {\n\t                    // TODO: use `isComputed(self, key)`, pending mobx #1120\n\t                    \n\t                    self.$mobx.values[key] = mobx.computed(descriptor.get, {\n\t                        name: key,\n\t                        setter: descriptor.set,\n\t                        context: self\n\t                    });\n\t                }\n\t                else {\n\t                    var tmp = {};\n\t                    Object.defineProperty(tmp, key, {\n\t                        get: descriptor.get,\n\t                        set: descriptor.set,\n\t                        enumerable: true\n\t                    });\n\t                    mobx.extendShallowObservable(self, tmp);\n\t                }\n\t            }\n\t            else if (typeof value === \"function\") {\n\t                // this is a view function, merge as is!\n\t                addHiddenFinalProp(self, key, value);\n\t            }\n\t            else {\n\t                fail(\"A view member should either be a function or getter based property\");\n\t            }\n\t        });\n\t    };\n\t    ModelType$$1.prototype.preProcessSnapshot = function (preProcessor) {\n\t        var currentPreprocessor = this.preProcessor;\n\t        if (!currentPreprocessor)\n\t            return this.cloneAndEnhance({ preProcessor: preProcessor });\n\t        else\n\t            return this.cloneAndEnhance({\n\t                preProcessor: function (snapshot) { return currentPreprocessor(preProcessor(snapshot)); }\n\t            });\n\t    };\n\t    ModelType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n\t        return createNode$$1(this, parent, subpath, environment, this.applySnapshotPreProcessor(snapshot), this.createNewInstance, this.finalizeNewInstance);\n\t        // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class\n\t        // that pre-reserves all these fields for fast object-member lookups\n\t    };\n\t    ModelType$$1.prototype.willChange = function (change) {\n\t        var node = getStateTreeNode$$1(change.object);\n\t        node.assertWritable();\n\t        var type = this.properties[change.name];\n\t        // only properties are typed, state are stored as-is references\n\t        if (type) {\n\t            typecheck$$1(type, change.newValue);\n\t            change.newValue = type.reconcile(node.getChildNode(change.name), change.newValue);\n\t        }\n\t        return change;\n\t    };\n\t    ModelType$$1.prototype.getChildren = function (node) {\n\t        var _this = this;\n\t        var res = [];\n\t        this.forAllProps(function (name, type) {\n\t            res.push(_this.getChildNode(node, name));\n\t        });\n\t        return res;\n\t    };\n\t    ModelType$$1.prototype.getChildNode = function (node, key) {\n\t        if (!(key in this.properties))\n\t            return fail(\"Not a value property: \" + key);\n\t        var childNode = node.storedValue.$mobx.values[key].value; // TODO: blegh!\n\t        if (!childNode)\n\t            return fail(\"Node not available for property \" + key);\n\t        return childNode;\n\t    };\n\t    ModelType$$1.prototype.getValue = function (node) {\n\t        return node.storedValue;\n\t    };\n\t    ModelType$$1.prototype.getSnapshot = function (node) {\n\t        var _this = this;\n\t        var res = {};\n\t        this.forAllProps(function (name, type) {\n\t            // TODO: FIXME, make sure the observable ref is used!\n\t            \n\t            mobx.extras.getAtom(node.storedValue, name).reportObserved();\n\t            res[name] = _this.getChildNode(node, name).snapshot;\n\t        });\n\t        if (typeof node.storedValue.postProcessSnapshot === \"function\")\n\t            return node.storedValue.postProcessSnapshot.call(null, res);\n\t        return res;\n\t    };\n\t    ModelType$$1.prototype.applyPatchLocally = function (node, subpath, patch) {\n\t        if (!(patch.op === \"replace\" || patch.op === \"add\"))\n\t            fail(\"object does not support operation \" + patch.op);\n\t        node.storedValue[subpath] = patch.value;\n\t    };\n\t    ModelType$$1.prototype.applySnapshot = function (node, snapshot) {\n\t        var s = this.applySnapshotPreProcessor(snapshot);\n\t        typecheck$$1(this, s);\n\t        this.forAllProps(function (name, type) {\n\t            node.storedValue[name] = s[name];\n\t        });\n\t    };\n\t    ModelType$$1.prototype.applySnapshotPreProcessor = function (snapshot) {\n\t        if (this.preProcessor)\n\t            return this.preProcessor.call(null, snapshot);\n\t        return snapshot;\n\t    };\n\t    ModelType$$1.prototype.getChildType = function (key) {\n\t        return this.properties[key];\n\t    };\n\t    ModelType$$1.prototype.isValidSnapshot = function (value, context) {\n\t        var _this = this;\n\t        var snapshot = this.applySnapshotPreProcessor(value);\n\t        if (!isPlainObject(snapshot)) {\n\t            return typeCheckFailure$$1(context, snapshot, \"Value is not a plain object\");\n\t        }\n\t        return flattenTypeErrors$$1(this.propertiesNames.map(function (key) {\n\t            return _this.properties[key].validate(snapshot[key], getContextForPath$$1(context, key, _this.properties[key]));\n\t        }));\n\t    };\n\t    ModelType$$1.prototype.forAllProps = function (fn) {\n\t        var _this = this;\n\t        this.propertiesNames.forEach(function (key) { return fn(key, _this.properties[key]); });\n\t    };\n\t    ModelType$$1.prototype.describe = function () {\n\t        var _this = this;\n\t        // optimization: cache\n\t        return (\"{ \" +\n\t            this.propertiesNames\n\t                .map(function (key) { return key + \": \" + _this.properties[key].describe(); })\n\t                .join(\"; \") +\n\t            \" }\");\n\t    };\n\t    ModelType$$1.prototype.getDefaultSnapshot = function () {\n\t        return {};\n\t    };\n\t    ModelType$$1.prototype.removeChild = function (node, subpath) {\n\t        node.storedValue[subpath] = null;\n\t    };\n\t    __decorate([\n\t        mobx.action\n\t    ], ModelType$$1.prototype, \"applySnapshot\", null);\n\t    return ModelType$$1;\n\t}(ComplexType$$1));\n\t/**\n\t * Creates a new model type by providing a name, properties, volatile state and actions.\n\t *\n\t * See the [model type](https://github.com/mobxjs/mobx-state-tree#creating-models) description or the [getting started](https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started-1) tutorial.\n\t *\n\t * @export\n\t * @alias types.model\n\t */\n\tfunction model$$1() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i] = arguments[_i];\n\t    }\n\t    var name = typeof args[0] === \"string\" ? args.shift() : \"AnonymousModel\";\n\t    var properties = args.shift() || {};\n\t    return new ModelType$$1({ name: name, properties: properties });\n\t}\n\t/**\n\t * Composes a new model from one or more existing model types.\n\t * This method can be invoked in two forms:\n\t * Given 2 or more model types, the types are composed into a new Type.\n\t *\n\t * @export\n\t * @alias types.compose\n\t */\n\tfunction compose$$1() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i] = arguments[_i];\n\t    }\n\t    // TODO: just join the base type names if no name is provided\n\t    var typeName = typeof args[0] === \"string\" ? args.shift() : \"AnonymousModel\";\n\t    // check all parameters\n\t    if (false) {\n\t        args.forEach(function (type) {\n\t            if (!isType$$1(type))\n\t                fail(\"expected a mobx-state-tree type, got \" + type + \" instead\");\n\t        });\n\t    }\n\t    return args\n\t        .reduce(function (prev, cur) {\n\t        return prev.cloneAndEnhance({\n\t            name: prev.name + \"_\" + cur.name,\n\t            properties: cur.properties,\n\t            initializers: cur.initializers\n\t        });\n\t    })\n\t        .named(typeName);\n\t}\n\t\n\tvar CoreType$$1 = /** @class */ (function (_super) {\n\t    __extends(CoreType$$1, _super);\n\t    function CoreType$$1(name, flags, checker, initializer) {\n\t        if (initializer === void 0) { initializer = identity; }\n\t        var _this = _super.call(this, name) || this;\n\t        _this.shouldAttachNode = false;\n\t        _this.flags = flags;\n\t        _this.checker = checker;\n\t        _this.initializer = initializer;\n\t        return _this;\n\t    }\n\t    CoreType$$1.prototype.describe = function () {\n\t        return this.name;\n\t    };\n\t    CoreType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n\t        return createNode$$1(this, parent, subpath, environment, snapshot, this.initializer);\n\t    };\n\t    CoreType$$1.prototype.isValidSnapshot = function (value, context) {\n\t        if (isPrimitive(value) && this.checker(value)) {\n\t            return typeCheckSuccess$$1();\n\t        }\n\t        var typeName = this.name === \"Date\" ? \"Date or a unix milliseconds timestamp\" : this.name;\n\t        return typeCheckFailure$$1(context, value, \"Value is not a \" + typeName);\n\t    };\n\t    return CoreType$$1;\n\t}(Type$$1));\n\t/**\n\t * Creates a type that can only contain a string value.\n\t * This type is used for string values by default\n\t *\n\t * @export\n\t * @alias types.string\n\t * @example\n\t * const Person = types.model({\n\t *   firstName: types.string,\n\t *   lastName: \"Doe\"\n\t * })\n\t */\n\t// tslint:disable-next-line:variable-name\n\tvar string$$1 = new CoreType$$1(\"string\", TypeFlags$$1.String, function (v) { return typeof v === \"string\"; });\n\t/**\n\t * Creates a type that can only contain a numeric value.\n\t * This type is used for numeric values by default\n\t *\n\t * @export\n\t * @alias types.number\n\t * @example\n\t * const Vector = types.model({\n\t *   x: types.number,\n\t *   y: 0\n\t * })\n\t */\n\t// tslint:disable-next-line:variable-name\n\tvar number$$1 = new CoreType$$1(\"number\", TypeFlags$$1.Number, function (v) { return typeof v === \"number\"; });\n\t/**\n\t * Creates a type that can only contain a boolean value.\n\t * This type is used for boolean values by default\n\t *\n\t * @export\n\t * @alias types.boolean\n\t * @example\n\t * const Thing = types.model({\n\t *   isCool: types.boolean,\n\t *   isAwesome: false\n\t * })\n\t */\n\t// tslint:disable-next-line:variable-name\n\tvar boolean$$1 = new CoreType$$1(\"boolean\", TypeFlags$$1.Boolean, function (v) { return typeof v === \"boolean\"; });\n\t/**\n\t * The type of the value `null`\n\t *\n\t * @export\n\t * @alias types.null\n\t */\n\tvar nullType$$1 = new CoreType$$1(\"null\", TypeFlags$$1.Null, function (v) { return v === null; });\n\t/**\n\t * The type of the value `undefined`\n\t *\n\t * @export\n\t * @alias types.undefined\n\t */\n\tvar undefinedType$$1 = new CoreType$$1(\"undefined\", TypeFlags$$1.Undefined, function (v) { return v === undefined; });\n\t/**\n\t * Creates a type that can only contain a javascript Date value.\n\t *\n\t * @export\n\t * @alias types.Date\n\t * @example\n\t * const LogLine = types.model({\n\t *   timestamp: types.Date,\n\t * })\n\t *\n\t * LogLine.create({ timestamp: new Date() })\n\t */\n\t// tslint:disable-next-line:variable-name\n\tvar DatePrimitive$$1 = new CoreType$$1(\"Date\", TypeFlags$$1.Date, function (v) { return typeof v === \"number\" || v instanceof Date; }, function (v) { return (v instanceof Date ? v : new Date(v)); });\n\tDatePrimitive$$1.getSnapshot = function (node) {\n\t    return node.storedValue.getTime();\n\t};\n\tfunction getPrimitiveFactoryFromValue$$1(value) {\n\t    switch (typeof value) {\n\t        case \"string\":\n\t            return string$$1;\n\t        case \"number\":\n\t            return number$$1;\n\t        case \"boolean\":\n\t            return boolean$$1;\n\t        case \"object\":\n\t            if (value instanceof Date)\n\t                return DatePrimitive$$1;\n\t    }\n\t    return fail(\"Cannot determine primitive type from value \" + value);\n\t}\n\tfunction isPrimitiveType$$1(type) {\n\t    return (isType$$1(type) &&\n\t        (type.flags & (TypeFlags$$1.String | TypeFlags$$1.Number | TypeFlags$$1.Boolean | TypeFlags$$1.Date)) >\n\t            0);\n\t}\n\t\n\tvar Literal$$1 = /** @class */ (function (_super) {\n\t    __extends(Literal$$1, _super);\n\t    function Literal$$1(value) {\n\t        var _this = _super.call(this, JSON.stringify(value)) || this;\n\t        _this.shouldAttachNode = false;\n\t        _this.flags = TypeFlags$$1.Literal;\n\t        _this.value = value;\n\t        return _this;\n\t    }\n\t    Literal$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n\t        return createNode$$1(this, parent, subpath, environment, snapshot);\n\t    };\n\t    Literal$$1.prototype.describe = function () {\n\t        return JSON.stringify(this.value);\n\t    };\n\t    Literal$$1.prototype.isValidSnapshot = function (value, context) {\n\t        if (isPrimitive(value) && value === this.value) {\n\t            return typeCheckSuccess$$1();\n\t        }\n\t        return typeCheckFailure$$1(context, value, \"Value is not a literal \" + JSON.stringify(this.value));\n\t    };\n\t    return Literal$$1;\n\t}(Type$$1));\n\t/**\n\t * The literal type will return a type that will match only the exact given type.\n\t * The given value must be a primitive, in order to be serialized to a snapshot correctly.\n\t * You can use literal to match exact strings for example the exact male or female string.\n\t *\n\t * @example\n\t * const Person = types.model({\n\t *     name: types.string,\n\t *     gender: types.union(types.literal('male'), types.literal('female'))\n\t * })\n\t *\n\t * @export\n\t * @alias types.literal\n\t * @template S\n\t * @param {S} value The value to use in the strict equal check\n\t * @returns {ISimpleType<S>}\n\t */\n\tfunction literal$$1(value) {\n\t    // check that the given value is a primitive\n\t    if (false) {\n\t        if (!isPrimitive(value))\n\t            fail(\"Literal types can be built only on top of primitives\");\n\t    }\n\t    return new Literal$$1(value);\n\t}\n\t\n\tvar Refinement$$1 = /** @class */ (function (_super) {\n\t    __extends(Refinement$$1, _super);\n\t    function Refinement$$1(name, type, predicate, message) {\n\t        var _this = _super.call(this, name) || this;\n\t        _this.type = type;\n\t        _this.predicate = predicate;\n\t        _this.message = message;\n\t        return _this;\n\t    }\n\t    Object.defineProperty(Refinement$$1.prototype, \"flags\", {\n\t        get: function () {\n\t            return this.type.flags | TypeFlags$$1.Refinement;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Refinement$$1.prototype, \"shouldAttachNode\", {\n\t        get: function () {\n\t            return this.type.shouldAttachNode;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Refinement$$1.prototype.describe = function () {\n\t        return this.name;\n\t    };\n\t    Refinement$$1.prototype.instantiate = function (parent, subpath, environment, value) {\n\t        // create the child type\n\t        var inst = this.type.instantiate(parent, subpath, environment, value);\n\t        return inst;\n\t    };\n\t    Refinement$$1.prototype.isAssignableFrom = function (type) {\n\t        return this.type.isAssignableFrom(type);\n\t    };\n\t    Refinement$$1.prototype.isValidSnapshot = function (value, context) {\n\t        var subtypeErrors = this.type.validate(value, context);\n\t        if (subtypeErrors.length > 0)\n\t            return subtypeErrors;\n\t        var snapshot = isStateTreeNode$$1(value) ? getStateTreeNode$$1(value).snapshot : value;\n\t        if (!this.predicate(snapshot)) {\n\t            return typeCheckFailure$$1(context, value, this.message(value));\n\t        }\n\t        return typeCheckSuccess$$1();\n\t    };\n\t    return Refinement$$1;\n\t}(Type$$1));\n\t/**\n\t * `types.refinement(baseType, (snapshot) => boolean)` creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.\n\t *\n\t * @export\n\t * @alias types.refinement\n\t * @template T\n\t * @param {string} name\n\t * @param {IType<T, T>} type\n\t * @param {(snapshot: T) => boolean} predicate\n\t * @returns {IType<T, T>}\n\t */\n\tfunction refinement$$1() {\n\t    var args = [];\n\t    for (var _i = 0; _i < arguments.length; _i++) {\n\t        args[_i] = arguments[_i];\n\t    }\n\t    var name = typeof args[0] === \"string\" ? args.shift() : isType$$1(args[0]) ? args[0].name : null;\n\t    var type = args[0];\n\t    var predicate = args[1];\n\t    var message = args[2]\n\t        ? args[2]\n\t        : function (v) { return \"Value does not respect the refinement predicate\"; };\n\t    // ensures all parameters are correct\n\t    if (false) {\n\t        if (typeof name !== \"string\")\n\t            fail(\"expected a string as first argument, got \" + name + \" instead\");\n\t        if (!isType$$1(type))\n\t            fail(\"expected a mobx-state-tree type as first or second argument, got \" +\n\t                type +\n\t                \" instead\");\n\t        if (typeof predicate !== \"function\")\n\t            fail(\"expected a function as third argument, got \" + predicate + \" instead\");\n\t        if (typeof message !== \"function\")\n\t            fail(\"expected a function as fourth argument, got \" + message + \" instead\");\n\t    }\n\t    return new Refinement$$1(name, type, predicate, message);\n\t}\n\t\n\t/**\n\t * Can be used to create an string based enumeration.\n\t * (note: this methods is just sugar for a union of string literals)\n\t *\n\t * @example\n\t * const TrafficLight = types.model({\n\t *   color: types.enumeration(\"Color\", [\"Red\", \"Orange\", \"Green\"])\n\t * })\n\t *\n\t * @export\n\t * @alias types.enumeration\n\t * @param {string} name descriptive name of the enumeration (optional)\n\t * @param {string[]} options possible values this enumeration can have\n\t * @returns {ISimpleType<string>}\n\t */\n\tfunction enumeration$$1(name, options) {\n\t    var realOptions = typeof name === \"string\" ? options : name;\n\t    // check all options\n\t    if (false) {\n\t        realOptions.forEach(function (option) {\n\t            if (typeof option !== \"string\")\n\t                fail(\"expected all options to be string, got \" + type + \" instead\");\n\t        });\n\t    }\n\t    var type = union$$1.apply(void 0, realOptions.map(function (option) { return literal$$1(\"\" + option); }));\n\t    if (typeof name === \"string\")\n\t        type.name = name;\n\t    return type;\n\t}\n\t\n\tvar Union$$1 = /** @class */ (function (_super) {\n\t    __extends(Union$$1, _super);\n\t    function Union$$1(name, types, dispatcher) {\n\t        var _this = _super.call(this, name) || this;\n\t        _this.dispatcher = null;\n\t        _this.dispatcher = dispatcher;\n\t        _this.types = types;\n\t        return _this;\n\t    }\n\t    Object.defineProperty(Union$$1.prototype, \"flags\", {\n\t        get: function () {\n\t            var result = TypeFlags$$1.Union;\n\t            this.types.forEach(function (type) {\n\t                result |= type.flags;\n\t            });\n\t            return result;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Union$$1.prototype, \"shouldAttachNode\", {\n\t        get: function () {\n\t            return this.types.some(function (type) { return type.shouldAttachNode; });\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Union$$1.prototype.isAssignableFrom = function (type) {\n\t        return this.types.some(function (subType) { return subType.isAssignableFrom(type); });\n\t    };\n\t    Union$$1.prototype.describe = function () {\n\t        return \"(\" + this.types.map(function (factory) { return factory.describe(); }).join(\" | \") + \")\";\n\t    };\n\t    Union$$1.prototype.instantiate = function (parent, subpath, environment, value) {\n\t        return this.determineType(value).instantiate(parent, subpath, environment, value);\n\t    };\n\t    Union$$1.prototype.reconcile = function (current, newValue) {\n\t        return this.determineType(newValue).reconcile(current, newValue);\n\t    };\n\t    Union$$1.prototype.determineType = function (value) {\n\t        // try the dispatcher, if defined\n\t        if (this.dispatcher !== null) {\n\t            return this.dispatcher(value);\n\t        }\n\t        // find the most accomodating type\n\t        var applicableTypes = this.types.filter(function (type) { return type.is(value); });\n\t        if (applicableTypes.length > 1)\n\t            return fail(\"Ambiguos snapshot \" + JSON.stringify(value) + \" for union \" + this\n\t                .name + \". Please provide a dispatch in the union declaration.\");\n\t        return applicableTypes[0];\n\t    };\n\t    Union$$1.prototype.isValidSnapshot = function (value, context) {\n\t        if (this.dispatcher !== null) {\n\t            return this.dispatcher(value).validate(value, context);\n\t        }\n\t        var errors = this.types.map(function (type) { return type.validate(value, context); });\n\t        var applicableTypes = errors.filter(function (errorArray) { return errorArray.length === 0; });\n\t        if (applicableTypes.length > 1) {\n\t            return typeCheckFailure$$1(context, value, \"Multiple types are applicable for the union (hint: provide a dispatch function)\");\n\t        }\n\t        else if (applicableTypes.length === 0) {\n\t            return typeCheckFailure$$1(context, value, \"No type is applicable for the union\").concat(flattenTypeErrors$$1(errors));\n\t        }\n\t        return typeCheckSuccess$$1();\n\t    };\n\t    return Union$$1;\n\t}(Type$$1));\n\t/**\n\t * types.union(dispatcher?, types...) create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function of the form (snapshot) => Type.\n\t *\n\t * @export\n\t * @alias types.union\n\t * @param {(ITypeDispatcher | IType<any, any>)} dispatchOrType\n\t * @param {...IType<any, any>[]} otherTypes\n\t * @returns {IType<any, any>}\n\t */\n\tfunction union$$1(dispatchOrType) {\n\t    var otherTypes = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        otherTypes[_i - 1] = arguments[_i];\n\t    }\n\t    var dispatcher = isType$$1(dispatchOrType) ? null : dispatchOrType;\n\t    var types = isType$$1(dispatchOrType) ? otherTypes.concat(dispatchOrType) : otherTypes;\n\t    var name = \"(\" + types.map(function (type) { return type.name; }).join(\" | \") + \")\";\n\t    // check all options\n\t    if (false) {\n\t        types.forEach(function (type) {\n\t            if (!isType$$1(type))\n\t                fail(\"expected all possible types to be a mobx-state-tree type, got \" +\n\t                    type +\n\t                    \" instead\");\n\t        });\n\t    }\n\t    return new Union$$1(name, types, dispatcher);\n\t}\n\t\n\tvar OptionalValue$$1 = /** @class */ (function (_super) {\n\t    __extends(OptionalValue$$1, _super);\n\t    function OptionalValue$$1(type, defaultValue) {\n\t        var _this = _super.call(this, type.name) || this;\n\t        _this.type = type;\n\t        _this.defaultValue = defaultValue;\n\t        return _this;\n\t    }\n\t    Object.defineProperty(OptionalValue$$1.prototype, \"flags\", {\n\t        get: function () {\n\t            return this.type.flags | TypeFlags$$1.Optional;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(OptionalValue$$1.prototype, \"shouldAttachNode\", {\n\t        get: function () {\n\t            return this.type.shouldAttachNode;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    OptionalValue$$1.prototype.describe = function () {\n\t        return this.type.describe() + \"?\";\n\t    };\n\t    OptionalValue$$1.prototype.instantiate = function (parent, subpath, environment, value) {\n\t        if (typeof value === \"undefined\") {\n\t            var defaultValue = this.getDefaultValue();\n\t            var defaultSnapshot = isStateTreeNode$$1(defaultValue)\n\t                ? getStateTreeNode$$1(defaultValue).snapshot\n\t                : defaultValue;\n\t            return this.type.instantiate(parent, subpath, environment, defaultSnapshot);\n\t        }\n\t        return this.type.instantiate(parent, subpath, environment, value);\n\t    };\n\t    OptionalValue$$1.prototype.reconcile = function (current, newValue) {\n\t        return this.type.reconcile(current, this.type.is(newValue) ? newValue : this.getDefaultValue());\n\t    };\n\t    OptionalValue$$1.prototype.getDefaultValue = function () {\n\t        var defaultValue = typeof this.defaultValue === \"function\" ? this.defaultValue() : this.defaultValue;\n\t        if (typeof this.defaultValue === \"function\")\n\t            typecheck$$1(this, defaultValue);\n\t        return defaultValue;\n\t    };\n\t    OptionalValue$$1.prototype.isValidSnapshot = function (value, context) {\n\t        // defaulted values can be skipped\n\t        if (value === undefined) {\n\t            return typeCheckSuccess$$1();\n\t        }\n\t        // bounce validation to the sub-type\n\t        return this.type.validate(value, context);\n\t    };\n\t    OptionalValue$$1.prototype.isAssignableFrom = function (type) {\n\t        return this.type.isAssignableFrom(type);\n\t    };\n\t    return OptionalValue$$1;\n\t}(Type$$1));\n\t/**\n\t * `types.optional` can be used to create a property with a default value.\n\t * If the given value is not provided in the snapshot, it will default to the provided `defaultValue`.\n\t * If `defaultValue` is a function, the function will be invoked for every new instance.\n\t * Applying a snapshot in which the optional value is _not_ present, causes the value to be reset\n\t *\n\t * @example\n\t * const Todo = types.model({\n\t *   title: types.optional(types.string, \"Test\"),\n\t *   done: types.optional(types.boolean, false),\n\t *   created: types.optional(types.Date, () => new Date())\n\t * })\n\t *\n\t * // it is now okay to omit 'created' and 'done'. created will get a freshly generated timestamp\n\t * const todo = Todo.create({ title: \"Get coffee \"})\n\t *\n\t * @export\n\t * @alias types.optional\n\t */\n\tfunction optional$$1(type, defaultValueOrFunction) {\n\t    if (false) {\n\t        if (!isType$$1(type))\n\t            fail(\"expected a mobx-state-tree type as first argument, got \" + type + \" instead\");\n\t        var defaultValue = typeof defaultValueOrFunction === \"function\"\n\t            ? defaultValueOrFunction()\n\t            : defaultValueOrFunction;\n\t        var defaultSnapshot = isStateTreeNode$$1(defaultValue)\n\t            ? getStateTreeNode$$1(defaultValue).snapshot\n\t            : defaultValue;\n\t        typecheck$$1(type, defaultSnapshot);\n\t    }\n\t    return new OptionalValue$$1(type, defaultValueOrFunction);\n\t}\n\t\n\tvar optionalNullType = optional$$1(nullType$$1, null);\n\t/**\n\t * Maybe will make a type nullable, and also null by default.\n\t *\n\t * @export\n\t * @alias types.maybe\n\t * @template S\n\t * @template T\n\t * @param {IType<S, T>} type The type to make nullable\n\t * @returns {(IType<S | null | undefined, T | null>)}\n\t */\n\tfunction maybe$$1(type) {\n\t    if (false) {\n\t        if (!isType$$1(type))\n\t            fail(\"expected a mobx-state-tree type as first argument, got \" + type + \" instead\");\n\t        if (type === frozen$$1) {\n\t            fail(\"Unable to declare `types.maybe(types.frozen)`. Frozen already accepts `null`. Consider using `types.optional(types.frozen, null)` instead.\");\n\t        }\n\t    }\n\t    return union$$1(optionalNullType, type);\n\t}\n\t\n\tvar Late$$1 = /** @class */ (function (_super) {\n\t    __extends(Late$$1, _super);\n\t    function Late$$1(name, definition) {\n\t        var _this = _super.call(this, name) || this;\n\t        _this._subType = null;\n\t        _this.definition = definition;\n\t        return _this;\n\t    }\n\t    Object.defineProperty(Late$$1.prototype, \"flags\", {\n\t        get: function () {\n\t            return this.subType.flags | TypeFlags$$1.Late;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Late$$1.prototype, \"shouldAttachNode\", {\n\t        get: function () {\n\t            return this.subType.shouldAttachNode;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Late$$1.prototype, \"subType\", {\n\t        get: function () {\n\t            if (this._subType === null) {\n\t                this._subType = this.definition();\n\t            }\n\t            return this._subType;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Late$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n\t        return this.subType.instantiate(parent, subpath, environment, snapshot);\n\t    };\n\t    Late$$1.prototype.reconcile = function (current, newValue) {\n\t        return this.subType.reconcile(current, newValue);\n\t    };\n\t    Late$$1.prototype.describe = function () {\n\t        return this.subType.name;\n\t    };\n\t    Late$$1.prototype.isValidSnapshot = function (value, context) {\n\t        return this.subType.validate(value, context);\n\t    };\n\t    Late$$1.prototype.isAssignableFrom = function (type) {\n\t        return this.subType.isAssignableFrom(type);\n\t    };\n\t    return Late$$1;\n\t}(Type$$1));\n\t/**\n\t * Defines a type that gets implemented later. This is useful when you have to deal with circular dependencies.\n\t * Please notice that when defining circular dependencies TypeScript isn't smart enough to inference them.\n\t * You need to declare an interface to explicit the return type of the late parameter function.\n\t *\n\t * @example\n\t *  interface INode {\n\t *       childs: INode[]\n\t *  }\n\t *\n\t *   // TypeScript is'nt smart enough to infer self referencing types.\n\t *  const Node = types.model({\n\t *       childs: types.optional(types.array(types.late<any, INode>(() => Node)), [])\n\t *  })\n\t *\n\t * @export\n\t * @alias types.late\n\t * @template S\n\t * @template T\n\t * @param {string} [name] The name to use for the type that will be returned.\n\t * @param {ILateType<S, T>} type A function that returns the type that will be defined.\n\t * @returns {IType<S, T>}\n\t */\n\tfunction late$$1(nameOrType, maybeType) {\n\t    var name = typeof nameOrType === \"string\" ? nameOrType : \"late(\" + nameOrType.toString() + \")\";\n\t    var type = typeof nameOrType === \"string\" ? maybeType : nameOrType;\n\t    // checks that the type is actually a late type\n\t    if (false) {\n\t        if (!(typeof type === \"function\" && type.length === 0))\n\t            fail(\"Invalid late type, expected a function with zero arguments that returns a type, got: \" +\n\t                type);\n\t    }\n\t    return new Late$$1(name, type);\n\t}\n\t\n\tvar Frozen$$1 = /** @class */ (function (_super) {\n\t    __extends(Frozen$$1, _super);\n\t    function Frozen$$1() {\n\t        var _this = _super.call(this, \"frozen\") || this;\n\t        _this.shouldAttachNode = false;\n\t        _this.flags = TypeFlags$$1.Frozen;\n\t        return _this;\n\t    }\n\t    Frozen$$1.prototype.describe = function () {\n\t        return \"<any immutable value>\";\n\t    };\n\t    Frozen$$1.prototype.instantiate = function (parent, subpath, environment, value) {\n\t        // deep freeze the object/array only in dev mode\n\t        var finalValue =  false ? deepFreeze(value) : value;\n\t        // create the node\n\t        return createNode$$1(this, parent, subpath, environment, finalValue);\n\t    };\n\t    Frozen$$1.prototype.isValidSnapshot = function (value, context) {\n\t        if (!isSerializable(value)) {\n\t            return typeCheckFailure$$1(context, value, \"Value is not serializable and cannot be frozen\");\n\t        }\n\t        return typeCheckSuccess$$1();\n\t    };\n\t    return Frozen$$1;\n\t}(Type$$1));\n\t/**\n\t * Frozen can be used to story any value that is serializable in itself (that is valid JSON).\n\t * Frozen values need to be immutable or treated as if immutable. They need be serializable as well.\n\t * Values stored in frozen will snapshotted as-is by MST, and internal changes will not be tracked.\n\t *\n\t * This is useful to store complex, but immutable values like vectors etc. It can form a powerful bridge to parts of your application that should be immutable, or that assume data to be immutable.\n\t *\n\t * Note: if you want to store free-form state that is mutable, or not serializeable, consider using volatile state instead.\n\t *\n\t * @example\n\t * const GameCharacter = types.model({\n\t *   name: string,\n\t *   location: types.frozen\n\t * })\n\t *\n\t * const hero = GameCharacter.create({\n\t *   name: \"Mario\",\n\t *   location: { x: 7, y: 4 }\n\t * })\n\t *\n\t * hero.location = { x: 10, y: 2 } // OK\n\t * hero.location.x = 7 // Not ok!\n\t *\n\t * @alias types.frozen\n\t */\n\tvar frozen$$1 = new Frozen$$1();\n\t\n\tvar StoredReference = /** @class */ (function () {\n\t    function StoredReference(mode, value) {\n\t        this.mode = mode;\n\t        this.value = value;\n\t        if (mode === \"object\") {\n\t            if (!isStateTreeNode$$1(value))\n\t                return fail(\"Can only store references to tree nodes, got: '\" + value + \"'\");\n\t            var targetNode = getStateTreeNode$$1(value);\n\t            if (!targetNode.identifierAttribute)\n\t                return fail(\"Can only store references with a defined identifier attribute.\");\n\t        }\n\t    }\n\t    return StoredReference;\n\t}());\n\tvar BaseReferenceType$$1 = /** @class */ (function (_super) {\n\t    __extends(BaseReferenceType$$1, _super);\n\t    function BaseReferenceType$$1(targetType) {\n\t        var _this = _super.call(this, \"reference(\" + targetType.name + \")\") || this;\n\t        _this.targetType = targetType;\n\t        _this.flags = TypeFlags$$1.Reference;\n\t        return _this;\n\t    }\n\t    BaseReferenceType$$1.prototype.describe = function () {\n\t        return this.name;\n\t    };\n\t    BaseReferenceType$$1.prototype.isAssignableFrom = function (type) {\n\t        return this.targetType.isAssignableFrom(type);\n\t    };\n\t    BaseReferenceType$$1.prototype.isValidSnapshot = function (value, context) {\n\t        return typeof value === \"string\" || typeof value === \"number\"\n\t            ? typeCheckSuccess$$1()\n\t            : typeCheckFailure$$1(context, value, \"Value is not a valid identifier, which is a string or a number\");\n\t    };\n\t    return BaseReferenceType$$1;\n\t}(Type$$1));\n\tvar IdentifierReferenceType$$1 = /** @class */ (function (_super) {\n\t    __extends(IdentifierReferenceType$$1, _super);\n\t    function IdentifierReferenceType$$1(targetType) {\n\t        var _this = _super.call(this, targetType) || this;\n\t        _this.shouldAttachNode = true;\n\t        return _this;\n\t    }\n\t    IdentifierReferenceType$$1.prototype.getValue = function (node) {\n\t        if (!node.isAlive)\n\t            return undefined;\n\t        var ref = node.storedValue;\n\t        // id already resolved, return\n\t        if (ref.mode === \"object\")\n\t            return ref.value;\n\t        // reference was initialized with the identifier of the target\n\t        var target = node.root.identifierCache.resolve(this.targetType, ref.value);\n\t        if (!target)\n\t            return fail(\"Failed to resolve reference of type \" + this.targetType\n\t                .name + \": '\" + ref.value + \"' (in: \" + node.path + \")\");\n\t        return target.value;\n\t    };\n\t    IdentifierReferenceType$$1.prototype.getSnapshot = function (node) {\n\t        var ref = node.storedValue;\n\t        switch (ref.mode) {\n\t            case \"identifier\":\n\t                return ref.value;\n\t            case \"object\":\n\t                return getStateTreeNode$$1(ref.value).identifier;\n\t        }\n\t    };\n\t    IdentifierReferenceType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n\t        return createNode$$1(this, parent, subpath, environment, new StoredReference(isStateTreeNode$$1(snapshot) ? \"object\" : \"identifier\", snapshot));\n\t    };\n\t    IdentifierReferenceType$$1.prototype.reconcile = function (current, newValue) {\n\t        if (current.type === this) {\n\t            var targetMode = isStateTreeNode$$1(newValue) ? \"object\" : \"identifier\";\n\t            var ref = current.storedValue;\n\t            if (targetMode === ref.mode && ref.value === newValue)\n\t                return current;\n\t        }\n\t        var newNode = this.instantiate(current.parent, current.subpath, current._environment, newValue);\n\t        current.die();\n\t        return newNode;\n\t    };\n\t    return IdentifierReferenceType$$1;\n\t}(BaseReferenceType$$1));\n\tvar CustomReferenceType$$1 = /** @class */ (function (_super) {\n\t    __extends(CustomReferenceType$$1, _super);\n\t    function CustomReferenceType$$1(targetType, options) {\n\t        var _this = _super.call(this, targetType) || this;\n\t        _this.options = options;\n\t        _this.shouldAttachNode = false;\n\t        return _this;\n\t    }\n\t    CustomReferenceType$$1.prototype.getValue = function (node) {\n\t        if (!node.isAlive)\n\t            return undefined;\n\t        return this.options.get(node.storedValue, node.parent ? node.parent.storedValue : null);\n\t    };\n\t    CustomReferenceType$$1.prototype.getSnapshot = function (node) {\n\t        return node.storedValue;\n\t    };\n\t    CustomReferenceType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n\t        var identifier$$1 = isStateTreeNode$$1(snapshot)\n\t            ? this.options.set(snapshot, parent ? parent.storedValue : null)\n\t            : snapshot;\n\t        return createNode$$1(this, parent, subpath, environment, identifier$$1);\n\t    };\n\t    CustomReferenceType$$1.prototype.reconcile = function (current, snapshot) {\n\t        var newIdentifier = isStateTreeNode$$1(snapshot)\n\t            ? this.options.set(snapshot, current ? current.storedValue : null)\n\t            : snapshot;\n\t        if (current.type === this) {\n\t            if (current.storedValue === newIdentifier)\n\t                return current;\n\t        }\n\t        var newNode = this.instantiate(current.parent, current.subpath, current._environment, newIdentifier);\n\t        current.die();\n\t        return newNode;\n\t    };\n\t    return CustomReferenceType$$1;\n\t}(BaseReferenceType$$1));\n\t/**\n\t * Creates a reference to another type, which should have defined an identifier.\n\t * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.\n\t *\n\t * @export\n\t * @alias types.reference\n\t */\n\tfunction reference$$1(subType, options) {\n\t    // check that a type is given\n\t    if (false) {\n\t        if (!isType$$1(subType))\n\t            fail(\"expected a mobx-state-tree type as first argument, got \" + subType + \" instead\");\n\t        if (arguments.length === 2 && typeof arguments[1] === \"string\")\n\t            fail(\"References with base path are no longer supported. Please remove the base path.\");\n\t    }\n\t    if (options)\n\t        return new CustomReferenceType$$1(subType, options);\n\t    else\n\t        return new IdentifierReferenceType$$1(subType);\n\t}\n\t\n\tvar IdentifierType$$1 = /** @class */ (function (_super) {\n\t    __extends(IdentifierType$$1, _super);\n\t    function IdentifierType$$1(identifierType) {\n\t        var _this = _super.call(this, \"identifier(\" + identifierType.name + \")\") || this;\n\t        _this.identifierType = identifierType;\n\t        _this.shouldAttachNode = false;\n\t        _this.flags = TypeFlags$$1.Identifier;\n\t        return _this;\n\t    }\n\t    IdentifierType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n\t        if (!parent || !isStateTreeNode$$1(parent.storedValue))\n\t            return fail(\"Identifier types can only be instantiated as direct child of a model type\");\n\t        if (parent.identifierAttribute)\n\t            fail(\"Cannot define property '\" + subpath + \"' as object identifier, property '\" + parent.identifierAttribute + \"' is already defined as identifier property\");\n\t        parent.identifierAttribute = subpath;\n\t        return createNode$$1(this, parent, subpath, environment, snapshot);\n\t    };\n\t    IdentifierType$$1.prototype.reconcile = function (current, newValue) {\n\t        if (current.storedValue !== newValue)\n\t            return fail(\"Tried to change identifier from '\" + current.storedValue + \"' to '\" + newValue + \"'. Changing identifiers is not allowed.\");\n\t        return current;\n\t    };\n\t    IdentifierType$$1.prototype.describe = function () {\n\t        return \"identifier(\" + this.identifierType.describe() + \")\";\n\t    };\n\t    IdentifierType$$1.prototype.isValidSnapshot = function (value, context) {\n\t        if (value === undefined ||\n\t            value === null ||\n\t            typeof value === \"string\" ||\n\t            typeof value === \"number\")\n\t            return this.identifierType.validate(value, context);\n\t        return typeCheckFailure$$1(context, value, \"Value is not a valid identifier, which is a string or a number\");\n\t    };\n\t    return IdentifierType$$1;\n\t}(Type$$1));\n\t/**\n\t * Identifiers are used to make references, lifecycle events and reconciling works.\n\t * Inside a state tree, for each type can exist only one instance for each given identifier.\n\t * For example there couldn't be 2 instances of user with id 1. If you need more, consider using references.\n\t * Identifier can be used only as type property of a model.\n\t * This type accepts as parameter the value type of the identifier field that can be either string or number.\n\t *\n\t * @example\n\t *  const Todo = types.model(\"Todo\", {\n\t *      id: types.identifier(types.string),\n\t *      title: types.string\n\t *  })\n\t *\n\t * @export\n\t * @alias types.identifier\n\t * @template T\n\t * @param {IType<T, T>} baseType\n\t * @returns {IType<T, T>}\n\t */\n\tfunction identifier$$1(baseType) {\n\t    if (baseType === void 0) { baseType = string$$1; }\n\t    if (false) {\n\t        if (!isType$$1(baseType))\n\t            fail(\"expected a mobx-state-tree type as first argument, got \" + baseType + \" instead\");\n\t    }\n\t    return new IdentifierType$$1(baseType);\n\t}\n\t\n\t/**\n\t * All imports / exports should be proxied through this file.\n\t * Why? It gives us full control over the module load order, preventing circular dependency isses\n\t */\n\t\n\t/** all code is initially loaded through internal, to avoid circular dep issues */\n\t// tslint:disable-next-line:no_unused-variable\n\tvar types = {\n\t    enumeration: enumeration$$1,\n\t    model: model$$1,\n\t    compose: compose$$1,\n\t    reference: reference$$1,\n\t    union: union$$1,\n\t    optional: optional$$1,\n\t    literal: literal$$1,\n\t    maybe: maybe$$1,\n\t    refinement: refinement$$1,\n\t    string: string$$1,\n\t    boolean: boolean$$1,\n\t    number: number$$1,\n\t    Date: DatePrimitive$$1,\n\t    map: map$$1,\n\t    array: array$$1,\n\t    frozen: frozen$$1,\n\t    identifier: identifier$$1,\n\t    late: late$$1,\n\t    undefined: undefinedType$$1,\n\t    null: nullType$$1\n\t};\n\t\n\texports.types = types;\n\texports.typecheck = typecheckPublic$$1;\n\texports.escapeJsonPath = escapeJsonPath$$1;\n\texports.unescapeJsonPath = unescapeJsonPath$$1;\n\texports.decorate = decorate$$1;\n\texports.addMiddleware = addMiddleware$$1;\n\texports.process = process$1$$1;\n\texports.isStateTreeNode = isStateTreeNode$$1;\n\texports.flow = flow;\n\texports.applyAction = applyAction$$1;\n\texports.onAction = onAction$$1;\n\texports.recordActions = recordActions$$1;\n\texports.createActionTrackingMiddleware = createActionTrackingMiddleware;\n\texports.getType = getType$$1;\n\texports.getChildType = getChildType$$1;\n\texports.onPatch = onPatch$$1;\n\texports.onSnapshot = onSnapshot$$1;\n\texports.applyPatch = applyPatch$$1;\n\texports.recordPatches = recordPatches$$1;\n\texports.protect = protect$$1;\n\texports.unprotect = unprotect$$1;\n\texports.isProtected = isProtected$$1;\n\texports.applySnapshot = applySnapshot$$1;\n\texports.getSnapshot = getSnapshot$$1;\n\texports.hasParent = hasParent$$1;\n\texports.getParent = getParent$$1;\n\texports.getRoot = getRoot$$1;\n\texports.getPath = getPath$$1;\n\texports.getPathParts = getPathParts$$1;\n\texports.isRoot = isRoot$$1;\n\texports.resolvePath = resolvePath$$1;\n\texports.resolveIdentifier = resolveIdentifier$$1;\n\texports.tryResolve = tryResolve$$1;\n\texports.getRelativePath = getRelativePath$$1;\n\texports.clone = clone$$1;\n\texports.detach = detach$$1;\n\texports.destroy = destroy$$1;\n\texports.isAlive = isAlive$$1;\n\texports.addDisposer = addDisposer$$1;\n\texports.getEnv = getEnv$$1;\n\texports.walk = walk$$1;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(391).setImmediate))\n\n/***/ }),\n\n/***/ 1010:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<p>以一个简单的 TodoList 应用为例，分别使用 <a href=\\\"https://github.com/mobxjs/mobx-state-tree\\\">Mobx State Tree</a> 和 React Mobx VM 来实现一下，这样对比起来更明显</p>\\n<div class=\\\"picidae-toc\\\">\\n<ul>\\n<li>\\n<a href=\\\"#mst-todolist\\\">MST TodoList</a>\\n</li>\\n<li>\\n<a href=\\\"#vm-todolist\\\">VM TodoList</a>\\n</li>\\n</ul>\\n</div>\\n<hr>\\n<h2 id=\\\"mst-todolist\\\"><a href=\\\"#mst-todolist\\\" aria-hidden=\\\"true\\\"><span class=\\\"icon icon-link\\\"></span></a>MST TodoList</h2>\\n<p>如需实现如下一个简单的 TodoList 应用，使用 MST（Mobx State Tree）应该如何书写呢？</p>\\n<ul>\\n<li>index.js</li>\\n</ul>\\n<div class=\\\"transformer-react-render-container\\\"><transformer-react-render data-id=\\\"0\\\"></transformer-react-render><pre><code class=\\\"hljs language-jsx\\\" data-query=\\\"{&#x22;editable&#x22;:true,&#x22;placement&#x22;:&#x22;top&#x22;}\\\" data-lang=\\\"jsx\\\"><span class=\\\"hljs-keyword\\\">import</span> { observable, computed } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> { observer } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx-react'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> * <span class=\\\"hljs-keyword\\\">as</span> React <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> { render } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-dom'</span>\\n\\n<span class=\\\"hljs-keyword\\\">import</span> { TodoStore } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'../snippets/mst/models/TodoStore'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> { TodoList } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'../snippets/mst/components/TodoList'</span>\\n<span class=\\\"hljs-comment\\\">// 注意：该以下代码可同步编辑</span>\\n<span class=\\\"hljs-keyword\\\">const</span> store = TodoStore.create({\\n  <span class=\\\"hljs-attr\\\">todos</span>: [\\n    {\\n      <span class=\\\"hljs-attr\\\">title</span>: <span class=\\\"hljs-string\\\">'Get Coffee'</span>\\n    },\\n    {\\n      <span class=\\\"hljs-attr\\\">title</span>: <span class=\\\"hljs-string\\\">'Write simpler code'</span>\\n    }\\n  ]\\n})\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> &#x3C;TodoList todoStore={store}/></code></pre></div>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> { types } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx-state-tree'</span>\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">const</span> Todo = types\\n  .model(<span class=\\\"hljs-string\\\">'Todo'</span>, {\\n    <span class=\\\"hljs-attr\\\">id</span>: types.optional(types.number, () => <span class=\\\"hljs-built_in\\\">Math</span>.random()),\\n    <span class=\\\"hljs-attr\\\">title</span>: types.string,\\n    <span class=\\\"hljs-attr\\\">finished</span>: <span class=\\\"hljs-literal\\\">false</span>\\n  })\\n  .actions(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">self</span> =></span> (\\n    {\\n      toggle() {\\n        self.finished = !self.finished\\n      }\\n    }\\n  ))\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">const</span> TodoStore = types\\n  .model(<span class=\\\"hljs-string\\\">'TodoStore'</span>, {\\n    <span class=\\\"hljs-attr\\\">todos</span>: types.array(Todo)\\n  })\\n  .views(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">self</span> =></span> (\\n    {\\n      get unfinishedTodoCount() {\\n        <span class=\\\"hljs-keyword\\\">return</span> self.todos.filter(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">todo</span> =></span> !todo.finished).length\\n      }\\n    }\\n  ))\\n  .actions(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">self</span> =></span> (\\n    {\\n      addTodo(title) {\\n        self.todos.push({ title })\\n      }\\n    }\\n  ))</code></pre>\\n<ul>\\n<li>../snippets/mst/components/TodoList.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> { observable } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> { observer } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx-react'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> * <span class=\\\"hljs-keyword\\\">as</span> React <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react'</span>\\n\\n<span class=\\\"hljs-keyword\\\">import</span> { Todo } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'./Todo'</span>\\n\\n@observer\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-class\\\"><span class=\\\"hljs-keyword\\\">class</span> <span class=\\\"hljs-title\\\">TodoList</span> <span class=\\\"hljs-keyword\\\">extends</span> <span class=\\\"hljs-title\\\">React</span>.<span class=\\\"hljs-title\\\">Component</span> </span>{\\n  @observable newTodoTitle = <span class=\\\"hljs-string\\\">''</span>\\n\\n  render() {\\n    <span class=\\\"hljs-keyword\\\">const</span> { todoStore } = <span class=\\\"hljs-keyword\\\">this</span>.props\\n    <span class=\\\"hljs-keyword\\\">return</span> (\\n      <span class=\\\"xml\\\"><span class=\\\"hljs-tag\\\">&#x3C;<span class=\\\"hljs-name\\\">div</span>></span>\\n        </span>&#x3C;input value={this.newTodoTitle} onChange={this.handleChange}/>\\n        &#x3C;button onClick={this.handleNewTodoClick}>Add&#x3C;/button>\\n        &#x3C;ul>\\n          {todoStore.todos.map(todo => &#x3C;Todo todo={todo} key={todo.id}/>)}\\n        &#x3C;/ul>\\n        Tasks left: {todoStore.unfinishedTodoCount}\\n      &#x3C;/div>\\n    )\\n  }\\n\\n  handleChange = (e) => {\\n    this.newTodoTitle = e.target.value\\n  }\\n\\n  handleNewTodoClick = (e) => {\\n    e.stopPropagation()\\n    this.props.todoStore.addTodo(this.newTodoTitle)\\n    this.newTodoTitle = ''\\n  }\\n}</code></pre>\\n<ul>\\n<li>../snippets/mst/components/Todo.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> { observer } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx-react'</span>;\\n<span class=\\\"hljs-keyword\\\">import</span> * <span class=\\\"hljs-keyword\\\">as</span> React <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react'</span>;\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">const</span> Todo = observer(<span class=\\\"hljs-function\\\">(<span class=\\\"hljs-params\\\">{ todo }</span>) =></span>\\n  &#x3C;li>\\n    <span class=\\\"xml\\\"><span class=\\\"hljs-tag\\\">&#x3C;<span class=\\\"hljs-name\\\">input</span>\\n      <span class=\\\"hljs-attr\\\">type</span>=<span class=\\\"hljs-string\\\">\\\"checkbox\\\"</span>\\n      <span class=\\\"hljs-attr\\\">checked</span>=<span class=\\\"hljs-string\\\">{todo.finished}</span>\\n      <span class=\\\"hljs-attr\\\">onClick</span>=<span class=\\\"hljs-string\\\">{todo.toggle}</span>\\n    /></span>\\n    {todo.title}\\n  <span class=\\\"hljs-tag\\\">&#x3C;/<span class=\\\"hljs-name\\\">li</span>></span></span>,\\n);</code></pre>\\n<h2 id=\\\"vm-todolist\\\"><a href=\\\"#vm-todolist\\\" aria-hidden=\\\"true\\\"><span class=\\\"icon icon-link\\\"></span></a>VM TodoList</h2>\\n<ul>\\n<li>index.js</li>\\n</ul>\\n<div class=\\\"transformer-react-render-container\\\"><transformer-react-render data-id=\\\"1\\\"></transformer-react-render><pre><code class=\\\"hljs language-jsx\\\" data-query=\\\"{&#x22;editable&#x22;:true,&#x22;placement&#x22;:&#x22;top&#x22;}\\\" data-lang=\\\"jsx\\\"><span class=\\\"hljs-keyword\\\">import</span> ReactDOM <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-dom'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> { h } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-mobx-vm'</span>\\n\\n<span class=\\\"hljs-keyword\\\">import</span> TodoList <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'../snippets/vm/TodoList'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> Todo <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'../snippets/vm/Todo'</span>\\n<span class=\\\"hljs-comment\\\">// 注意：该以下代码可同步编辑</span>\\n<span class=\\\"hljs-keyword\\\">const</span> App = TodoList.create({\\n  <span class=\\\"hljs-attr\\\">todos</span>: [\\n    Todo.create({\\n      <span class=\\\"hljs-attr\\\">title</span>: <span class=\\\"hljs-string\\\">'Get Coffee'</span>\\n    }),\\n    Todo.create({\\n      <span class=\\\"hljs-attr\\\">title</span>: <span class=\\\"hljs-string\\\">'Write simpler code'</span>\\n    })\\n  ]\\n})\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> h(App)</code></pre></div>\\n<ul>\\n<li>../snippets/vm/TodoList/index.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> {\\n  Root,\\n  bindView,\\n  observable,\\n  computed,\\n  action\\n} <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-mobx-vm'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> View <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'./View'</span>\\n\\n<span class=\\\"hljs-keyword\\\">import</span> Todo <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'../Todo'</span>\\n\\n@bindView(View)\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> <span class=\\\"hljs-class\\\"><span class=\\\"hljs-keyword\\\">class</span> <span class=\\\"hljs-title\\\">TodoList</span> <span class=\\\"hljs-keyword\\\">extends</span> <span class=\\\"hljs-title\\\">Root</span> </span>{\\n  @observable todos = []\\n  @observable newTodoTitle = <span class=\\\"hljs-string\\\">''</span>\\n  @computed get unfinishedTodoCount() {\\n    <span class=\\\"hljs-keyword\\\">return</span> <span class=\\\"hljs-keyword\\\">this</span>.todos.filter(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">todo</span> =></span> !todo.finished).length\\n  }\\n  @action addTodo() {\\n    <span class=\\\"hljs-keyword\\\">this</span>.todos.push(Todo.create({ <span class=\\\"hljs-attr\\\">title</span>: <span class=\\\"hljs-keyword\\\">this</span>.newTodoTitle }))\\n  }\\n}</code></pre>\\n<ul>\\n<li>../snippets/vm/TodoList/View.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> { h, binding } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-mobx-vm'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> * <span class=\\\"hljs-keyword\\\">as</span> React <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react'</span>\\n\\n@binding\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> <span class=\\\"hljs-class\\\"><span class=\\\"hljs-keyword\\\">class</span> <span class=\\\"hljs-title\\\">TodoList</span> <span class=\\\"hljs-keyword\\\">extends</span> <span class=\\\"hljs-title\\\">React</span>.<span class=\\\"hljs-title\\\">Component</span> </span>{\\n\\n  render() {\\n    <span class=\\\"hljs-keyword\\\">const</span> todoStore = <span class=\\\"hljs-keyword\\\">this</span>.local\\n    <span class=\\\"hljs-keyword\\\">return</span> (\\n      <span class=\\\"xml\\\"><span class=\\\"hljs-tag\\\">&#x3C;<span class=\\\"hljs-name\\\">div</span>></span>\\n        </span>&#x3C;input data-bind=\\\"newTodoTitle\\\" />\\n        &#x3C;button onClick={this.handleNewTodoClick}>Add&#x3C;/button>\\n        &#x3C;ul>\\n          {todoStore.todos.map(todo => h(todo, { key: todo.id }))}\\n        &#x3C;/ul>\\n        Tasks left: {todoStore.unfinishedTodoCount}\\n      &#x3C;/div><span class=\\\"xml\\\">\\n    )\\n  }\\n\\n  handleNewTodoClick = (e) => {\\n    e.stopPropagation()\\n    this.local.addTodo(this.newTodoTitle)\\n    this.local.newTodoTitle = ''\\n  }\\n}</span></code></pre>\\n<ul>\\n<li>../snippets/vm/Todo/index.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> { Root, bindView, observable, action } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-mobx-vm'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> View <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'./View'</span>\\n\\n@bindView(View)\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> <span class=\\\"hljs-class\\\"><span class=\\\"hljs-keyword\\\">class</span> <span class=\\\"hljs-title\\\">Todo</span> <span class=\\\"hljs-keyword\\\">extends</span> <span class=\\\"hljs-title\\\">Root</span> </span>{\\n  @observable id = <span class=\\\"hljs-built_in\\\">Math</span>.random()\\n  @observable title = <span class=\\\"hljs-string\\\">''</span>\\n  @observable finished = <span class=\\\"hljs-literal\\\">false</span>\\n  @action toggle() {\\n    <span class=\\\"hljs-keyword\\\">this</span>.finished = !<span class=\\\"hljs-keyword\\\">this</span>.finished\\n  }\\n}</code></pre>\\n<ul>\\n<li>../snippets/vm/Todo/View.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> {\\n  stateless\\n} <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-mobx-vm'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> * <span class=\\\"hljs-keyword\\\">as</span> React <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react'</span>\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> stateless(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">local</span> =></span>\\n  &#x3C;li>\\n    <span class=\\\"xml\\\"><span class=\\\"hljs-tag\\\">&#x3C;<span class=\\\"hljs-name\\\">input</span>\\n      <span class=\\\"hljs-attr\\\">type</span>=<span class=\\\"hljs-string\\\">\\\"checkbox\\\"</span>\\n      <span class=\\\"hljs-attr\\\">checked</span>=<span class=\\\"hljs-string\\\">{local.finished}</span>\\n      <span class=\\\"hljs-attr\\\">onClick</span>=<span class=\\\"hljs-string\\\">{local.toggle.bind(local)}</span>\\n    /></span>\\n    {local.title}\\n  <span class=\\\"hljs-tag\\\">&#x3C;/<span class=\\\"hljs-name\\\">li</span>></span></span>\\n)</code></pre>\\n\",\n\t  \"extra\": {},\n\t  \"transformer-react-render\": {\n\t    \"list\": [\n\t      [\n\t        \"function anonymous(React,Component,ReactDOM,require\\n) {\\n\\nvar exports = {}, module = {};\\nmodule.exports = exports;\\n(function picidaeTransformerReactRender(){Object.defineProperty(exports,\\\"__esModule\\\",{value:true});var _mobx=require(\\\"mobx\\\");var _mobxReact=require(\\\"mobx-react\\\");var _react=require(\\\"react\\\");var React=_interopRequireWildcard(_react);var _reactDom=require(\\\"react-dom\\\");var _TodoStore=require(\\\"../snippets/mst/models/TodoStore\\\");var _TodoList=require(\\\"../snippets/mst/components/TodoList\\\");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))newObj[key]=obj[key]}}newObj.default=obj;return newObj}}// 注意：该以下代码可同步编辑\\nvar store=_TodoStore.TodoStore.create({todos:[{title:\\\"Get Coffee\\\"},{title:\\\"Write simpler code\\\"}]});exports.default=React.createElement(_TodoList.TodoList,{todoStore:store})})(exports, module)\\nreturn module.exports.default || module.exports;\\n}\",\n\t        {\n\t          \"editable\": true,\n\t          \"placement\": \"top\"\n\t        },\n\t        7\n\t      ],\n\t      [\n\t        \"function anonymous(React,Component,ReactDOM,require\\n) {\\n\\nvar exports = {}, module = {};\\nmodule.exports = exports;\\n(function picidaeTransformerReactRender(){Object.defineProperty(exports,\\\"__esModule\\\",{value:true});var _reactDom=require(\\\"react-dom\\\");var _reactDom2=_interopRequireDefault(_reactDom);var _reactMobxVm=require(\\\"react-mobx-vm\\\");var _TodoList=require(\\\"../snippets/vm/TodoList\\\");var _TodoList2=_interopRequireDefault(_TodoList);var _Todo=require(\\\"../snippets/vm/Todo\\\");var _Todo2=_interopRequireDefault(_Todo);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}// 注意：该以下代码可同步编辑\\nvar App=_TodoList2.default.create({todos:[_Todo2.default.create({title:\\\"Get Coffee\\\"}),_Todo2.default.create({title:\\\"Write simpler code\\\"})]});exports.default=(0,_reactMobxVm.h)(App)})(exports, module)\\nreturn module.exports.default || module.exports;\\n}\",\n\t        {\n\t          \"editable\": true,\n\t          \"placement\": \"top\"\n\t        },\n\t        5\n\t      ]\n\t    ],\n\t    \"pkg\": {\n\t      \"react\": __webpack_require__(3),\n\t      \"react-dom\": __webpack_require__(52),\n\t      \"mobx\": __webpack_require__(94),\n\t      \"mobx-react\": __webpack_require__(112),\n\t      \"../snippets/mst/models/TodoStore\": __webpack_require__(372),\n\t      \"../snippets/mst/components/TodoList\": __webpack_require__(371),\n\t      \"react-mobx-vm\": __webpack_require__(19),\n\t      \"../snippets/vm/TodoList\": __webpack_require__(375),\n\t      \"../snippets/vm/Todo\": __webpack_require__(241)\n\t    }\n\t  }\n\t}\n\n/***/ }),\n\n/***/ 1113:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n\t    \"use strict\";\n\t\n\t    if (global.setImmediate) {\n\t        return;\n\t    }\n\t\n\t    var nextHandle = 1; // Spec says greater than zero\n\t    var tasksByHandle = {};\n\t    var currentlyRunningATask = false;\n\t    var doc = global.document;\n\t    var registerImmediate;\n\t\n\t    function setImmediate(callback) {\n\t      // Callback can either be a function or a string\n\t      if (typeof callback !== \"function\") {\n\t        callback = new Function(\"\" + callback);\n\t      }\n\t      // Copy function arguments\n\t      var args = new Array(arguments.length - 1);\n\t      for (var i = 0; i < args.length; i++) {\n\t          args[i] = arguments[i + 1];\n\t      }\n\t      // Store and register the task\n\t      var task = { callback: callback, args: args };\n\t      tasksByHandle[nextHandle] = task;\n\t      registerImmediate(nextHandle);\n\t      return nextHandle++;\n\t    }\n\t\n\t    function clearImmediate(handle) {\n\t        delete tasksByHandle[handle];\n\t    }\n\t\n\t    function run(task) {\n\t        var callback = task.callback;\n\t        var args = task.args;\n\t        switch (args.length) {\n\t        case 0:\n\t            callback();\n\t            break;\n\t        case 1:\n\t            callback(args[0]);\n\t            break;\n\t        case 2:\n\t            callback(args[0], args[1]);\n\t            break;\n\t        case 3:\n\t            callback(args[0], args[1], args[2]);\n\t            break;\n\t        default:\n\t            callback.apply(undefined, args);\n\t            break;\n\t        }\n\t    }\n\t\n\t    function runIfPresent(handle) {\n\t        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n\t        // So if we're currently running a task, we'll need to delay this invocation.\n\t        if (currentlyRunningATask) {\n\t            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n\t            // \"too much recursion\" error.\n\t            setTimeout(runIfPresent, 0, handle);\n\t        } else {\n\t            var task = tasksByHandle[handle];\n\t            if (task) {\n\t                currentlyRunningATask = true;\n\t                try {\n\t                    run(task);\n\t                } finally {\n\t                    clearImmediate(handle);\n\t                    currentlyRunningATask = false;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function installNextTickImplementation() {\n\t        registerImmediate = function(handle) {\n\t            process.nextTick(function () { runIfPresent(handle); });\n\t        };\n\t    }\n\t\n\t    function canUsePostMessage() {\n\t        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n\t        // where `global.postMessage` means something completely different and can't be used for this purpose.\n\t        if (global.postMessage && !global.importScripts) {\n\t            var postMessageIsAsynchronous = true;\n\t            var oldOnMessage = global.onmessage;\n\t            global.onmessage = function() {\n\t                postMessageIsAsynchronous = false;\n\t            };\n\t            global.postMessage(\"\", \"*\");\n\t            global.onmessage = oldOnMessage;\n\t            return postMessageIsAsynchronous;\n\t        }\n\t    }\n\t\n\t    function installPostMessageImplementation() {\n\t        // Installs an event handler on `global` for the `message` event: see\n\t        // * https://developer.mozilla.org/en/DOM/window.postMessage\n\t        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\t\n\t        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\t        var onGlobalMessage = function(event) {\n\t            if (event.source === global &&\n\t                typeof event.data === \"string\" &&\n\t                event.data.indexOf(messagePrefix) === 0) {\n\t                runIfPresent(+event.data.slice(messagePrefix.length));\n\t            }\n\t        };\n\t\n\t        if (global.addEventListener) {\n\t            global.addEventListener(\"message\", onGlobalMessage, false);\n\t        } else {\n\t            global.attachEvent(\"onmessage\", onGlobalMessage);\n\t        }\n\t\n\t        registerImmediate = function(handle) {\n\t            global.postMessage(messagePrefix + handle, \"*\");\n\t        };\n\t    }\n\t\n\t    function installMessageChannelImplementation() {\n\t        var channel = new MessageChannel();\n\t        channel.port1.onmessage = function(event) {\n\t            var handle = event.data;\n\t            runIfPresent(handle);\n\t        };\n\t\n\t        registerImmediate = function(handle) {\n\t            channel.port2.postMessage(handle);\n\t        };\n\t    }\n\t\n\t    function installReadyStateChangeImplementation() {\n\t        var html = doc.documentElement;\n\t        registerImmediate = function(handle) {\n\t            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t            var script = doc.createElement(\"script\");\n\t            script.onreadystatechange = function () {\n\t                runIfPresent(handle);\n\t                script.onreadystatechange = null;\n\t                html.removeChild(script);\n\t                script = null;\n\t            };\n\t            html.appendChild(script);\n\t        };\n\t    }\n\t\n\t    function installSetTimeoutImplementation() {\n\t        registerImmediate = function(handle) {\n\t            setTimeout(runIfPresent, 0, handle);\n\t        };\n\t    }\n\t\n\t    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\t    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n\t    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\t\n\t    // Don't get fooled by e.g. browserify environments.\n\t    if ({}.toString.call(global.process) === \"[object process]\") {\n\t        // For Node.js before 0.9\n\t        installNextTickImplementation();\n\t\n\t    } else if (canUsePostMessage()) {\n\t        // For non-IE10 modern browsers\n\t        installPostMessageImplementation();\n\t\n\t    } else if (global.MessageChannel) {\n\t        // For web workers, where supported\n\t        installMessageChannelImplementation();\n\t\n\t    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n\t        // For IE 6–8\n\t        installReadyStateChangeImplementation();\n\t\n\t    } else {\n\t        // For older browsers\n\t        installSetTimeoutImplementation();\n\t    }\n\t\n\t    attachTo.setImmediate = setImmediate;\n\t    attachTo.clearImmediate = clearImmediate;\n\t}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(234)))\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// guide/contrast.js","import { Root, bindView, observable, action } from 'react-mobx-vm'\nimport View from './View'\n\n@bindView(View)\nexport default class Todo extends Root {\n  @observable id = Math.random()\n  @observable title = ''\n  @observable finished = false\n  @action toggle() {\n    this.finished = !this.finished\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./docs/snippets/vm/Todo/index.js","import { observer } from 'mobx-react';\nimport * as React from 'react';\n\nexport const Todo = observer(({ todo }) =>\n  <li>\n    <input\n      type=\"checkbox\"\n      checked={todo.finished}\n      onClick={todo.toggle}\n    />\n    {todo.title}\n  </li>,\n);\n\n\n\n// WEBPACK FOOTER //\n// ./docs/snippets/mst/components/Todo.js","import { observable } from 'mobx'\nimport { observer } from 'mobx-react'\nimport * as React from 'react'\n\nimport { Todo } from './Todo'\n\n@observer\nexport class TodoList extends React.Component {\n  @observable newTodoTitle = ''\n\n  render() {\n    const { todoStore } = this.props\n    return (\n      <div>\n        <input value={this.newTodoTitle} onChange={this.handleChange}/>\n        <button onClick={this.handleNewTodoClick}>Add</button>\n        <ul>\n          {todoStore.todos.map(todo => <Todo todo={todo} key={todo.id}/>)}\n        </ul>\n        Tasks left: {todoStore.unfinishedTodoCount}\n      </div>\n    )\n  }\n\n  handleChange = (e) => {\n    this.newTodoTitle = e.target.value\n  }\n\n  handleNewTodoClick = (e) => {\n    e.stopPropagation()\n    this.props.todoStore.addTodo(this.newTodoTitle)\n    this.newTodoTitle = ''\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./docs/snippets/mst/components/TodoList.js","import { types } from 'mobx-state-tree'\n\nexport const Todo = types\n  .model('Todo', {\n    id: types.optional(types.number, () => Math.random()),\n    title: types.string,\n    finished: false\n  })\n  .actions(self => (\n    {\n      toggle() {\n        self.finished = !self.finished\n      }\n    }\n  ))\n\nexport const TodoStore = types\n  .model('TodoStore', {\n    todos: types.array(Todo)\n  })\n  .views(self => (\n    {\n      get unfinishedTodoCount() {\n        return self.todos.filter(todo => !todo.finished).length\n      }\n    }\n  ))\n  .actions(self => (\n    {\n      addTodo(title) {\n        self.todos.push({ title })\n      }\n    }\n  ))\n\n\n\n// WEBPACK FOOTER //\n// ./docs/snippets/mst/models/TodoStore.js","import {\n  stateless\n} from 'react-mobx-vm'\nimport * as React from 'react'\n\nexport default stateless(local =>\n  <li>\n    <input\n      type=\"checkbox\"\n      checked={local.finished}\n      onClick={local.toggle.bind(local)}\n    />\n    {local.title}\n  </li>\n)\n\n\n\n\n// WEBPACK FOOTER //\n// ./docs/snippets/vm/Todo/View.js","import { h, binding } from 'react-mobx-vm'\nimport * as React from 'react'\n\n@binding\nexport default class TodoList extends React.Component {\n\n  render() {\n    const todoStore = this.local\n    return (\n      <div>\n        <input data-bind=\"newTodoTitle\" />\n        <button onClick={this.handleNewTodoClick}>Add</button>\n        <ul>\n          {todoStore.todos.map(todo => h(todo, { key: todo.id }))}\n        </ul>\n        Tasks left: {todoStore.unfinishedTodoCount}\n      </div>\n    )\n  }\n\n  handleNewTodoClick = (e) => {\n    e.stopPropagation()\n    this.local.addTodo(this.newTodoTitle)\n    this.local.newTodoTitle = ''\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./docs/snippets/vm/TodoList/View.js","import {\n  Root,\n  bindView,\n  observable,\n  computed,\n  action\n} from 'react-mobx-vm'\nimport View from './View'\n\nimport Todo from '../Todo'\n\n@bindView(View)\nexport default class TodoList extends Root {\n  @observable todos = []\n  @observable newTodoTitle = ''\n  @computed get unfinishedTodoCount() {\n    return this.todos.filter(todo => !todo.finished).length\n  }\n  @action addTodo() {\n    this.todos.push(Todo.create({ title: this.newTodoTitle }))\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./docs/snippets/vm/TodoList/index.js","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmeidate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n\n\n// WEBPACK FOOTER //\n// ../~/picidae/~/timers-browserify/main.js","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar mobx = require('mobx');\n\n/**\n * Returns the _actual_ type of the given tree node. (Or throws)\n *\n * @export\n * @param {IStateTreeNode} object\n * @returns {IType<S, T>}\n */\nfunction getType$$1(object) {\n    return getStateTreeNode$$1(object).type;\n}\n/**\n * Returns the _declared_ type of the given sub property of an object, array or map.\n *\n * @example\n * const Box = types.model({ x: 0, y: 0 })\n * const box = Box.create()\n *\n * console.log(getChildType(box, \"x\").name) // 'number'\n *\n * @export\n * @param {IStateTreeNode} object\n * @param {string} child\n * @returns {IType<any, any>}\n */\nfunction getChildType$$1(object, child) {\n    return getStateTreeNode$$1(object).getChildType(child);\n}\n/**\n * Registers a function that will be invoked for each mutation that is applied to the provided model instance, or to any of its children.\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details. onPatch events are emitted immediately and will not await the end of a transaction.\n * Patches can be used to deep observe a model tree.\n *\n * @export\n * @param {Object} target the model instance from which to receive patches\n * @param {(patch: IJsonPatch, reversePatch) => void} callback the callback that is invoked for each patch. The reversePatch is a patch that would actually undo the emitted patch\n * @param {includeOldValue} boolean if oldValue is included in the patches, they can be inverted. However patches will become much bigger and might not be suitable for efficient transport\n * @returns {IDisposer} function to remove the listener\n */\nfunction onPatch$$1(target, callback) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (typeof callback !== \"function\")\n            fail(\"expected second argument to be a function, got \" + callback + \" instead\");\n    }\n    return getStateTreeNode$$1(target).onPatch(callback);\n}\n/**\n * Registers a function that is invoked whenever a new snapshot for the given model instance is available.\n * The listener will only be fire at the and of the current MobX (trans)action.\n * See [snapshots](https://github.com/mobxjs/mobx-state-tree#snapshots) for more details.\n *\n * @export\n * @param {Object} target\n * @param {(snapshot: any) => void} callback\n * @returns {IDisposer}\n */\nfunction onSnapshot$$1(target, callback) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (typeof callback !== \"function\")\n            fail(\"expected second argument to be a function, got \" + callback + \" instead\");\n    }\n    return getStateTreeNode$$1(target).onSnapshot(callback);\n}\n/**\n * Applies a JSON-patch to the given model instance or bails out if the patch couldn't be applied\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details.\n *\n * Can apply a single past, or an array of patches.\n *\n * @export\n * @param {Object} target\n * @param {IJsonPatch} patch\n * @returns\n */\nfunction applyPatch$$1(target, patch) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (typeof patch !== \"object\")\n            fail(\"expected second argument to be an object or array, got \" + patch + \" instead\");\n    }\n    getStateTreeNode$$1(target).applyPatches(asArray(patch));\n}\n/**\n * Small abstraction around `onPatch` and `applyPatch`, attaches a patch listener to a tree and records all the patches.\n * Returns an recorder object with the following signature:\n *\n * @example\n * export interface IPatchRecorder {\n *      // the recorded patches\n *      patches: IJsonPatch[]\n *      // the inverse of the recorded patches\n *      inversePatches: IJsonPatch[]\n *      // stop recording patches\n *      stop(target?: IStateTreeNode): any\n *      // resume recording patches\n *      resume()\n *      // apply all the recorded patches on the given target (the original subject if omitted)\n *      replay(target?: IStateTreeNode): any\n *      // reverse apply the recorded patches on the given target  (the original subject if omitted)\n *      // stops the recorder if not already stopped\n *      undo(): void\n * }\n *\n * @export\n * @param {IStateTreeNode} subject\n * @returns {IPatchRecorder}\n */\nfunction recordPatches$$1(subject) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(subject))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + subject + \" instead\");\n    }\n    var disposer = null;\n    function resume() {\n        if (disposer)\n            return;\n        disposer = onPatch$$1(subject, function (patch, inversePatch) {\n            recorder.rawPatches.push([patch, inversePatch]);\n        });\n    }\n    var recorder = {\n        rawPatches: [],\n        get patches() {\n            return this.rawPatches.map(function (_a) {\n                var a = _a[0];\n                return a;\n            });\n        },\n        get inversePatches() {\n            return this.rawPatches.map(function (_a) {\n                var _ = _a[0], b = _a[1];\n                return b;\n            });\n        },\n        stop: function () {\n            if (disposer)\n                disposer();\n            disposer = null;\n        },\n        resume: resume,\n        replay: function (target) {\n            applyPatch$$1(target || subject, recorder.patches);\n        },\n        undo: function (target) {\n            applyPatch$$1(target || subject, recorder.inversePatches.slice().reverse());\n        }\n    };\n    resume();\n    return recorder;\n}\n/**\n * The inverse of `unprotect`\n *\n * @export\n * @param {IStateTreeNode} target\n *\n */\nfunction protect$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    var node = getStateTreeNode$$1(target);\n    if (!node.isRoot)\n        fail(\"`protect` can only be invoked on root nodes\");\n    node.isProtectionEnabled = true;\n}\n/**\n * By default it is not allowed to directly modify a model. Models can only be modified through actions.\n * However, in some cases you don't care about the advantages (like replayability, traceability, etc) this yields.\n * For example because you are building a PoC or don't have any middleware attached to your tree.\n *\n * In that case you can disable this protection by calling `unprotect` on the root of your tree.\n *\n * @example\n * const Todo = types.model({\n *     done: false\n * }).actions(self => ({\n *     toggle() {\n *         self.done = !self.done\n *     }\n * }))\n *\n * const todo = Todo.create()\n * todo.done = true // throws!\n * todo.toggle() // OK\n * unprotect(todo)\n * todo.done = false // OK\n */\nfunction unprotect$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    var node = getStateTreeNode$$1(target);\n    if (!node.isRoot)\n        fail(\"`unprotect` can only be invoked on root nodes\");\n    node.isProtectionEnabled = false;\n}\n/**\n * Returns true if the object is in protected mode, @see protect\n */\nfunction isProtected$$1(target) {\n    return getStateTreeNode$$1(target).isProtected;\n}\n/**\n * Applies a snapshot to a given model instances. Patch and snapshot listeners will be invoked as usual.\n *\n * @export\n * @param {Object} target\n * @param {Object} snapshot\n * @returns\n */\nfunction applySnapshot$$1(target, snapshot) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    return getStateTreeNode$$1(target).applySnapshot(snapshot);\n}\n/**\n * Calculates a snapshot from the given model instance. The snapshot will always reflect the latest state but use\n * structural sharing where possible. Doesn't require MobX transactions to be completed.\n *\n * @export\n * @param {Object} target\n * @returns {*}\n */\nfunction getSnapshot$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    return getStateTreeNode$$1(target).snapshot;\n}\n/**\n * Given a model instance, returns `true` if the object has a parent, that is, is part of another object, map or array\n *\n * @export\n * @param {Object} target\n * @param {number} depth = 1, how far should we look upward?\n * @returns {boolean}\n */\nfunction hasParent$$1(target, depth) {\n    if (depth === void 0) { depth = 1; }\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (typeof depth !== \"number\")\n            fail(\"expected second argument to be a number, got \" + depth + \" instead\");\n        if (depth < 0)\n            fail(\"Invalid depth: \" + depth + \", should be >= 1\");\n    }\n    var parent = getStateTreeNode$$1(target).parent;\n    while (parent) {\n        if (--depth === 0)\n            return true;\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the immediate parent of this object, or null.\n *\n * Note that the immediate parent can be either an object, map or array, and\n * doesn't necessarily refer to the parent model\n *\n * @export\n * @param {Object} target\n * @param {number} depth = 1, how far should we look upward?\n * @returns {*}\n */\nfunction getParent$$1(target, depth) {\n    if (depth === void 0) { depth = 1; }\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (typeof depth !== \"number\")\n            fail(\"expected second argument to be a number, got \" + depth + \" instead\");\n        if (depth < 0)\n            fail(\"Invalid depth: \" + depth + \", should be >= 1\");\n    }\n    var d = depth;\n    var parent = getStateTreeNode$$1(target).parent;\n    while (parent) {\n        if (--d === 0)\n            return parent.storedValue;\n        parent = parent.parent;\n    }\n    return fail(\"Failed to find the parent of \" + getStateTreeNode$$1(target) + \" at depth \" + depth);\n}\n/**\n * Given an object in a model tree, returns the root object of that tree\n *\n * @export\n * @param {Object} target\n * @returns {*}\n */\nfunction getRoot$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    return getStateTreeNode$$1(target).root.storedValue;\n}\n/**\n * Returns the path of the given object in the model tree\n *\n * @export\n * @param {Object} target\n * @returns {string}\n */\nfunction getPath$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    return getStateTreeNode$$1(target).path;\n}\n/**\n * Returns the path of the given object as unescaped string array\n *\n * @export\n * @param {Object} target\n * @returns {string[]}\n */\nfunction getPathParts$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    return splitJsonPath$$1(getStateTreeNode$$1(target).path);\n}\n/**\n * Returns true if the given object is the root of a model tree\n *\n * @export\n * @param {Object} target\n * @returns {boolean}\n */\nfunction isRoot$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    return getStateTreeNode$$1(target).isRoot;\n}\n/**\n * Resolves a path relatively to a given object.\n * Returns undefined if no value can be found.\n *\n * @export\n * @param {Object} target\n * @param {string} path - escaped json path\n * @returns {*}\n */\nfunction resolvePath$$1(target, path) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (typeof path !== \"string\")\n            fail(\"expected second argument to be a number, got \" + path + \" instead\");\n    }\n    var node = resolveNodeByPath$$1(getStateTreeNode$$1(target), path);\n    return node ? node.value : undefined;\n}\n/**\n * Resolves a model instance given a root target, the type and the identifier you are searching for.\n * Returns undefined if no value can be found.\n *\n * @export\n * @param {IType<any, any>} type\n * @param {IStateTreeNode} target\n * @param {(string | number)} identifier\n * @returns {*}\n */\nfunction resolveIdentifier$$1(type, target, identifier$$1) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isType$$1(type))\n            fail(\"expected first argument to be a mobx-state-tree type, got \" + type + \" instead\");\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected second argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (!(typeof identifier$$1 === \"string\" || typeof identifier$$1 === \"number\"))\n            fail(\"expected third argument to be a string or number, got \" + identifier$$1 + \" instead\");\n    }\n    var node = getStateTreeNode$$1(target).root.identifierCache.resolve(type, \"\" + identifier$$1);\n    return node ? node.value : undefined;\n}\n/**\n *\n *\n * @export\n * @param {Object} target\n * @param {string} path\n * @returns {*}\n */\nfunction tryResolve$$1(target, path) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (typeof path !== \"string\")\n            fail(\"expected second argument to be a string, got \" + path + \" instead\");\n    }\n    var node = resolveNodeByPath$$1(getStateTreeNode$$1(target), path, false);\n    if (node === undefined)\n        return undefined;\n    return node ? node.value : undefined;\n}\n/**\n * Given two state tree nodes that are part of the same tree,\n * returns the shortest jsonpath needed to navigate from the one to the other\n *\n * @export\n * @param {IStateTreeNode} base\n * @param {IStateTreeNode} target\n * @returns {string}\n */\nfunction getRelativePath$$1(base, target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected second argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (!isStateTreeNode$$1(base))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + base + \" instead\");\n    }\n    return getRelativePathBetweenNodes$$1(getStateTreeNode$$1(base), getStateTreeNode$$1(target));\n}\n/**\n * Returns a deep copy of the given state tree node as new tree.\n * Short hand for `snapshot(x) = getType(x).create(getSnapshot(x))`\n *\n * _Tip: clone will create a literal copy, including the same identifiers. To modify identifiers etc during cloning, don't use clone but take a snapshot of the tree, modify it, and create new instance_\n *\n * @export\n * @template T\n * @param {T} source\n * @param {boolean | any} keepEnvironment indicates whether the clone should inherit the same environment (`true`, the default), or not have an environment (`false`). If an object is passed in as second argument, that will act as the environment for the cloned tree.\n * @returns {T}\n */\nfunction clone$$1(source, keepEnvironment) {\n    if (keepEnvironment === void 0) { keepEnvironment = true; }\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(source))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + source + \" instead\");\n    }\n    var node = getStateTreeNode$$1(source);\n    return node.type.create(node.snapshot, keepEnvironment === true\n        ? node.root._environment\n        : keepEnvironment === false ? undefined : keepEnvironment); // it's an object or something else\n}\n/**\n * Removes a model element from the state tree, and let it live on as a new state tree\n */\nfunction detach$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    getStateTreeNode$$1(target).detach();\n    return target;\n}\n/**\n * Removes a model element from the state tree, and mark it as end-of-life; the element should not be used anymore\n */\nfunction destroy$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    var node = getStateTreeNode$$1(target);\n    if (node.isRoot)\n        node.die();\n    else\n        node.parent.removeChild(node.subpath);\n}\n/**\n * Returns true if the given state tree node is not killed yet.\n * This means that the node is still a part of a tree, and that `destroy`\n * has not been called. If a node is not alive anymore, the only thing one can do with it\n * is requesting it's last path and snapshot\n *\n * @export\n * @param {IStateTreeNode} target\n * @returns {boolean}\n */\nfunction isAlive$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    return getStateTreeNode$$1(target).isAlive;\n}\n/**\n * Use this utility to register a function that should be called whenever the\n * targeted state tree node is destroyed. This is a useful alternative to managing\n * cleanup methods yourself using the `beforeDestroy` hook.\n *\n * @example\n * const Todo = types.model({\n *   title: types.string\n * }).actions(self => ({\n *   afterCreate() {\n *     const autoSaveDisposer = reaction(\n *       () => getSnapshot(self),\n *       snapshot => sendSnapshotToServerSomehow(snapshot)\n *     )\n *     // stop sending updates to server if this\n *     // instance is destroyed\n *     addDisposer(self, autoSaveDisposer)\n *   }\n * }))\n *\n * @export\n * @param {IStateTreeNode} target\n * @param {() => void} disposer\n */\nfunction addDisposer$$1(target, disposer) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (typeof disposer !== \"function\")\n            fail(\"expected second argument to be a function, got \" + disposer + \" instead\");\n    }\n    getStateTreeNode$$1(target).addDisposer(disposer);\n}\n/**\n * Returns the environment of the current state tree. For more info on environments,\n * see [Dependency injection](https://github.com/mobxjs/mobx-state-tree#dependency-injection)\n *\n * Returns an empty environment if the tree wasn't initialized with an environment\n *\n * @export\n * @param {IStateTreeNode} target\n * @returns {*}\n */\nfunction getEnv$$1(target) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n    }\n    var node = getStateTreeNode$$1(target);\n    var env = node.root._environment;\n    if (!!!env)\n        return EMPTY_OBJECT;\n    return env;\n}\n/**\n * Performs a depth first walk through a tree\n */\nfunction walk$$1(target, processor) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (typeof processor !== \"function\")\n            fail(\"expected second argument to be a function, got \" + processor + \" instead\");\n    }\n    var node = getStateTreeNode$$1(target);\n    // tslint:disable-next-line:no_unused-variable\n    node.getChildren().forEach(function (child) {\n        if (isStateTreeNode$$1(child.storedValue))\n            walk$$1(child.storedValue, processor);\n    });\n    processor(node.storedValue);\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\n\nvar ScalarNode$$1 = /** @class */ (function () {\n    function ScalarNode$$1(type, parent, subpath, environment, initialValue, storedValue, canAttachTreeNode, finalizeNewInstance) {\n        if (finalizeNewInstance === void 0) { finalizeNewInstance = noop; }\n        this.subpath = \"\";\n        this._environment = undefined;\n        this._autoUnbox = true; // unboxing is disabled when reading child nodes\n        this.state = NodeLifeCycle$$1.INITIALIZING;\n        this.type = type;\n        this.storedValue = storedValue;\n        this._parent = parent;\n        this.subpath = subpath;\n        this.storedValue = storedValue;\n        this._environment = environment;\n        this.unbox = this.unbox.bind(this);\n        if (canAttachTreeNode)\n            addHiddenFinalProp(this.storedValue, \"$treenode\", this);\n        var sawException = true;\n        try {\n            if (canAttachTreeNode)\n                addHiddenFinalProp(this.storedValue, \"toJSON\", toJSON$$1);\n            finalizeNewInstance(this, initialValue);\n            this.state = NodeLifeCycle$$1.CREATED;\n            sawException = false;\n        }\n        finally {\n            if (sawException) {\n                // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n                this.state = NodeLifeCycle$$1.DEAD;\n            }\n        }\n    }\n    Object.defineProperty(ScalarNode$$1.prototype, \"path\", {\n        /*\n         * Returnes (escaped) path representation as string\n         */\n        get: function () {\n            if (!this.parent)\n                return \"\";\n            return this.parent.path + \"/\" + escapeJsonPath$$1(this.subpath);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScalarNode$$1.prototype, \"isRoot\", {\n        get: function () {\n            return this.parent === null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScalarNode$$1.prototype, \"parent\", {\n        get: function () {\n            return this._parent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScalarNode$$1.prototype, \"root\", {\n        get: function () {\n            // future optimization: store root ref in the node and maintain it\n            if (!this._parent)\n                return fail(\"This scalar node is not part of a tree\");\n            return this._parent.root;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScalarNode$$1.prototype.setParent = function (newParent, subpath) {\n        if (subpath === void 0) { subpath = null; }\n        if (this.parent !== newParent)\n            fail(\"Cannot change parent of immutable node\");\n        if (this.subpath === subpath)\n            return;\n        this.subpath = subpath || \"\";\n    };\n    Object.defineProperty(ScalarNode$$1.prototype, \"value\", {\n        get: function () {\n            return this.type.getValue(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScalarNode$$1.prototype, \"snapshot\", {\n        get: function () {\n            var snapshot = this.type.getSnapshot(this);\n            // avoid any external modification in dev mode\n            if (process.env.NODE_ENV !== \"production\") {\n                return freeze(snapshot);\n            }\n            return snapshot;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ScalarNode$$1.prototype, \"isAlive\", {\n        get: function () {\n            return this.state !== NodeLifeCycle$$1.DEAD;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScalarNode$$1.prototype.unbox = function (childNode) {\n        if (childNode && this._autoUnbox === true)\n            return childNode.value;\n        return childNode;\n    };\n    ScalarNode$$1.prototype.toString = function () {\n        return this.type.name + \"@\" + (this.path || \"<root>\") + (this.isAlive ? \"\" : \"[dead]\");\n    };\n    ScalarNode$$1.prototype.die = function () {\n        this.state = NodeLifeCycle$$1.DEAD;\n    };\n    __decorate([\n        mobx.observable\n    ], ScalarNode$$1.prototype, \"subpath\", void 0);\n    return ScalarNode$$1;\n}());\n\nvar nextNodeId = 1;\nvar ObjectNode$$1 = /** @class */ (function () {\n    function ObjectNode$$1(type, parent, subpath, environment, initialValue, storedValue, canAttachTreeNode, finalizeNewInstance) {\n        if (finalizeNewInstance === void 0) { finalizeNewInstance = noop; }\n        var _this = this;\n        this.nodeId = ++nextNodeId;\n        this.subpath = \"\";\n        this._parent = null;\n        this._isRunningAction = false; // only relevant for root\n        this.isProtectionEnabled = true;\n        this.identifierAttribute = undefined; // not to be modified directly, only through model initialization\n        this._environment = undefined;\n        this._autoUnbox = true; // unboxing is disabled when reading child nodes\n        this.state = NodeLifeCycle$$1.INITIALIZING;\n        this.middlewares = EMPTY_ARRAY;\n        this.type = type;\n        this.storedValue = storedValue;\n        this._parent = parent;\n        this.subpath = subpath;\n        this._environment = environment;\n        this.unbox = this.unbox.bind(this);\n        this.preboot();\n        if (!parent)\n            this.identifierCache = new IdentifierCache$$1();\n        if (canAttachTreeNode)\n            addHiddenFinalProp(this.storedValue, \"$treenode\", this);\n        var sawException = true;\n        try {\n            if (canAttachTreeNode)\n                addHiddenFinalProp(this.storedValue, \"toJSON\", toJSON$$1);\n            this._isRunningAction = true;\n            finalizeNewInstance(this, initialValue);\n            this._isRunningAction = false;\n            if (parent)\n                parent.root.identifierCache.addNodeToCache(this);\n            else\n                this.identifierCache.addNodeToCache(this);\n            this.fireHook(\"afterCreate\");\n            this.state = NodeLifeCycle$$1.CREATED;\n            sawException = false;\n        }\n        finally {\n            if (sawException) {\n                // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n                this.state = NodeLifeCycle$$1.DEAD;\n            }\n        }\n        var snapshotDisposer = mobx.reaction(function () { return _this.snapshot; }, function (snapshot) {\n            _this.emitSnapshot(snapshot);\n        });\n        snapshotDisposer.onError(function (e) {\n            throw e;\n        });\n        this.addDisposer(snapshotDisposer);\n    }\n    Object.defineProperty(ObjectNode$$1.prototype, \"path\", {\n        /*\n         * Returnes (escaped) path representation as string\n         */\n        get: function () {\n            if (!this.parent)\n                return \"\";\n            return this.parent.path + \"/\" + escapeJsonPath$$1(this.subpath);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ObjectNode$$1.prototype, \"isRoot\", {\n        get: function () {\n            return this.parent === null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ObjectNode$$1.prototype, \"parent\", {\n        get: function () {\n            return this._parent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ObjectNode$$1.prototype, \"root\", {\n        // Optimization: make computed\n        get: function () {\n            var p, r = this;\n            while ((p = r.parent))\n                r = p;\n            return r;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObjectNode$$1.prototype.setParent = function (newParent, subpath) {\n        if (subpath === void 0) { subpath = null; }\n        if (this.parent === newParent && this.subpath === subpath)\n            return;\n        if (newParent) {\n            if (this._parent && newParent !== this._parent) {\n                fail(\"A node cannot exists twice in the state tree. Failed to add \" + this + \" to path '\" + newParent.path + \"/\" + subpath + \"'.\");\n            }\n            if (!this._parent && newParent.root === this) {\n                fail(\"A state tree is not allowed to contain itself. Cannot assign \" + this + \" to path '\" + newParent.path + \"/\" + subpath + \"'\");\n            }\n            if (!this._parent &&\n                !!this.root._environment &&\n                this.root._environment !== newParent.root._environment) {\n                fail(\"A state tree cannot be made part of another state tree as long as their environments are different.\");\n            }\n        }\n        if (this.parent && !newParent) {\n            this.die();\n        }\n        else {\n            this.subpath = subpath || \"\";\n            if (newParent && newParent !== this._parent) {\n                newParent.root.identifierCache.mergeCache(this);\n                this._parent = newParent;\n                this.fireHook(\"afterAttach\");\n            }\n        }\n    };\n    ObjectNode$$1.prototype.fireHook = function (name) {\n        var fn = this.storedValue && typeof this.storedValue === \"object\" && this.storedValue[name];\n        if (typeof fn === \"function\")\n            fn.apply(this.storedValue);\n    };\n    Object.defineProperty(ObjectNode$$1.prototype, \"value\", {\n        get: function () {\n            if (!this.isAlive)\n                return undefined;\n            return this.type.getValue(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ObjectNode$$1.prototype, \"snapshot\", {\n        get: function () {\n            if (!this.isAlive)\n                return undefined;\n            // advantage of using computed for a snapshot is that nicely respects transactions etc.\n            var snapshot = this.type.getSnapshot(this);\n            // avoid any external modification in dev mode\n            if (process.env.NODE_ENV !== \"production\") {\n                return freeze(snapshot);\n            }\n            return snapshot;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObjectNode$$1.prototype.isRunningAction = function () {\n        if (this._isRunningAction)\n            return true;\n        if (this.isRoot)\n            return false;\n        return this.parent.isRunningAction();\n    };\n    Object.defineProperty(ObjectNode$$1.prototype, \"identifier\", {\n        get: function () {\n            return this.identifierAttribute ? this.storedValue[this.identifierAttribute] : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ObjectNode$$1.prototype, \"isAlive\", {\n        get: function () {\n            return this.state !== NodeLifeCycle$$1.DEAD;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObjectNode$$1.prototype.assertAlive = function () {\n        if (!this.isAlive)\n            fail(this + \" cannot be used anymore as it has died; it has been removed from a state tree. If you want to remove an element from a tree and let it live on, use 'detach' or 'clone' the value\");\n    };\n    ObjectNode$$1.prototype.getChildNode = function (subpath) {\n        this.assertAlive();\n        this._autoUnbox = false;\n        var res = this.type.getChildNode(this, subpath);\n        this._autoUnbox = true;\n        return res;\n    };\n    ObjectNode$$1.prototype.getChildren = function () {\n        this.assertAlive();\n        this._autoUnbox = false;\n        var res = this.type.getChildren(this);\n        this._autoUnbox = true;\n        return res;\n    };\n    ObjectNode$$1.prototype.getChildType = function (key) {\n        return this.type.getChildType(key);\n    };\n    Object.defineProperty(ObjectNode$$1.prototype, \"isProtected\", {\n        get: function () {\n            return this.root.isProtectionEnabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObjectNode$$1.prototype.assertWritable = function () {\n        this.assertAlive();\n        if (!this.isRunningAction() && this.isProtected) {\n            fail(\"Cannot modify '\" + this + \"', the object is protected and can only be modified by using an action.\");\n        }\n    };\n    ObjectNode$$1.prototype.removeChild = function (subpath) {\n        this.type.removeChild(this, subpath);\n    };\n    ObjectNode$$1.prototype.unbox = function (childNode) {\n        if (childNode && this._autoUnbox === true)\n            return childNode.value;\n        return childNode;\n    };\n    ObjectNode$$1.prototype.toString = function () {\n        var identifier$$1 = this.identifier ? \"(id: \" + this.identifier + \")\" : \"\";\n        return this.type.name + \"@\" + (this.path || \"<root>\") + identifier$$1 + (this.isAlive\n            ? \"\"\n            : \"[dead]\");\n    };\n    ObjectNode$$1.prototype.finalizeCreation = function () {\n        // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already\n        if (this.state === NodeLifeCycle$$1.CREATED) {\n            if (this.parent) {\n                if (this.parent.state !== NodeLifeCycle$$1.FINALIZED) {\n                    // parent not ready yet, postpone\n                    return;\n                }\n                this.fireHook(\"afterAttach\");\n            }\n            this.state = NodeLifeCycle$$1.FINALIZED;\n            for (var _i = 0, _a = this.getChildren(); _i < _a.length; _i++) {\n                var child = _a[_i];\n                if (child instanceof ObjectNode$$1)\n                    child.finalizeCreation();\n            }\n        }\n    };\n    ObjectNode$$1.prototype.detach = function () {\n        if (!this.isAlive)\n            fail(\"Error while detaching, node is not alive.\");\n        if (this.isRoot)\n            return;\n        else {\n            this.fireHook(\"beforeDetach\");\n            this._environment = this.root._environment; // make backup of environment\n            this.state = NodeLifeCycle$$1.DETACHING;\n            this.identifierCache = this.root.identifierCache.splitCache(this);\n            this.parent.removeChild(this.subpath);\n            this._parent = null;\n            this.subpath = \"\";\n            this.state = NodeLifeCycle$$1.FINALIZED;\n        }\n    };\n    ObjectNode$$1.prototype.preboot = function () {\n        var _this = this;\n        this.disposers = [];\n        this.middlewares = [];\n        this.snapshotSubscribers = [];\n        this.patchSubscribers = [];\n        // Optimization: this does not need to be done per instance\n        // if some pieces from createActionInvoker are extracted\n        this.applyPatches = createActionInvoker$$1(this.storedValue, \"@APPLY_PATCHES\", function (patches) {\n            patches.forEach(function (patch) {\n                var parts = splitJsonPath$$1(patch.path);\n                var node = resolveNodeByPathParts$$1(_this, parts.slice(0, -1));\n                node.applyPatchLocally(parts[parts.length - 1], patch);\n            });\n        }).bind(this.storedValue);\n        this.applySnapshot = createActionInvoker$$1(this.storedValue, \"@APPLY_SNAPSHOT\", function (snapshot) {\n            // if the snapshot is the same as the current one, avoid performing a reconcile\n            if (snapshot === _this.snapshot)\n                return;\n            // else, apply it by calling the type logic\n            return _this.type.applySnapshot(_this, snapshot);\n        }).bind(this.storedValue);\n    };\n    ObjectNode$$1.prototype.die = function () {\n        if (this.state === NodeLifeCycle$$1.DETACHING)\n            return;\n        if (isStateTreeNode$$1(this.storedValue)) {\n            // optimization: don't use walk, but getChildNodes for more efficiency\n            walk$$1(this.storedValue, function (child) {\n                var node = getStateTreeNode$$1(child);\n                if (node instanceof ObjectNode$$1)\n                    node.aboutToDie();\n            });\n            walk$$1(this.storedValue, function (child) {\n                var node = getStateTreeNode$$1(child);\n                if (node instanceof ObjectNode$$1)\n                    node.finalizeDeath();\n            });\n        }\n    };\n    ObjectNode$$1.prototype.aboutToDie = function () {\n        this.disposers.splice(0).forEach(function (f) { return f(); });\n        this.fireHook(\"beforeDestroy\");\n    };\n    ObjectNode$$1.prototype.finalizeDeath = function () {\n        // invariant: not called directly but from \"die\"\n        this.root.identifierCache.notifyDied(this);\n        var self = this;\n        var oldPath = this.path;\n        addReadOnlyProp(this, \"snapshot\", this.snapshot); // kill the computed prop and just store the last snapshot\n        this.patchSubscribers.splice(0);\n        this.snapshotSubscribers.splice(0);\n        this.patchSubscribers.splice(0);\n        this.state = NodeLifeCycle$$1.DEAD;\n        this._parent = null;\n        this.subpath = \"\";\n        // This is quite a hack, once interceptable objects / arrays / maps are extracted from mobx,\n        // we could express this in a much nicer way\n        // TODO: should be possible to obtain id's still...\n        Object.defineProperty(this.storedValue, \"$mobx\", {\n            get: function () {\n                fail(\"This object has died and is no longer part of a state tree. It cannot be used anymore. The object (of type '\" + self\n                    .type\n                    .name + \"') used to live at '\" + oldPath + \"'. It is possible to access the last snapshot of this object using 'getSnapshot', or to create a fresh copy using 'clone'. If you want to remove an object from the tree without killing it, use 'detach' instead.\");\n            }\n        });\n    };\n    ObjectNode$$1.prototype.onSnapshot = function (onChange) {\n        return registerEventHandler(this.snapshotSubscribers, onChange);\n    };\n    ObjectNode$$1.prototype.emitSnapshot = function (snapshot) {\n        this.snapshotSubscribers.forEach(function (f) { return f(snapshot); });\n    };\n    ObjectNode$$1.prototype.onPatch = function (handler) {\n        return registerEventHandler(this.patchSubscribers, handler);\n    };\n    ObjectNode$$1.prototype.emitPatch = function (basePatch, source) {\n        if (this.patchSubscribers.length) {\n            var localizedPatch = extend({}, basePatch, {\n                path: source.path.substr(this.path.length) + \"/\" + basePatch.path // calculate the relative path of the patch\n            });\n            var _a = splitPatch$$1(localizedPatch), patch_1 = _a[0], reversePatch_1 = _a[1];\n            this.patchSubscribers.forEach(function (f) { return f(patch_1, reversePatch_1); });\n        }\n        if (this.parent)\n            this.parent.emitPatch(basePatch, source);\n    };\n    ObjectNode$$1.prototype.addDisposer = function (disposer) {\n        this.disposers.unshift(disposer);\n    };\n    ObjectNode$$1.prototype.addMiddleWare = function (handler) {\n        return registerEventHandler(this.middlewares, handler);\n    };\n    ObjectNode$$1.prototype.applyPatchLocally = function (subpath, patch) {\n        this.assertWritable();\n        this.type.applyPatchLocally(this, subpath, patch);\n    };\n    __decorate([\n        mobx.observable\n    ], ObjectNode$$1.prototype, \"subpath\", void 0);\n    __decorate([\n        mobx.observable\n    ], ObjectNode$$1.prototype, \"_parent\", void 0);\n    __decorate([\n        mobx.computed\n    ], ObjectNode$$1.prototype, \"path\", null);\n    __decorate([\n        mobx.computed\n    ], ObjectNode$$1.prototype, \"value\", null);\n    __decorate([\n        mobx.computed\n    ], ObjectNode$$1.prototype, \"snapshot\", null);\n    return ObjectNode$$1;\n}());\n\nvar TypeFlags$$1;\n(function (TypeFlags$$1) {\n    TypeFlags$$1[TypeFlags$$1[\"String\"] = 1] = \"String\";\n    TypeFlags$$1[TypeFlags$$1[\"Number\"] = 2] = \"Number\";\n    TypeFlags$$1[TypeFlags$$1[\"Boolean\"] = 4] = \"Boolean\";\n    TypeFlags$$1[TypeFlags$$1[\"Date\"] = 8] = \"Date\";\n    TypeFlags$$1[TypeFlags$$1[\"Literal\"] = 16] = \"Literal\";\n    TypeFlags$$1[TypeFlags$$1[\"Array\"] = 32] = \"Array\";\n    TypeFlags$$1[TypeFlags$$1[\"Map\"] = 64] = \"Map\";\n    TypeFlags$$1[TypeFlags$$1[\"Object\"] = 128] = \"Object\";\n    TypeFlags$$1[TypeFlags$$1[\"Frozen\"] = 256] = \"Frozen\";\n    TypeFlags$$1[TypeFlags$$1[\"Optional\"] = 512] = \"Optional\";\n    TypeFlags$$1[TypeFlags$$1[\"Reference\"] = 1024] = \"Reference\";\n    TypeFlags$$1[TypeFlags$$1[\"Identifier\"] = 2048] = \"Identifier\";\n    TypeFlags$$1[TypeFlags$$1[\"Late\"] = 4096] = \"Late\";\n    TypeFlags$$1[TypeFlags$$1[\"Refinement\"] = 8192] = \"Refinement\";\n    TypeFlags$$1[TypeFlags$$1[\"Union\"] = 16384] = \"Union\";\n    TypeFlags$$1[TypeFlags$$1[\"Null\"] = 32768] = \"Null\";\n    TypeFlags$$1[TypeFlags$$1[\"Undefined\"] = 65536] = \"Undefined\";\n})(TypeFlags$$1 || (TypeFlags$$1 = {}));\n/*\n * A complex type produces a MST node (Node in the state tree)\n */\nvar ComplexType$$1 = /** @class */ (function () {\n    function ComplexType$$1(name) {\n        this.isType = true;\n        this.name = name;\n    }\n    ComplexType$$1.prototype.create = function (snapshot, environment) {\n        if (snapshot === void 0) { snapshot = this.getDefaultSnapshot(); }\n        typecheck$$1(this, snapshot);\n        return this.instantiate(null, \"\", environment, snapshot).value;\n    };\n    ComplexType$$1.prototype.isAssignableFrom = function (type) {\n        return type === this;\n    };\n    ComplexType$$1.prototype.validate = function (value, context) {\n        if (isStateTreeNode$$1(value)) {\n            return getType$$1(value) === this || this.isAssignableFrom(getType$$1(value))\n                ? typeCheckSuccess$$1()\n                : typeCheckFailure$$1(context, value);\n            // it is tempting to compare snapshots, but in that case we should always clone on assignments...\n        }\n        return this.isValidSnapshot(value, context);\n    };\n    ComplexType$$1.prototype.is = function (value) {\n        return this.validate(value, [{ path: \"\", type: this }]).length === 0;\n    };\n    ComplexType$$1.prototype.reconcile = function (current, newValue) {\n        if (current.snapshot === newValue)\n            // newValue is the current snapshot of the node, noop\n            return current;\n        if (isStateTreeNode$$1(newValue) && getStateTreeNode$$1(newValue) === current)\n            // the current node is the same as the new one\n            return current;\n        if (current.type === this &&\n            isMutable(newValue) &&\n            !isStateTreeNode$$1(newValue) &&\n            (!current.identifierAttribute ||\n                current.identifier === newValue[current.identifierAttribute])) {\n            // the newValue has no node, so can be treated like a snapshot\n            // we can reconcile\n            current.applySnapshot(newValue);\n            return current;\n        }\n        // current node cannot be recycled in any way\n        var parent = current.parent, subpath = current.subpath;\n        current.die();\n        // attempt to reuse the new one\n        if (isStateTreeNode$$1(newValue) && this.isAssignableFrom(getType$$1(newValue))) {\n            // newValue is a Node as well, move it here..\n            var newNode = getStateTreeNode$$1(newValue);\n            newNode.setParent(parent, subpath);\n            return newNode;\n        }\n        // nothing to do, we have to create a new node\n        return this.instantiate(parent, subpath, current._environment, newValue);\n    };\n    Object.defineProperty(ComplexType$$1.prototype, \"Type\", {\n        get: function () {\n            return fail(\"Factory.Type should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.Type`\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ComplexType$$1.prototype, \"SnapshotType\", {\n        get: function () {\n            return fail(\"Factory.SnapshotType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.SnapshotType`\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    __decorate([\n        mobx.action\n    ], ComplexType$$1.prototype, \"create\", null);\n    return ComplexType$$1;\n}());\nvar Type$$1 = /** @class */ (function (_super) {\n    __extends(Type$$1, _super);\n    function Type$$1(name) {\n        return _super.call(this, name) || this;\n    }\n    Type$$1.prototype.getValue = function (node) {\n        return node.storedValue;\n    };\n    Type$$1.prototype.getSnapshot = function (node) {\n        return node.storedValue;\n    };\n    Type$$1.prototype.getDefaultSnapshot = function () {\n        return undefined;\n    };\n    Type$$1.prototype.applySnapshot = function (node, snapshot) {\n        fail(\"Immutable types do not support applying snapshots\");\n    };\n    Type$$1.prototype.applyPatchLocally = function (node, subpath, patch) {\n        fail(\"Immutable types do not support applying patches\");\n    };\n    Type$$1.prototype.getChildren = function (node) {\n        return EMPTY_ARRAY;\n    };\n    Type$$1.prototype.getChildNode = function (node, key) {\n        return fail(\"No child '\" + key + \"' available in type: \" + this.name);\n    };\n    Type$$1.prototype.getChildType = function (key) {\n        return fail(\"No child '\" + key + \"' available in type: \" + this.name);\n    };\n    Type$$1.prototype.reconcile = function (current, newValue) {\n        // reconcile only if type and value are still the same\n        if (current.type === this && current.storedValue === newValue)\n            return current;\n        var res = this.instantiate(current.parent, current.subpath, current._environment, newValue);\n        current.die();\n        return res;\n    };\n    Type$$1.prototype.removeChild = function (node, subpath) {\n        return fail(\"No child '\" + subpath + \"' available in type: \" + this.name);\n    };\n    return Type$$1;\n}(ComplexType$$1));\nfunction isType$$1(value) {\n    return typeof value === \"object\" && value && value.isType === true;\n}\n\n/**\n * Convenience utility to create action based middleware that supports async processes more easily.\n * All hooks are called for both synchronous and asynchronous actions. Except that either `onSuccess` or `onFail` is called\n *\n * The create middleware tracks the process of an action (assuming it passes the `filter`).\n * `onResume` can return any value, which will be passed as second argument to any other hook. This makes it possible to keep state during a process.\n *\n * See the `atomic` middleware for an example\n *\n * @export\n * @template T\n * @template any\n * @param {{\n *     filter?: (call: IMiddlewareEvent) => boolean\n *     onStart: (call: IMiddlewareEvent) => T\n *     onResume: (call: IMiddlewareEvent, context: T) => void\n *     onSuspend: (call: IMiddlewareEvent, context: T) => void\n *     onSuccess: (call: IMiddlewareEvent, context: T, result: any) => void\n *     onFail: (call: IMiddlewareEvent, context: T, error: any) => void\n * }} hooks\n * @returns {IMiddlewareHandler}\n */\nfunction createActionTrackingMiddleware(hooks) {\n    var runningActions = new Map();\n    return function actionTrackingMiddleware(call, next) {\n        switch (call.type) {\n            case \"action\": {\n                if (!hooks.filter || hooks.filter(call) === true) {\n                    var context = hooks.onStart(call);\n                    hooks.onResume(call, context);\n                    runningActions.set(call.id, {\n                        call: call,\n                        context: context,\n                        async: false\n                    });\n                    try {\n                        var res = next(call);\n                        hooks.onSuspend(call, context);\n                        if (runningActions.get(call.id).async === false) {\n                            hooks.onSuccess(call, context, res);\n                        }\n                        return res;\n                    }\n                    catch (e) {\n                        hooks.onFail(call, context, e);\n                        throw e;\n                    }\n                }\n                else {\n                    return next(call);\n                }\n            }\n            case \"flow_spawn\": {\n                var root = runningActions.get(call.rootId);\n                root.async = true;\n                return next(call);\n            }\n            case \"flow_resume\":\n            case \"flow_resume_error\": {\n                var root = runningActions.get(call.rootId);\n                hooks.onResume(call, root.context);\n                try {\n                    return next(call);\n                }\n                finally {\n                    hooks.onSuspend(call, root.context);\n                }\n            }\n            case \"flow_throw\": {\n                var root = runningActions.get(call.rootId);\n                runningActions.delete(call.id);\n                hooks.onFail(call, root.context, call.args[0]);\n                return next(call);\n            }\n            case \"flow_return\": {\n                var root = runningActions.get(call.rootId);\n                runningActions.delete(call.id);\n                hooks.onSuccess(call, root.context, call.args[0]);\n                return next(call);\n            }\n        }\n    };\n}\n\nfunction serializeArgument(node, actionName, index, arg) {\n    if (arg instanceof Date)\n        return { $MST_DATE: arg.getTime() };\n    if (isPrimitive(arg))\n        return arg;\n    // We should not serialize MST nodes, even if we can, because we don't know if the receiving party can handle a raw snapshot instead of an\n    // MST type instance. So if one wants to serialize a MST node that was pass in, either explitly pass: 1: an id, 2: a (relative) path, 3: a snapshot\n    if (isStateTreeNode$$1(arg))\n        return serializeTheUnserializable(\"[MSTNode: \" + getType$$1(arg).name + \"]\");\n    if (typeof arg === \"function\")\n        return serializeTheUnserializable(\"[function]\");\n    if (typeof arg === \"object\" && !isPlainObject(arg) && !isArray(arg))\n        return serializeTheUnserializable(\"[object \" + ((arg && arg.constructor && arg.constructor.name) || \"Complex Object\") + \"]\");\n    try {\n        // Check if serializable, cycle free etc...\n        // MWE: there must be a better way....\n        JSON.stringify(arg); // or throws\n        return arg;\n    }\n    catch (e) {\n        return serializeTheUnserializable(\"\" + e);\n    }\n}\nfunction deserializeArgument(adm, value) {\n    if (value && typeof value === \"object\" && \"$MST_DATE\" in value)\n        return new Date(value[\"$MST_DATE\"]);\n    return value;\n}\nfunction serializeTheUnserializable(baseType) {\n    return {\n        $MST_UNSERIALIZABLE: true,\n        type: baseType\n    };\n}\n/**\n * Applies an action or a series of actions in a single MobX transaction.\n * Does not return any value\n * Takes an action description as produced by the `onAction` middleware.\n *\n * @export\n * @param {Object} target\n * @param {IActionCall[]} actions\n * @param {IActionCallOptions} [options]\n */\nfunction applyAction$$1(target, actions) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (typeof actions !== \"object\")\n            fail(\"expected second argument to be an object or array, got \" + actions + \" instead\");\n    }\n    mobx.runInAction(function () {\n        asArray(actions).forEach(function (action$$1) { return baseApplyAction(target, action$$1); });\n    });\n}\nfunction baseApplyAction(target, action$$1) {\n    var resolvedTarget = tryResolve$$1(target, action$$1.path || \"\");\n    if (!resolvedTarget)\n        return fail(\"Invalid action path: \" + (action$$1.path || \"\"));\n    var node = getStateTreeNode$$1(resolvedTarget);\n    // Reserved functions\n    if (action$$1.name === \"@APPLY_PATCHES\") {\n        return applyPatch$$1.call(null, resolvedTarget, action$$1.args[0]);\n    }\n    if (action$$1.name === \"@APPLY_SNAPSHOT\") {\n        return applySnapshot$$1.call(null, resolvedTarget, action$$1.args[0]);\n    }\n    if (!(typeof resolvedTarget[action$$1.name] === \"function\"))\n        fail(\"Action '\" + action$$1.name + \"' does not exist in '\" + node.path + \"'\");\n    return resolvedTarget[action$$1.name].apply(resolvedTarget, action$$1.args ? action$$1.args.map(function (v) { return deserializeArgument(node, v); }) : []);\n}\n/**\n * Small abstraction around `onAction` and `applyAction`, attaches an action listener to a tree and records all the actions emitted.\n * Returns an recorder object with the following signature:\n *\n * @example\n * export interface IActionRecorder {\n *      // the recorded actions\n *      actions: ISerializedActionCall[]\n *      // stop recording actions\n *      stop(): any\n *      // apply all the recorded actions on the given object\n *      replay(target: IStateTreeNode): any\n * }\n *\n * @export\n * @param {IStateTreeNode} subject\n * @returns {IPatchRecorder}\n */\nfunction recordActions$$1(subject) {\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(subject))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + subject + \" instead\");\n    }\n    var recorder = {\n        actions: [],\n        stop: function () { return disposer(); },\n        replay: function (target) {\n            applyAction$$1(target, recorder.actions);\n        }\n    };\n    var disposer = onAction$$1(subject, recorder.actions.push.bind(recorder.actions));\n    return recorder;\n}\n/**\n * Registers a function that will be invoked for each action that is called on the provided model instance, or to any of its children.\n * See [actions](https://github.com/mobxjs/mobx-state-tree#actions) for more details. onAction events are emitted only for the outermost called action in the stack.\n * Action can also be intercepted by middleware using addMiddleware to change the function call before it will be run.\n *\n * Not all action arguments might be serializable. For unserializable arguments, a struct like `{ $MST_UNSERIALIZABLE: true, type: \"someType\" }` will be generated.\n * MST Nodes are considered non-serializable as well (they could be serialized as there snapshot, but it is uncertain whether an replaying party will be able to handle such a non-instantiated snapshot).\n * Rather, when using `onAction` middleware, one should consider in passing arguments which are 1: an id, 2: a (relative) path, or 3: a snapshot. Instead of a real MST node.\n *\n * @example\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * }).actions(self => ({\n *   add(todo) {\n *     self.todos.push(todo);\n *   }\n * }))\n *\n * const s = TodoStore.create({ todos: [] })\n *\n * let disposer = onAction(s, (call) => {\n *   console.log(call);\n * })\n *\n * s.add({ task: \"Grab a coffee\" })\n * // Logs: { name: \"add\", path: \"\", args: [{ task: \"Grab a coffee\" }] }\n *\n * @export\n * @param {IStateTreeNode} target\n * @param {(call: ISerializedActionCall) => void} listener\n * @param attachAfter {boolean} (default false) fires the listener *after* the action has executed instead of before.\n * @returns {IDisposer}\n */\nfunction onAction$$1(target, listener, attachAfter) {\n    if (attachAfter === void 0) { attachAfter = false; }\n    // check all arguments\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isStateTreeNode$$1(target))\n            fail(\"expected first argument to be a mobx-state-tree node, got \" + target + \" instead\");\n        if (!isRoot$$1(target))\n            console.warn(\"[mobx-state-tree] Warning: Attaching onAction listeners to non root nodes is dangerous: No events will be emitted for actions initiated higher up in the tree.\");\n        if (!isProtected$$1(target))\n            console.warn(\"[mobx-state-tree] Warning: Attaching onAction listeners to non protected nodes is dangerous: No events will be emitted for direct modifications without action.\");\n    }\n    function fireListener(rawCall) {\n        if (rawCall.type === \"action\" && rawCall.id === rawCall.rootId) {\n            var sourceNode_1 = getStateTreeNode$$1(rawCall.context);\n            listener({\n                name: rawCall.name,\n                path: getRelativePathBetweenNodes$$1(getStateTreeNode$$1(target), sourceNode_1),\n                args: rawCall.args.map(function (arg, index) {\n                    return serializeArgument(sourceNode_1, rawCall.name, index, arg);\n                })\n            });\n        }\n    }\n    return addMiddleware$$1(target, attachAfter\n        ? function onActionMiddleware(rawCall, next) {\n            var res = next(rawCall);\n            fireListener(rawCall);\n            return res;\n        }\n        : function onActionMiddleware(rawCall, next) {\n            fireListener(rawCall);\n            return next(rawCall);\n        });\n}\n\nvar nextActionId = 1;\nvar currentActionContext = null;\nfunction getNextActionId$$1() {\n    return nextActionId++;\n}\nfunction runWithActionContext$$1(context, fn) {\n    var node = getStateTreeNode$$1(context.context);\n    var baseIsRunningAction = node._isRunningAction;\n    var prevContext = currentActionContext;\n    node.assertAlive();\n    node._isRunningAction = true;\n    currentActionContext = context;\n    try {\n        return runMiddleWares(node, context, fn);\n    }\n    finally {\n        currentActionContext = prevContext;\n        node._isRunningAction = baseIsRunningAction;\n    }\n}\nfunction getActionContext$$1() {\n    if (!currentActionContext)\n        return fail(\"Not running an action!\");\n    return currentActionContext;\n}\nfunction createActionInvoker$$1(target, name, fn) {\n    return function () {\n        var id = getNextActionId$$1();\n        return runWithActionContext$$1({\n            type: \"action\",\n            name: name,\n            id: id,\n            args: argsToArray(arguments),\n            context: target,\n            tree: getRoot$$1(target),\n            rootId: currentActionContext ? currentActionContext.rootId : id,\n            parentId: currentActionContext ? currentActionContext.id : 0\n        }, fn);\n    };\n}\n/**\n * Middleware can be used to intercept any action is invoked on the subtree where it is attached.\n * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.\n *\n * For more details, see the [middleware docs](docs/middleware.md)\n *\n * @export\n * @param {IStateTreeNode} target\n * @param {(action: IRawActionCall, next: (call: IRawActionCall) => any) => any} middleware\n * @returns {IDisposer}\n */\nfunction addMiddleware$$1(target, middleware) {\n    var node = getStateTreeNode$$1(target);\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!node.isProtectionEnabled)\n            console.warn(\"It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`\");\n    }\n    return node.addMiddleWare(middleware);\n}\n/**\n * Binds middleware to a specific action\n *\n * @example\n * type.actions(self => {\n *   function takeA____() {\n *       self.toilet.donate()\n *       self.wipe()\n *       self.wipe()\n *       self.toilet.flush()\n *   }\n *   return {\n *     takeA____: decorate(atomic, takeA____)\n *   }\n * })\n *\n * @export\n * @template T\n * @param {IMiddlewareHandler} middleware\n * @param Function} fn\n * @returns the original function\n */\nfunction decorate$$1(middleware, fn) {\n    if (fn.$mst_middleware)\n        fn.$mst_middleware.push(middleware);\n    else\n        fn.$mst_middleware = [middleware];\n    return fn;\n}\nfunction collectMiddlewareHandlers(node, baseCall, fn) {\n    var handlers = fn.$mst_middleware || EMPTY_ARRAY;\n    var n = node;\n    // Find all middlewares. Optimization: cache this?\n    while (n) {\n        if (n.middlewares)\n            handlers = handlers.concat(n.middlewares);\n        n = n.parent;\n    }\n    return handlers;\n}\nfunction runMiddleWares(node, baseCall, originalFn) {\n    var handlers = collectMiddlewareHandlers(node, baseCall, originalFn);\n    // Short circuit\n    if (!handlers.length)\n        return mobx.action(originalFn).apply(null, baseCall.args);\n    var index = 0;\n    function runNextMiddleware(call) {\n        var handler = handlers[index++];\n        if (handler)\n            return handler(call, runNextMiddleware);\n        else\n            return mobx.action(originalFn).apply(null, baseCall.args);\n    }\n    return runNextMiddleware(baseCall);\n}\n\nfunction safeStringify(value) {\n    try {\n        return JSON.stringify(value);\n    }\n    catch (e) {\n        return \"<Unserializable: \" + e + \">\";\n    }\n}\nfunction prettyPrintValue$$1(value) {\n    return typeof value === \"function\"\n        ? \"<function\" + (value.name ? \" \" + value.name : \"\") + \">\"\n        : isStateTreeNode$$1(value) ? \"<\" + value + \">\" : \"`\" + safeStringify(value) + \"`\";\n}\nfunction toErrorString(error) {\n    var value = error.value;\n    var type = error.context[error.context.length - 1].type;\n    var fullPath = error.context\n        .map(function (_a) {\n        var path = _a.path;\n        return path;\n    })\n        .filter(function (path) { return path.length > 0; })\n        .join(\"/\");\n    var pathPrefix = fullPath.length > 0 ? \"at path \\\"/\" + fullPath + \"\\\" \" : \"\";\n    var currentTypename = isStateTreeNode$$1(value)\n        ? \"value of type \" + getStateTreeNode$$1(value).type.name + \":\"\n        : isPrimitive(value) ? \"value\" : \"snapshot\";\n    var isSnapshotCompatible = type && isStateTreeNode$$1(value) && type.is(getStateTreeNode$$1(value).snapshot);\n    return (\"\" + pathPrefix + currentTypename + \" \" + prettyPrintValue$$1(value) + \" is not assignable \" + (type\n        ? \"to type: `\" + type.name + \"`\"\n        : \"\") +\n        (error.message ? \" (\" + error.message + \")\" : \"\") +\n        (type\n            ? isPrimitiveType$$1(type)\n                ? \".\"\n                : \", expected an instance of `\" + type.name + \"` or a snapshot like `\" + type.describe() + \"` instead.\" +\n                    (isSnapshotCompatible\n                        ? \" (Note that a snapshot of the provided value is compatible with the targeted type)\"\n                        : \"\")\n            : \".\"));\n}\n\nfunction getContextForPath$$1(context, path, type) {\n    return context.concat([{ path: path, type: type }]);\n}\nfunction typeCheckSuccess$$1() {\n    return EMPTY_ARRAY;\n}\nfunction typeCheckFailure$$1(context, value, message) {\n    return [{ context: context, value: value, message: message }];\n}\nfunction flattenTypeErrors$$1(errors) {\n    return errors.reduce(function (a, i) { return a.concat(i); }, []);\n}\n// TODO; doublecheck: typecheck should only needed to be invoked from: type.create and array / map / value.property will change\nfunction typecheck$$1(type, value) {\n    // if not in dev-mode, do not even try to run typecheck. Everything is developer fault!\n    if (process.env.NODE_ENV === \"production\")\n        return;\n    typecheckPublic$$1(type, value);\n}\n/**\n * Run's the typechecker on the given type.\n * Throws if the given value is not according the provided type specification.\n * Use this if you need typechecks even in a production build (by default all automatic runtime type checks will be skipped in production builds)\n *\n * @alias typecheck\n * @export\n * @param {IType<any, any>} type\n * @param {*} value\n */\nfunction typecheckPublic$$1(type, value) {\n    var errors = type.validate(value, [{ path: \"\", type: type }]);\n    if (errors.length > 0) {\n        fail(\"Error while converting \" + prettyPrintValue$$1(value) + \" to `\" + type.name + \"`:\\n\" +\n            errors.map(toErrorString).join(\"\\n\"));\n    }\n}\n\nvar IdentifierCache$$1 = /** @class */ (function () {\n    function IdentifierCache$$1() {\n        this.cache = mobx.observable.map();\n    }\n    IdentifierCache$$1.prototype.addNodeToCache = function (node) {\n        if (node.identifierAttribute) {\n            var identifier$$1 = node.identifier;\n            if (!this.cache.has(identifier$$1)) {\n                this.cache.set(identifier$$1, mobx.observable.shallowArray());\n            }\n            var set = this.cache.get(identifier$$1);\n            if (set.indexOf(node) !== -1)\n                fail(\"Already registered\");\n            set.push(node);\n        }\n        return this;\n    };\n    IdentifierCache$$1.prototype.mergeCache = function (node) {\n        var _this = this;\n        node.identifierCache.cache.values().forEach(function (nodes) {\n            return nodes.forEach(function (child) {\n                _this.addNodeToCache(child);\n            });\n        });\n    };\n    IdentifierCache$$1.prototype.notifyDied = function (node) {\n        if (node.identifierAttribute) {\n            var set = this.cache.get(node.identifier);\n            if (set)\n                set.remove(node);\n        }\n    };\n    IdentifierCache$$1.prototype.splitCache = function (node) {\n        var res = new IdentifierCache$$1();\n        var basePath = node.path;\n        this.cache.values().forEach(function (nodes) {\n            for (var i = nodes.length - 1; i >= 0; i--) {\n                if (nodes[i].path.indexOf(basePath) === 0) {\n                    res.addNodeToCache(nodes[i]);\n                    nodes.splice(i, 1);\n                }\n            }\n        });\n        return res;\n    };\n    IdentifierCache$$1.prototype.resolve = function (type, identifier$$1) {\n        var set = this.cache.get(identifier$$1);\n        if (!set)\n            return null;\n        var matches = set.filter(function (candidate) { return type.isAssignableFrom(candidate.type); });\n        switch (matches.length) {\n            case 0:\n                return null;\n            case 1:\n                return matches[0];\n            default:\n                return fail(\"Cannot resolve a reference to type '\" + type.name + \"' with id: '\" + identifier$$1 + \"' unambigously, there are multiple candidates: \" + matches\n                    .map(function (n) { return n.path; })\n                    .join(\", \"));\n        }\n    };\n    return IdentifierCache$$1;\n}());\n\n// TODO: split into object and scalar node?\nfunction createNode$$1(type, parent, subpath, environment, initialValue, createNewInstance, finalizeNewInstance) {\n    if (createNewInstance === void 0) { createNewInstance = identity; }\n    if (finalizeNewInstance === void 0) { finalizeNewInstance = noop; }\n    if (isStateTreeNode$$1(initialValue)) {\n        var targetNode = initialValue.$treenode;\n        if (!targetNode.isRoot)\n            fail(\"Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '\" + (parent\n                ? parent.path\n                : \"\") + \"/\" + subpath + \"', but it lives already at '\" + targetNode.path + \"'\");\n        targetNode.setParent(parent, subpath);\n        return targetNode;\n    }\n    var storedValue = createNewInstance(initialValue);\n    if (type.shouldAttachNode) {\n        var node = new ObjectNode$$1(type, parent, subpath, environment, initialValue, storedValue, type.shouldAttachNode, finalizeNewInstance);\n        node.finalizeCreation();\n        return node;\n    }\n    return new ScalarNode$$1(type, parent, subpath, environment, initialValue, storedValue, type.shouldAttachNode, finalizeNewInstance);\n}\nfunction isNode$$1(value) {\n    return value instanceof ScalarNode$$1 || value instanceof ObjectNode$$1;\n}\n\nvar NodeLifeCycle$$1;\n(function (NodeLifeCycle$$1) {\n    NodeLifeCycle$$1[NodeLifeCycle$$1[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n    NodeLifeCycle$$1[NodeLifeCycle$$1[\"CREATED\"] = 1] = \"CREATED\";\n    NodeLifeCycle$$1[NodeLifeCycle$$1[\"FINALIZED\"] = 2] = \"FINALIZED\";\n    NodeLifeCycle$$1[NodeLifeCycle$$1[\"DETACHING\"] = 3] = \"DETACHING\";\n    NodeLifeCycle$$1[NodeLifeCycle$$1[\"DEAD\"] = 4] = \"DEAD\"; // no coming back from this one\n})(NodeLifeCycle$$1 || (NodeLifeCycle$$1 = {}));\n/**\n * Returns true if the given value is a node in a state tree.\n * More precisely, that is, if the value is an instance of a\n * `types.model`, `types.array` or `types.map`.\n *\n * @export\n * @param {*} value\n * @returns {value is IStateTreeNode}\n */\nfunction isStateTreeNode$$1(value) {\n    return !!(value && value.$treenode);\n}\nfunction getStateTreeNode$$1(value) {\n    if (isStateTreeNode$$1(value))\n        return value.$treenode;\n    else\n        return fail(\"Value \" + value + \" is no MST Node\");\n}\n\nfunction toJSON$$1() {\n    return getStateTreeNode$$1(this).snapshot;\n}\nvar doubleDot = function (_) { return \"..\"; };\nfunction getRelativePathBetweenNodes$$1(base, target) {\n    // PRE condition target is (a child of) base!\n    if (base.root !== target.root)\n        fail(\"Cannot calculate relative path: objects '\" + base + \"' and '\" + target + \"' are not part of the same object tree\");\n    var baseParts = splitJsonPath$$1(base.path);\n    var targetParts = splitJsonPath$$1(target.path);\n    var common = 0;\n    for (; common < baseParts.length; common++) {\n        if (baseParts[common] !== targetParts[common])\n            break;\n    }\n    // TODO: assert that no targetParts paths are \"..\", \".\" or \"\"!\n    return (baseParts\n        .slice(common)\n        .map(doubleDot)\n        .join(\"/\") + joinJsonPath$$1(targetParts.slice(common)));\n}\nfunction resolveNodeByPath$$1(base, path, failIfResolveFails) {\n    if (failIfResolveFails === void 0) { failIfResolveFails = true; }\n    return resolveNodeByPathParts$$1(base, splitJsonPath$$1(path), failIfResolveFails);\n}\nfunction resolveNodeByPathParts$$1(base, pathParts, failIfResolveFails) {\n    if (failIfResolveFails === void 0) { failIfResolveFails = true; }\n    // counter part of getRelativePath\n    // note that `../` is not part of the JSON pointer spec, which is actually a prefix format\n    // in json pointer: \"\" = current, \"/a\", attribute a, \"/\" is attribute \"\" etc...\n    // so we treat leading ../ apart...\n    var current = base;\n    for (var i = 0; i < pathParts.length; i++) {\n        if (pathParts[i] === \"\")\n            current = current.root;\n        else if (pathParts[i] === \"..\")\n            current = current.parent;\n        else if (pathParts[i] === \".\" || pathParts[i] === \"\")\n            // '/bla' or 'a//b' splits to empty strings\n            continue;\n        else if (current) {\n            if (current instanceof ObjectNode$$1)\n                current = current.getChildNode(pathParts[i]);\n            else\n                return fail(\"Illegal state\");\n            continue;\n        }\n        if (!current) {\n            if (failIfResolveFails)\n                return fail(\"Could not resolve '\" + pathParts[i] + \"' in '\" + joinJsonPath$$1(pathParts.slice(0, i - 1)) + \"', path of the patch does not resolve\");\n            else\n                return undefined;\n        }\n    }\n    return current;\n}\n\n// based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts\n/*\n    All contents of this file are deprecated.\n\n    The term `process` has been replaced with `flow` to avoid conflicts with the\n    global `process` object.\n\n    Refer to `flow.ts` for any further changes to this implementation.\n*/\nvar DEPRECATION_MESSAGE = \"See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information. \" +\n    \"Note that the middleware event types starting with `process` now start with `flow`.\";\n/**\n * @deprecated has been renamed to `flow()`.\n * See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information.\n * Note that the middleware event types starting with `process` now start with `flow`.\n *\n * @export\n * @alias process\n * @returns {Promise}\n */\nfunction process$1$$1(asyncAction) {\n    deprecated(\"process\", \"`process()` has been renamed to `flow()`. \" + DEPRECATION_MESSAGE);\n    return flow(asyncAction);\n}\n\nvar EMPTY_ARRAY = Object.freeze([]);\nvar EMPTY_OBJECT = Object.freeze({});\nfunction fail(message) {\n    if (message === void 0) { message = \"Illegal state\"; }\n    throw new Error(\"[mobx-state-tree] \" + message);\n}\nfunction identity(_) {\n    return _;\n}\n\nfunction noop() { }\nfunction isArray(val) {\n    return !!(Array.isArray(val) || mobx.isObservableArray(val));\n}\nfunction asArray(val) {\n    if (!val)\n        return EMPTY_ARRAY;\n    if (isArray(val))\n        return val;\n    return [val];\n}\nfunction extend(a) {\n    var b = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        b[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < b.length; i++) {\n        var current = b[i];\n        for (var key in current)\n            a[key] = current[key];\n    }\n    return a;\n}\n\nfunction isPlainObject(value) {\n    if (value === null || typeof value !== \"object\")\n        return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction isMutable(value) {\n    return (value !== null &&\n        typeof value === \"object\" &&\n        !(value instanceof Date) &&\n        !(value instanceof RegExp));\n}\nfunction isPrimitive(value) {\n    if (value === null || value === undefined)\n        return true;\n    if (typeof value === \"string\" ||\n        typeof value === \"number\" ||\n        typeof value === \"boolean\" ||\n        value instanceof Date)\n        return true;\n    return false;\n}\nfunction freeze(value) {\n    return isPrimitive(value) ? value : Object.freeze(value);\n}\nfunction deepFreeze(value) {\n    freeze(value);\n    if (isPlainObject(value)) {\n        Object.keys(value).forEach(function (propKey) {\n            if (!isPrimitive(value[propKey]) &&\n                !Object.isFrozen(value[propKey])) {\n                deepFreeze(value[propKey]);\n            }\n        });\n    }\n    return value;\n}\nfunction isSerializable(value) {\n    return typeof value !== \"function\";\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\n\nfunction addReadOnlyProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: true,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction remove(collection, item) {\n    var idx = collection.indexOf(item);\n    if (idx !== -1)\n        collection.splice(idx, 1);\n}\nfunction registerEventHandler(handlers, handler) {\n    handlers.push(handler);\n    return function () {\n        remove(handlers, handler);\n    };\n}\n\nfunction argsToArray(args) {\n    var res = new Array(args.length);\n    for (var i = 0; i < args.length; i++)\n        res[i] = args[i];\n    return res;\n}\nvar deprecated = function () { };\ndeprecated = function (id, message) {\n    // skip if running production\n    if (process.env.NODE_ENV === \"production\")\n        return;\n    // warn if hasn't been warned before\n    if (deprecated.ids && !deprecated.ids.hasOwnProperty(id)) {\n        console.warn(\"[mobx-state-tree] Deprecation warning: \" + message);\n    }\n    // mark as warned to avoid duplicate warn message\n    if (deprecated.ids)\n        deprecated.ids[id] = true;\n};\ndeprecated.ids = {};\n\n// based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts\n/**\n * See [asynchronous actions](https://github.com/mobxjs/mobx-state-tree/blob/master/docs/async-actions.md).\n *\n * @export\n * @alias flow\n * @returns {Promise}\n */\nfunction flow(asyncAction) {\n    return createFlowSpawner(asyncAction.name, asyncAction);\n}\nfunction createFlowSpawner(name, generator) {\n    var spawner = function flowSpawner() {\n        // Implementation based on https://github.com/tj/co/blob/master/index.js\n        var runId = getNextActionId$$1();\n        var baseContext = getActionContext$$1();\n        var args = arguments;\n        function wrap(fn, type, arg) {\n            fn.$mst_middleware = spawner.$mst_middleware; // pick up any middleware attached to the flow\n            runWithActionContext$$1({\n                name: name,\n                type: type,\n                id: runId,\n                args: [arg],\n                tree: baseContext.tree,\n                context: baseContext.context,\n                parentId: baseContext.id,\n                rootId: baseContext.rootId\n            }, fn);\n        }\n        return new Promise(function (resolve, reject) {\n            var gen;\n            var init = function asyncActionInit() {\n                gen = generator.apply(null, arguments);\n                onFulfilled(undefined); // kick off the flow\n            };\n            init.$mst_middleware = spawner.$mst_middleware;\n            runWithActionContext$$1({\n                name: name,\n                type: \"flow_spawn\",\n                id: runId,\n                args: argsToArray(args),\n                tree: baseContext.tree,\n                context: baseContext.context,\n                parentId: baseContext.id,\n                rootId: baseContext.rootId\n            }, init);\n            function onFulfilled(res) {\n                var ret;\n                try {\n                    // prettier-ignore\n                    wrap(function (r) { ret = gen.next(r); }, \"flow_resume\", res);\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediate(function () {\n                        wrap(function (r) { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n                return;\n            }\n            function onRejected(err) {\n                var ret;\n                try {\n                    // prettier-ignore\n                    wrap(function (r) { ret = gen.throw(r); }, \"flow_resume_error\", err); // or yieldError?\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediate(function () {\n                        wrap(function (r) { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n            }\n            function next(ret) {\n                if (ret.done) {\n                    // prettier-ignore\n                    setImmediate(function () {\n                        wrap(function (r) { resolve(r); }, \"flow_return\", ret.value);\n                    });\n                    return;\n                }\n                // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100\n                if (!ret.value || typeof ret.value.then !== \"function\")\n                    fail(\"Only promises can be yielded to `async`, got: \" + ret);\n                return ret.value.then(onFulfilled, onRejected);\n            }\n        });\n    };\n    return spawner;\n}\n\nfunction splitPatch$$1(patch) {\n    if (!(\"oldValue\" in patch))\n        fail(\"Patches without `oldValue` field cannot be inversed\");\n    return [stripPatch$$1(patch), invertPatch(patch)];\n}\nfunction stripPatch$$1(patch) {\n    // strips `oldvalue` information from the patch, so that it becomes a patch conform the json-patch spec\n    // this removes the ability to undo the patch\n    switch (patch.op) {\n        case \"add\":\n            return { op: \"add\", path: patch.path, value: patch.value };\n        case \"remove\":\n            return { op: \"remove\", path: patch.path };\n        case \"replace\":\n            return { op: \"replace\", path: patch.path, value: patch.value };\n    }\n}\nfunction invertPatch(patch) {\n    switch (patch.op) {\n        case \"add\":\n            return {\n                op: \"remove\",\n                path: patch.path\n            };\n        case \"remove\":\n            return {\n                op: \"add\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n        case \"replace\":\n            return {\n                op: \"replace\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n    }\n}\n/**\n * escape slashes and backslashes\n * http://tools.ietf.org/html/rfc6901\n */\nfunction escapeJsonPath$$1(str) {\n    return str.replace(/~/g, \"~1\").replace(/\\//g, \"~0\");\n}\n/**\n * unescape slashes and backslashes\n */\nfunction unescapeJsonPath$$1(str) {\n    return str.replace(/~0/g, \"/\").replace(/~1/g, \"~\");\n}\nfunction joinJsonPath$$1(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    if (path.length === 0)\n        return \"\";\n    return \"/\" + path.map(escapeJsonPath$$1).join(\"/\");\n}\nfunction splitJsonPath$$1(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    var parts = path.split(\"/\").map(unescapeJsonPath$$1);\n    // path '/a/b/c' -> a b c\n    // path '../../b/c -> .. .. b c\n    return parts[0] === \"\" ? parts.slice(1) : parts;\n}\n\nfunction mapToString$$1() {\n    return getStateTreeNode$$1(this) + \"(\" + this.size + \" items)\";\n}\nfunction put(value) {\n    if (!!!value)\n        fail(\"Map.put cannot be used to set empty values\");\n    var node;\n    if (isStateTreeNode$$1(value)) {\n        node = getStateTreeNode$$1(value);\n    }\n    else if (isMutable(value)) {\n        var targetType = getStateTreeNode$$1(this).type\n            .subType;\n        node = getStateTreeNode$$1(targetType.create(value));\n    }\n    else {\n        return fail(\"Map.put can only be used to store complex values\");\n    }\n    if (!node.identifierAttribute)\n        fail(\"Map.put can only be used to store complex values that have an identifier type attribute\");\n    this.set(node.identifier, node.value);\n    return this;\n}\nvar MapType$$1 = /** @class */ (function (_super) {\n    __extends(MapType$$1, _super);\n    function MapType$$1(name, subType) {\n        var _this = _super.call(this, name) || this;\n        _this.shouldAttachNode = true;\n        _this.flags = TypeFlags$$1.Map;\n        _this.createNewInstance = function () {\n            // const identifierAttr = getIdentifierAttribute(this.subType)\n            var map$$1 = mobx.observable.shallowMap();\n            addHiddenFinalProp(map$$1, \"put\", put);\n            addHiddenFinalProp(map$$1, \"toString\", mapToString$$1);\n            return map$$1;\n        };\n        _this.finalizeNewInstance = function (node, snapshot) {\n            var instance = node.storedValue;\n            mobx.extras.interceptReads(instance, node.unbox);\n            mobx.intercept(instance, function (c) { return _this.willChange(c); });\n            node.applySnapshot(snapshot);\n            mobx.observe(instance, _this.didChange);\n        };\n        _this.subType = subType;\n        return _this;\n    }\n    MapType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n        return createNode$$1(this, parent, subpath, environment, snapshot, this.createNewInstance, this.finalizeNewInstance);\n    };\n    MapType$$1.prototype.describe = function () {\n        return \"Map<string, \" + this.subType.describe() + \">\";\n    };\n    MapType$$1.prototype.getChildren = function (node) {\n        return node.storedValue.values();\n    };\n    MapType$$1.prototype.getChildNode = function (node, key) {\n        var childNode = node.storedValue.get(key);\n        if (!childNode)\n            fail(\"Not a child \" + key);\n        return childNode;\n    };\n    MapType$$1.prototype.willChange = function (change) {\n        var node = getStateTreeNode$$1(change.object);\n        node.assertWritable();\n        switch (change.type) {\n            case \"update\":\n                {\n                    var newValue = change.newValue;\n                    var oldValue = change.object.get(change.name);\n                    if (newValue === oldValue)\n                        return null;\n                    typecheck$$1(this.subType, newValue);\n                    change.newValue = this.subType.reconcile(node.getChildNode(change.name), change.newValue);\n                    this.verifyIdentifier(change.name, change.newValue);\n                }\n                break;\n            case \"add\":\n                {\n                    typecheck$$1(this.subType, change.newValue);\n                    change.newValue = this.subType.instantiate(node, change.name, undefined, change.newValue);\n                    this.verifyIdentifier(change.name, change.newValue);\n                }\n                break;\n        }\n        return change;\n    };\n    MapType$$1.prototype.verifyIdentifier = function (expected, node) {\n        if (node instanceof ObjectNode$$1) {\n            var identifier$$1 = node.identifier;\n            if (identifier$$1 !== null && \"\" + identifier$$1 !== \"\" + expected)\n                fail(\"A map of objects containing an identifier should always store the object under their own identifier. Trying to store key '\" + identifier$$1 + \"', but expected: '\" + expected + \"'\");\n        }\n    };\n    MapType$$1.prototype.getValue = function (node) {\n        return node.storedValue;\n    };\n    MapType$$1.prototype.getSnapshot = function (node) {\n        var res = {};\n        node.getChildren().forEach(function (childNode) {\n            res[childNode.subpath] = childNode.snapshot;\n        });\n        return res;\n    };\n    MapType$$1.prototype.didChange = function (change) {\n        var node = getStateTreeNode$$1(change.object);\n        switch (change.type) {\n            case \"update\":\n                return void node.emitPatch({\n                    op: \"replace\",\n                    path: escapeJsonPath$$1(change.name),\n                    value: change.newValue.snapshot,\n                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                }, node);\n            case \"add\":\n                return void node.emitPatch({\n                    op: \"add\",\n                    path: escapeJsonPath$$1(change.name),\n                    value: change.newValue.snapshot,\n                    oldValue: undefined\n                }, node);\n            case \"delete\":\n                // a node got deleted, get the old snapshot and make the node die\n                var oldSnapshot = change.oldValue.snapshot;\n                change.oldValue.die();\n                // emit the patch\n                return void node.emitPatch({ op: \"remove\", path: escapeJsonPath$$1(change.name), oldValue: oldSnapshot }, node);\n        }\n    };\n    MapType$$1.prototype.applyPatchLocally = function (node, subpath, patch) {\n        var target = node.storedValue;\n        switch (patch.op) {\n            case \"add\":\n            case \"replace\":\n                target.set(subpath, patch.value);\n                break;\n            case \"remove\":\n                target.delete(subpath);\n                break;\n        }\n    };\n    MapType$$1.prototype.applySnapshot = function (node, snapshot) {\n        typecheck$$1(this, snapshot);\n        var target = node.storedValue;\n        var currentKeys = {};\n        target.keys().forEach(function (key) {\n            currentKeys[key] = false;\n        });\n        // Don't use target.replace, as it will throw all existing items first\n        Object.keys(snapshot).forEach(function (key) {\n            target.set(key, snapshot[key]);\n            currentKeys[key] = true;\n        });\n        Object.keys(currentKeys).forEach(function (key) {\n            if (currentKeys[key] === false)\n                target.delete(key);\n        });\n    };\n    MapType$$1.prototype.getChildType = function (key) {\n        return this.subType;\n    };\n    MapType$$1.prototype.isValidSnapshot = function (value, context) {\n        var _this = this;\n        if (!isPlainObject(value)) {\n            return typeCheckFailure$$1(context, value, \"Value is not a plain object\");\n        }\n        return flattenTypeErrors$$1(Object.keys(value).map(function (path) {\n            return _this.subType.validate(value[path], getContextForPath$$1(context, path, _this.subType));\n        }));\n    };\n    MapType$$1.prototype.getDefaultSnapshot = function () {\n        return {};\n    };\n    MapType$$1.prototype.removeChild = function (node, subpath) {\n        \n        node.storedValue.delete(subpath);\n    };\n    __decorate([\n        mobx.action\n    ], MapType$$1.prototype, \"applySnapshot\", null);\n    return MapType$$1;\n}(ComplexType$$1));\n/**\n * Creates a key based collection type who's children are all of a uniform declared type.\n * If the type stored in a map has an identifier, it is mandatory to store the child under that identifier in the map.\n *\n * This type will always produce [observable maps](https://mobx.js.org/refguide/map.html)\n *\n * @example\n * const Todo = types.model({\n *   id: types.identifier(types.number),\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.map(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: {} })\n * unprotect(s)\n * s.todos.set(17, { task: \"Grab coffee\", id: 17 })\n * s.todos.put({ task: \"Grab cookie\", id: 18 }) // put will infer key from the identifier\n * console.log(s.todos.get(17).task) // prints: \"Grab coffee\"\n *\n * @export\n * @alias types.map\n * @param {IType<S, T>} subtype\n * @returns {IComplexType<S[], IObservableArray<T>>}\n */\nfunction map$$1(subtype) {\n    return new MapType$$1(\"map<string, \" + subtype.name + \">\", subtype);\n}\n\nfunction arrayToString$$1() {\n    return getStateTreeNode$$1(this) + \"(\" + this.length + \" items)\";\n}\nvar ArrayType$$1 = /** @class */ (function (_super) {\n    __extends(ArrayType$$1, _super);\n    function ArrayType$$1(name, subType) {\n        var _this = _super.call(this, name) || this;\n        _this.shouldAttachNode = true;\n        _this.flags = TypeFlags$$1.Array;\n        _this.createNewInstance = function () {\n            var array$$1 = mobx.observable.shallowArray();\n            addHiddenFinalProp(array$$1, \"toString\", arrayToString$$1);\n            return array$$1;\n        };\n        _this.finalizeNewInstance = function (node, snapshot) {\n            var instance = node.storedValue;\n            mobx.extras.getAdministration(instance).dehancer = node.unbox;\n            mobx.intercept(instance, function (change) { return _this.willChange(change); });\n            node.applySnapshot(snapshot);\n            mobx.observe(instance, _this.didChange);\n        };\n        _this.subType = subType;\n        return _this;\n    }\n    ArrayType$$1.prototype.describe = function () {\n        return this.subType.describe() + \"[]\";\n    };\n    ArrayType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n        return createNode$$1(this, parent, subpath, environment, snapshot, this.createNewInstance, this.finalizeNewInstance);\n    };\n    ArrayType$$1.prototype.getChildren = function (node) {\n        return node.storedValue.peek();\n    };\n    ArrayType$$1.prototype.getChildNode = function (node, key) {\n        var index = parseInt(key, 10);\n        if (index < node.storedValue.length)\n            return node.storedValue[index];\n        return fail(\"Not a child: \" + key);\n    };\n    ArrayType$$1.prototype.willChange = function (change) {\n        var node = getStateTreeNode$$1(change.object);\n        node.assertWritable();\n        var childNodes = node.getChildren();\n        switch (change.type) {\n            case \"update\":\n                if (change.newValue === change.object[change.index])\n                    return null;\n                change.newValue = reconcileArrayChildren(node, this.subType, [childNodes[change.index]], [change.newValue], [change.index])[0];\n                break;\n            case \"splice\":\n                var index_1 = change.index, removedCount = change.removedCount, added = change.added;\n                change.added = reconcileArrayChildren(node, this.subType, childNodes.slice(index_1, index_1 + removedCount), added, added.map(function (_, i) { return index_1 + i; }));\n                // update paths of remaining items\n                for (var i = index_1 + removedCount; i < childNodes.length; i++) {\n                    childNodes[i].setParent(node, \"\" + (i + added.length - removedCount));\n                }\n                break;\n        }\n        return change;\n    };\n    ArrayType$$1.prototype.getValue = function (node) {\n        return node.storedValue;\n    };\n    ArrayType$$1.prototype.getSnapshot = function (node) {\n        return node.getChildren().map(function (childNode) { return childNode.snapshot; });\n    };\n    ArrayType$$1.prototype.didChange = function (change) {\n        var node = getStateTreeNode$$1(change.object);\n        switch (change.type) {\n            case \"update\":\n                return void node.emitPatch({\n                    op: \"replace\",\n                    path: \"\" + change.index,\n                    value: change.newValue.snapshot,\n                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                }, node);\n            case \"splice\":\n                for (var i = change.removedCount - 1; i >= 0; i--)\n                    node.emitPatch({\n                        op: \"remove\",\n                        path: \"\" + (change.index + i),\n                        oldValue: change.removed[i].snapshot\n                    }, node);\n                for (var i = 0; i < change.addedCount; i++)\n                    node.emitPatch({\n                        op: \"add\",\n                        path: \"\" + (change.index + i),\n                        value: node.getChildNode(\"\" + (change.index + i)).snapshot,\n                        oldValue: undefined\n                    }, node);\n                return;\n        }\n    };\n    ArrayType$$1.prototype.applyPatchLocally = function (node, subpath, patch) {\n        var target = node.storedValue;\n        var index = subpath === \"-\" ? target.length : parseInt(subpath);\n        switch (patch.op) {\n            case \"replace\":\n                target[index] = patch.value;\n                break;\n            case \"add\":\n                target.splice(index, 0, patch.value);\n                break;\n            case \"remove\":\n                target.splice(index, 1);\n                break;\n        }\n    };\n    ArrayType$$1.prototype.applySnapshot = function (node, snapshot) {\n        typecheck$$1(this, snapshot);\n        var target = node.storedValue;\n        target.replace(snapshot);\n    };\n    ArrayType$$1.prototype.getChildType = function (key) {\n        return this.subType;\n    };\n    ArrayType$$1.prototype.isValidSnapshot = function (value, context) {\n        var _this = this;\n        if (!isArray(value)) {\n            return typeCheckFailure$$1(context, value, \"Value is not an array\");\n        }\n        return flattenTypeErrors$$1(value.map(function (item, index) {\n            return _this.subType.validate(item, getContextForPath$$1(context, \"\" + index, _this.subType));\n        }));\n    };\n    ArrayType$$1.prototype.getDefaultSnapshot = function () {\n        return [];\n    };\n    ArrayType$$1.prototype.removeChild = function (node, subpath) {\n        node.storedValue.splice(parseInt(subpath, 10), 1);\n    };\n    __decorate([\n        mobx.action\n    ], ArrayType$$1.prototype, \"applySnapshot\", null);\n    return ArrayType$$1;\n}(ComplexType$$1));\n/**\n * Creates an index based collection type who's children are all of a uniform declared type.\n *\n * This type will always produce [observable arrays](https://mobx.js.org/refguide/array.html)\n *\n * @example\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: [] })\n * unprotect(s) // needed to allow modifying outside of an action\n * s.todos.push({ task: \"Grab coffee\" })\n * console.log(s.todos[0]) // prints: \"Grab coffee\"\n *\n * @export\n * @alias types.array\n * @param {IType<S, T>} subtype\n * @returns {IComplexType<S[], IObservableArray<T>>}\n */\nfunction array$$1(subtype) {\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isType$$1(subtype))\n            fail(\"expected a mobx-state-tree type as first argument, got \" + subtype + \" instead\");\n    }\n    return new ArrayType$$1(subtype.name + \"[]\", subtype);\n}\nfunction reconcileArrayChildren(parent, childType, oldNodes, newValues, newPaths) {\n    var oldNode, newValue, hasNewNode = false, oldMatch = undefined;\n    for (var i = 0;; i++) {\n        hasNewNode = i <= newValues.length - 1;\n        oldNode = oldNodes[i];\n        newValue = hasNewNode ? newValues[i] : undefined;\n        // for some reason, instead of newValue we got a node, fallback to the storedValue\n        // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681\n        if (isNode$$1(newValue))\n            newValue = newValue.storedValue;\n        // both are empty, end\n        if (!oldNode && !hasNewNode) {\n            break;\n            // new one does not exists, old one dies\n        }\n        else if (!hasNewNode) {\n            oldNode.die();\n            oldNodes.splice(i, 1);\n            i--;\n            // there is no old node, create it\n        }\n        else if (!oldNode) {\n            // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.\n            if (isStateTreeNode$$1(newValue) && getStateTreeNode$$1(newValue).parent === parent) {\n                // this node is owned by this parent, but not in the reconcilable set, so it must be double\n                fail(\"Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '\" + parent.path + \"/\" + newPaths[i] + \"', but it lives already at '\" + getStateTreeNode$$1(newValue).path + \"'\");\n            }\n            oldNodes.splice(i, 0, valueAsNode(childType, parent, \"\" + newPaths[i], newValue));\n            // both are the same, reconcile\n        }\n        else if (areSame(oldNode, newValue)) {\n            oldNodes[i] = valueAsNode(childType, parent, \"\" + newPaths[i], newValue, oldNode);\n            // nothing to do, try to reorder\n        }\n        else {\n            oldMatch = undefined;\n            // find a possible candidate to reuse\n            for (var j = i; j < oldNodes.length; j++) {\n                if (areSame(oldNodes[j], newValue)) {\n                    oldMatch = oldNodes.splice(j, 1)[0];\n                    break;\n                }\n            }\n            oldNodes.splice(i, 0, valueAsNode(childType, parent, \"\" + newPaths[i], newValue, oldMatch));\n        }\n    }\n    return oldNodes;\n}\n// convert a value to a node at given parent and subpath. attempts to reuse old node if possible and given\nfunction valueAsNode(childType, parent, subpath, newValue, oldNode) {\n    // ensure the value is valid-ish\n    typecheck$$1(childType, newValue);\n    // the new value has a MST node\n    if (isStateTreeNode$$1(newValue)) {\n        var childNode_1 = getStateTreeNode$$1(newValue);\n        childNode_1.assertAlive();\n        // the node lives here\n        if (childNode_1.parent !== null && childNode_1.parent === parent) {\n            childNode_1.setParent(parent, subpath);\n            if (oldNode && oldNode !== childNode_1)\n                oldNode.die();\n            return childNode_1;\n        }\n    }\n    // there is old node and new one is a value/snapshot\n    if (oldNode) {\n        var childNode_2 = childType.reconcile(oldNode, newValue);\n        childNode_2.setParent(parent, subpath);\n        return childNode_2;\n    }\n    // nothing to do, create from scratch\n    var childNode = childType.instantiate(parent, subpath, parent._environment, newValue);\n    return childNode;\n}\n// given a value\nfunction areSame(oldNode, newValue) {\n    // the new value has the same node\n    if (isStateTreeNode$$1(newValue)) {\n        return getStateTreeNode$$1(newValue) === oldNode;\n    }\n    // the provided value is the snapshot of the old node\n    if (isMutable(newValue) && oldNode.snapshot === newValue)\n        return true;\n    // new value is a snapshot with the correct identifier\n    if (oldNode instanceof ObjectNode$$1 &&\n        oldNode.identifier !== null &&\n        oldNode.identifierAttribute &&\n        isPlainObject(newValue) &&\n        newValue[oldNode.identifierAttribute] === oldNode.identifier)\n        return true;\n    return false;\n}\n\nvar PRE_PROCESS_SNAPSHOT = \"preProcessSnapshot\";\nvar HOOK_NAMES = {\n    afterCreate: \"afterCreate\",\n    afterAttach: \"afterAttach\",\n    postProcessSnapshot: \"postProcessSnapshot\",\n    beforeDetach: \"beforeDetach\",\n    beforeDestroy: \"beforeDestroy\"\n};\nfunction objectTypeToString() {\n    return getStateTreeNode$$1(this).toString();\n}\nvar defaultObjectOptions = {\n    name: \"AnonymousModel\",\n    properties: {},\n    initializers: EMPTY_ARRAY\n};\nfunction toPropertiesObject(properties) {\n    // loop through properties and ensures that all items are types\n    return Object.keys(properties).reduce(function (properties, key) {\n        // warn if user intended a HOOK\n        if (key in HOOK_NAMES)\n            return fail(\"Hook '\" + key + \"' was defined as property. Hooks should be defined as part of the actions\");\n        // the user intended to use a view\n        var descriptor = Object.getOwnPropertyDescriptor(properties, key);\n        if (\"get\" in descriptor) {\n            fail(\"Getters are not supported as properties. Please use views instead\");\n        }\n        // undefined and null are not valid\n        var value = descriptor.value;\n        if (value === null || undefined) {\n            fail(\"The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?\");\n            // its a primitive, convert to its type\n        }\n        else if (isPrimitive(value)) {\n            return Object.assign({}, properties, (_a = {},\n                _a[key] = optional$$1(getPrimitiveFactoryFromValue$$1(value), value),\n                _a));\n            // its already a type\n        }\n        else if (isType$$1(value)) {\n            return properties;\n            // its a function, maybe the user wanted a view?\n        }\n        else if (typeof value === \"function\") {\n            fail(\"Functions are not supported as properties, use views instead\");\n            // no other complex values\n        }\n        else if (typeof value === \"object\") {\n            fail(\"In property '\" + key + \"': base model's should not contain complex values: '\" + value + \"'\");\n            // WTF did you passed in mate?\n        }\n        else {\n            fail(\"Unexpected value for property '\" + key + \"'\");\n        }\n        var _a;\n    }, properties);\n}\nvar ModelType$$1 = /** @class */ (function (_super) {\n    __extends(ModelType$$1, _super);\n    function ModelType$$1(opts) {\n        var _this = _super.call(this, opts.name || defaultObjectOptions.name) || this;\n        _this.flags = TypeFlags$$1.Object;\n        _this.shouldAttachNode = true;\n        _this.createNewInstance = function () {\n            var instance = mobx.observable.shallowObject(EMPTY_OBJECT);\n            addHiddenFinalProp(instance, \"toString\", objectTypeToString);\n            return instance;\n        };\n        _this.finalizeNewInstance = function (node, snapshot) {\n            var instance = node.storedValue;\n            _this.forAllProps(function (name, type) {\n                mobx.extendShallowObservable(instance, (_a = {},\n                    _a[name] = mobx.observable.ref(type.instantiate(node, name, node._environment, snapshot[name])),\n                    _a));\n                mobx.extras.interceptReads(instance, name, node.unbox);\n                var _a;\n            });\n            _this.initializers.reduce(function (self, fn) { return fn(self); }, instance);\n            mobx.intercept(instance, function (change) { return _this.willChange(change); });\n            mobx.observe(instance, _this.didChange);\n        };\n        _this.didChange = function (change) {\n            if (!_this.properties[change.name]) {\n                // don't emit patches for volatile state\n                return;\n            }\n            var node = getStateTreeNode$$1(change.object);\n            var oldValue = change.oldValue ? change.oldValue.snapshot : undefined;\n            node.emitPatch({\n                op: \"replace\",\n                path: escapeJsonPath$$1(change.name),\n                value: change.newValue.snapshot,\n                oldValue: oldValue\n            }, node);\n        };\n        var name = opts.name || defaultObjectOptions.name;\n        // TODO: this test still needed?\n        if (!/^\\w[\\w\\d_]*$/.test(name))\n            fail(\"Typename should be a valid identifier: \" + name);\n        Object.assign(_this, defaultObjectOptions, opts);\n        // ensures that any default value gets converted to its related type\n        _this.properties = toPropertiesObject(_this.properties);\n        _this.propertiesNames = Object.keys(_this.properties);\n        Object.freeze(_this.properties); // make sure nobody messes with it\n        return _this;\n    }\n    ModelType$$1.prototype.cloneAndEnhance = function (opts) {\n        return new ModelType$$1({\n            name: opts.name || this.name,\n            properties: Object.assign({}, this.properties, opts.properties),\n            initializers: this.initializers.concat(opts.initializers || []),\n            preProcessor: opts.preProcessor || this.preProcessor\n        });\n    };\n    ModelType$$1.prototype.actions = function (fn) {\n        var _this = this;\n        var actionInitializer = function (self) {\n            _this.instantiateActions(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [actionInitializer] });\n    };\n    ModelType$$1.prototype.instantiateActions = function (self, actions) {\n        // check if return is correct\n        if (!isPlainObject(actions))\n            fail(\"actions initializer should return a plain object containing actions\");\n        // bind actions to the object created\n        Object.keys(actions).forEach(function (name) {\n            // warn if preprocessor was given\n            if (name === PRE_PROCESS_SNAPSHOT)\n                return fail(\"Cannot define action '\" + PRE_PROCESS_SNAPSHOT + \"', it should be defined using 'type.preProcessSnapshot(fn)' instead\");\n            // apply hook composition\n            var action$$1 = actions[name];\n            var baseAction = self[name];\n            if (name in HOOK_NAMES && baseAction) {\n                var specializedAction_1 = action$$1;\n                if (name === HOOK_NAMES.postProcessSnapshot)\n                    action$$1 = function (snapshot) { return specializedAction_1(baseAction(snapshot)); };\n                else\n                    action$$1 = function () {\n                        baseAction.apply(null, arguments);\n                        specializedAction_1.apply(null, arguments);\n                    };\n            }\n            addHiddenFinalProp(self, name, createActionInvoker$$1(self, name, action$$1));\n            return;\n        });\n    };\n    ModelType$$1.prototype.named = function (name) {\n        return this.cloneAndEnhance({ name: name });\n    };\n    ModelType$$1.prototype.props = function (properties) {\n        return this.cloneAndEnhance({ properties: properties });\n    };\n    ModelType$$1.prototype.volatile = function (fn) {\n        var _this = this;\n        var stateInitializer = function (self) {\n            _this.instantiateVolatileState(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [stateInitializer] });\n    };\n    ModelType$$1.prototype.instantiateVolatileState = function (self, state) {\n        // check views return\n        if (!isPlainObject(state))\n            fail(\"state initializer should return a plain object containing views\");\n        // TODO: typecheck & namecheck members of state?\n        mobx.extendShallowObservable(self, state);\n    };\n    ModelType$$1.prototype.extend = function (fn) {\n        var _this = this;\n        var initializer = function (self) {\n            var _a = fn(self), actions = _a.actions, views = _a.views, state = _a.state, rest = __rest(_a, [\"actions\", \"views\", \"state\"]);\n            for (var key in rest)\n                fail(\"The `extend` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '\" + key + \"'\");\n            if (state)\n                _this.instantiateVolatileState(self, state);\n            if (views)\n                _this.instantiateViews(self, views);\n            if (actions)\n                _this.instantiateActions(self, actions);\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [initializer] });\n    };\n    ModelType$$1.prototype.views = function (fn) {\n        var _this = this;\n        var viewInitializer = function (self) {\n            _this.instantiateViews(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [viewInitializer] });\n    };\n    ModelType$$1.prototype.instantiateViews = function (self, views) {\n        // check views return\n        if (!isPlainObject(views))\n            fail(\"views initializer should return a plain object containing views\");\n        Object.keys(views).forEach(function (key) {\n            // is this a computed property?\n            var descriptor = Object.getOwnPropertyDescriptor(views, key);\n            var value = descriptor.value;\n            if (\"get\" in descriptor) {\n                // TODO: mobx currently does not allow redefining computes yet, pending #1121\n                if (mobx.isComputed(self.$mobx.values[key])) {\n                    // TODO: use `isComputed(self, key)`, pending mobx #1120\n                    \n                    self.$mobx.values[key] = mobx.computed(descriptor.get, {\n                        name: key,\n                        setter: descriptor.set,\n                        context: self\n                    });\n                }\n                else {\n                    var tmp = {};\n                    Object.defineProperty(tmp, key, {\n                        get: descriptor.get,\n                        set: descriptor.set,\n                        enumerable: true\n                    });\n                    mobx.extendShallowObservable(self, tmp);\n                }\n            }\n            else if (typeof value === \"function\") {\n                // this is a view function, merge as is!\n                addHiddenFinalProp(self, key, value);\n            }\n            else {\n                fail(\"A view member should either be a function or getter based property\");\n            }\n        });\n    };\n    ModelType$$1.prototype.preProcessSnapshot = function (preProcessor) {\n        var currentPreprocessor = this.preProcessor;\n        if (!currentPreprocessor)\n            return this.cloneAndEnhance({ preProcessor: preProcessor });\n        else\n            return this.cloneAndEnhance({\n                preProcessor: function (snapshot) { return currentPreprocessor(preProcessor(snapshot)); }\n            });\n    };\n    ModelType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n        return createNode$$1(this, parent, subpath, environment, this.applySnapshotPreProcessor(snapshot), this.createNewInstance, this.finalizeNewInstance);\n        // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class\n        // that pre-reserves all these fields for fast object-member lookups\n    };\n    ModelType$$1.prototype.willChange = function (change) {\n        var node = getStateTreeNode$$1(change.object);\n        node.assertWritable();\n        var type = this.properties[change.name];\n        // only properties are typed, state are stored as-is references\n        if (type) {\n            typecheck$$1(type, change.newValue);\n            change.newValue = type.reconcile(node.getChildNode(change.name), change.newValue);\n        }\n        return change;\n    };\n    ModelType$$1.prototype.getChildren = function (node) {\n        var _this = this;\n        var res = [];\n        this.forAllProps(function (name, type) {\n            res.push(_this.getChildNode(node, name));\n        });\n        return res;\n    };\n    ModelType$$1.prototype.getChildNode = function (node, key) {\n        if (!(key in this.properties))\n            return fail(\"Not a value property: \" + key);\n        var childNode = node.storedValue.$mobx.values[key].value; // TODO: blegh!\n        if (!childNode)\n            return fail(\"Node not available for property \" + key);\n        return childNode;\n    };\n    ModelType$$1.prototype.getValue = function (node) {\n        return node.storedValue;\n    };\n    ModelType$$1.prototype.getSnapshot = function (node) {\n        var _this = this;\n        var res = {};\n        this.forAllProps(function (name, type) {\n            // TODO: FIXME, make sure the observable ref is used!\n            \n            mobx.extras.getAtom(node.storedValue, name).reportObserved();\n            res[name] = _this.getChildNode(node, name).snapshot;\n        });\n        if (typeof node.storedValue.postProcessSnapshot === \"function\")\n            return node.storedValue.postProcessSnapshot.call(null, res);\n        return res;\n    };\n    ModelType$$1.prototype.applyPatchLocally = function (node, subpath, patch) {\n        if (!(patch.op === \"replace\" || patch.op === \"add\"))\n            fail(\"object does not support operation \" + patch.op);\n        node.storedValue[subpath] = patch.value;\n    };\n    ModelType$$1.prototype.applySnapshot = function (node, snapshot) {\n        var s = this.applySnapshotPreProcessor(snapshot);\n        typecheck$$1(this, s);\n        this.forAllProps(function (name, type) {\n            node.storedValue[name] = s[name];\n        });\n    };\n    ModelType$$1.prototype.applySnapshotPreProcessor = function (snapshot) {\n        if (this.preProcessor)\n            return this.preProcessor.call(null, snapshot);\n        return snapshot;\n    };\n    ModelType$$1.prototype.getChildType = function (key) {\n        return this.properties[key];\n    };\n    ModelType$$1.prototype.isValidSnapshot = function (value, context) {\n        var _this = this;\n        var snapshot = this.applySnapshotPreProcessor(value);\n        if (!isPlainObject(snapshot)) {\n            return typeCheckFailure$$1(context, snapshot, \"Value is not a plain object\");\n        }\n        return flattenTypeErrors$$1(this.propertiesNames.map(function (key) {\n            return _this.properties[key].validate(snapshot[key], getContextForPath$$1(context, key, _this.properties[key]));\n        }));\n    };\n    ModelType$$1.prototype.forAllProps = function (fn) {\n        var _this = this;\n        this.propertiesNames.forEach(function (key) { return fn(key, _this.properties[key]); });\n    };\n    ModelType$$1.prototype.describe = function () {\n        var _this = this;\n        // optimization: cache\n        return (\"{ \" +\n            this.propertiesNames\n                .map(function (key) { return key + \": \" + _this.properties[key].describe(); })\n                .join(\"; \") +\n            \" }\");\n    };\n    ModelType$$1.prototype.getDefaultSnapshot = function () {\n        return {};\n    };\n    ModelType$$1.prototype.removeChild = function (node, subpath) {\n        node.storedValue[subpath] = null;\n    };\n    __decorate([\n        mobx.action\n    ], ModelType$$1.prototype, \"applySnapshot\", null);\n    return ModelType$$1;\n}(ComplexType$$1));\n/**\n * Creates a new model type by providing a name, properties, volatile state and actions.\n *\n * See the [model type](https://github.com/mobxjs/mobx-state-tree#creating-models) description or the [getting started](https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started-1) tutorial.\n *\n * @export\n * @alias types.model\n */\nfunction model$$1() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var name = typeof args[0] === \"string\" ? args.shift() : \"AnonymousModel\";\n    var properties = args.shift() || {};\n    return new ModelType$$1({ name: name, properties: properties });\n}\n/**\n * Composes a new model from one or more existing model types.\n * This method can be invoked in two forms:\n * Given 2 or more model types, the types are composed into a new Type.\n *\n * @export\n * @alias types.compose\n */\nfunction compose$$1() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    // TODO: just join the base type names if no name is provided\n    var typeName = typeof args[0] === \"string\" ? args.shift() : \"AnonymousModel\";\n    // check all parameters\n    if (process.env.NODE_ENV !== \"production\") {\n        args.forEach(function (type) {\n            if (!isType$$1(type))\n                fail(\"expected a mobx-state-tree type, got \" + type + \" instead\");\n        });\n    }\n    return args\n        .reduce(function (prev, cur) {\n        return prev.cloneAndEnhance({\n            name: prev.name + \"_\" + cur.name,\n            properties: cur.properties,\n            initializers: cur.initializers\n        });\n    })\n        .named(typeName);\n}\n\nvar CoreType$$1 = /** @class */ (function (_super) {\n    __extends(CoreType$$1, _super);\n    function CoreType$$1(name, flags, checker, initializer) {\n        if (initializer === void 0) { initializer = identity; }\n        var _this = _super.call(this, name) || this;\n        _this.shouldAttachNode = false;\n        _this.flags = flags;\n        _this.checker = checker;\n        _this.initializer = initializer;\n        return _this;\n    }\n    CoreType$$1.prototype.describe = function () {\n        return this.name;\n    };\n    CoreType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n        return createNode$$1(this, parent, subpath, environment, snapshot, this.initializer);\n    };\n    CoreType$$1.prototype.isValidSnapshot = function (value, context) {\n        if (isPrimitive(value) && this.checker(value)) {\n            return typeCheckSuccess$$1();\n        }\n        var typeName = this.name === \"Date\" ? \"Date or a unix milliseconds timestamp\" : this.name;\n        return typeCheckFailure$$1(context, value, \"Value is not a \" + typeName);\n    };\n    return CoreType$$1;\n}(Type$$1));\n/**\n * Creates a type that can only contain a string value.\n * This type is used for string values by default\n *\n * @export\n * @alias types.string\n * @example\n * const Person = types.model({\n *   firstName: types.string,\n *   lastName: \"Doe\"\n * })\n */\n// tslint:disable-next-line:variable-name\nvar string$$1 = new CoreType$$1(\"string\", TypeFlags$$1.String, function (v) { return typeof v === \"string\"; });\n/**\n * Creates a type that can only contain a numeric value.\n * This type is used for numeric values by default\n *\n * @export\n * @alias types.number\n * @example\n * const Vector = types.model({\n *   x: types.number,\n *   y: 0\n * })\n */\n// tslint:disable-next-line:variable-name\nvar number$$1 = new CoreType$$1(\"number\", TypeFlags$$1.Number, function (v) { return typeof v === \"number\"; });\n/**\n * Creates a type that can only contain a boolean value.\n * This type is used for boolean values by default\n *\n * @export\n * @alias types.boolean\n * @example\n * const Thing = types.model({\n *   isCool: types.boolean,\n *   isAwesome: false\n * })\n */\n// tslint:disable-next-line:variable-name\nvar boolean$$1 = new CoreType$$1(\"boolean\", TypeFlags$$1.Boolean, function (v) { return typeof v === \"boolean\"; });\n/**\n * The type of the value `null`\n *\n * @export\n * @alias types.null\n */\nvar nullType$$1 = new CoreType$$1(\"null\", TypeFlags$$1.Null, function (v) { return v === null; });\n/**\n * The type of the value `undefined`\n *\n * @export\n * @alias types.undefined\n */\nvar undefinedType$$1 = new CoreType$$1(\"undefined\", TypeFlags$$1.Undefined, function (v) { return v === undefined; });\n/**\n * Creates a type that can only contain a javascript Date value.\n *\n * @export\n * @alias types.Date\n * @example\n * const LogLine = types.model({\n *   timestamp: types.Date,\n * })\n *\n * LogLine.create({ timestamp: new Date() })\n */\n// tslint:disable-next-line:variable-name\nvar DatePrimitive$$1 = new CoreType$$1(\"Date\", TypeFlags$$1.Date, function (v) { return typeof v === \"number\" || v instanceof Date; }, function (v) { return (v instanceof Date ? v : new Date(v)); });\nDatePrimitive$$1.getSnapshot = function (node) {\n    return node.storedValue.getTime();\n};\nfunction getPrimitiveFactoryFromValue$$1(value) {\n    switch (typeof value) {\n        case \"string\":\n            return string$$1;\n        case \"number\":\n            return number$$1;\n        case \"boolean\":\n            return boolean$$1;\n        case \"object\":\n            if (value instanceof Date)\n                return DatePrimitive$$1;\n    }\n    return fail(\"Cannot determine primitive type from value \" + value);\n}\nfunction isPrimitiveType$$1(type) {\n    return (isType$$1(type) &&\n        (type.flags & (TypeFlags$$1.String | TypeFlags$$1.Number | TypeFlags$$1.Boolean | TypeFlags$$1.Date)) >\n            0);\n}\n\nvar Literal$$1 = /** @class */ (function (_super) {\n    __extends(Literal$$1, _super);\n    function Literal$$1(value) {\n        var _this = _super.call(this, JSON.stringify(value)) || this;\n        _this.shouldAttachNode = false;\n        _this.flags = TypeFlags$$1.Literal;\n        _this.value = value;\n        return _this;\n    }\n    Literal$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n        return createNode$$1(this, parent, subpath, environment, snapshot);\n    };\n    Literal$$1.prototype.describe = function () {\n        return JSON.stringify(this.value);\n    };\n    Literal$$1.prototype.isValidSnapshot = function (value, context) {\n        if (isPrimitive(value) && value === this.value) {\n            return typeCheckSuccess$$1();\n        }\n        return typeCheckFailure$$1(context, value, \"Value is not a literal \" + JSON.stringify(this.value));\n    };\n    return Literal$$1;\n}(Type$$1));\n/**\n * The literal type will return a type that will match only the exact given type.\n * The given value must be a primitive, in order to be serialized to a snapshot correctly.\n * You can use literal to match exact strings for example the exact male or female string.\n *\n * @example\n * const Person = types.model({\n *     name: types.string,\n *     gender: types.union(types.literal('male'), types.literal('female'))\n * })\n *\n * @export\n * @alias types.literal\n * @template S\n * @param {S} value The value to use in the strict equal check\n * @returns {ISimpleType<S>}\n */\nfunction literal$$1(value) {\n    // check that the given value is a primitive\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isPrimitive(value))\n            fail(\"Literal types can be built only on top of primitives\");\n    }\n    return new Literal$$1(value);\n}\n\nvar Refinement$$1 = /** @class */ (function (_super) {\n    __extends(Refinement$$1, _super);\n    function Refinement$$1(name, type, predicate, message) {\n        var _this = _super.call(this, name) || this;\n        _this.type = type;\n        _this.predicate = predicate;\n        _this.message = message;\n        return _this;\n    }\n    Object.defineProperty(Refinement$$1.prototype, \"flags\", {\n        get: function () {\n            return this.type.flags | TypeFlags$$1.Refinement;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Refinement$$1.prototype, \"shouldAttachNode\", {\n        get: function () {\n            return this.type.shouldAttachNode;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Refinement$$1.prototype.describe = function () {\n        return this.name;\n    };\n    Refinement$$1.prototype.instantiate = function (parent, subpath, environment, value) {\n        // create the child type\n        var inst = this.type.instantiate(parent, subpath, environment, value);\n        return inst;\n    };\n    Refinement$$1.prototype.isAssignableFrom = function (type) {\n        return this.type.isAssignableFrom(type);\n    };\n    Refinement$$1.prototype.isValidSnapshot = function (value, context) {\n        var subtypeErrors = this.type.validate(value, context);\n        if (subtypeErrors.length > 0)\n            return subtypeErrors;\n        var snapshot = isStateTreeNode$$1(value) ? getStateTreeNode$$1(value).snapshot : value;\n        if (!this.predicate(snapshot)) {\n            return typeCheckFailure$$1(context, value, this.message(value));\n        }\n        return typeCheckSuccess$$1();\n    };\n    return Refinement$$1;\n}(Type$$1));\n/**\n * `types.refinement(baseType, (snapshot) => boolean)` creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.\n *\n * @export\n * @alias types.refinement\n * @template T\n * @param {string} name\n * @param {IType<T, T>} type\n * @param {(snapshot: T) => boolean} predicate\n * @returns {IType<T, T>}\n */\nfunction refinement$$1() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var name = typeof args[0] === \"string\" ? args.shift() : isType$$1(args[0]) ? args[0].name : null;\n    var type = args[0];\n    var predicate = args[1];\n    var message = args[2]\n        ? args[2]\n        : function (v) { return \"Value does not respect the refinement predicate\"; };\n    // ensures all parameters are correct\n    if (process.env.NODE_ENV !== \"production\") {\n        if (typeof name !== \"string\")\n            fail(\"expected a string as first argument, got \" + name + \" instead\");\n        if (!isType$$1(type))\n            fail(\"expected a mobx-state-tree type as first or second argument, got \" +\n                type +\n                \" instead\");\n        if (typeof predicate !== \"function\")\n            fail(\"expected a function as third argument, got \" + predicate + \" instead\");\n        if (typeof message !== \"function\")\n            fail(\"expected a function as fourth argument, got \" + message + \" instead\");\n    }\n    return new Refinement$$1(name, type, predicate, message);\n}\n\n/**\n * Can be used to create an string based enumeration.\n * (note: this methods is just sugar for a union of string literals)\n *\n * @example\n * const TrafficLight = types.model({\n *   color: types.enumeration(\"Color\", [\"Red\", \"Orange\", \"Green\"])\n * })\n *\n * @export\n * @alias types.enumeration\n * @param {string} name descriptive name of the enumeration (optional)\n * @param {string[]} options possible values this enumeration can have\n * @returns {ISimpleType<string>}\n */\nfunction enumeration$$1(name, options) {\n    var realOptions = typeof name === \"string\" ? options : name;\n    // check all options\n    if (process.env.NODE_ENV !== \"production\") {\n        realOptions.forEach(function (option) {\n            if (typeof option !== \"string\")\n                fail(\"expected all options to be string, got \" + type + \" instead\");\n        });\n    }\n    var type = union$$1.apply(void 0, realOptions.map(function (option) { return literal$$1(\"\" + option); }));\n    if (typeof name === \"string\")\n        type.name = name;\n    return type;\n}\n\nvar Union$$1 = /** @class */ (function (_super) {\n    __extends(Union$$1, _super);\n    function Union$$1(name, types, dispatcher) {\n        var _this = _super.call(this, name) || this;\n        _this.dispatcher = null;\n        _this.dispatcher = dispatcher;\n        _this.types = types;\n        return _this;\n    }\n    Object.defineProperty(Union$$1.prototype, \"flags\", {\n        get: function () {\n            var result = TypeFlags$$1.Union;\n            this.types.forEach(function (type) {\n                result |= type.flags;\n            });\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Union$$1.prototype, \"shouldAttachNode\", {\n        get: function () {\n            return this.types.some(function (type) { return type.shouldAttachNode; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Union$$1.prototype.isAssignableFrom = function (type) {\n        return this.types.some(function (subType) { return subType.isAssignableFrom(type); });\n    };\n    Union$$1.prototype.describe = function () {\n        return \"(\" + this.types.map(function (factory) { return factory.describe(); }).join(\" | \") + \")\";\n    };\n    Union$$1.prototype.instantiate = function (parent, subpath, environment, value) {\n        return this.determineType(value).instantiate(parent, subpath, environment, value);\n    };\n    Union$$1.prototype.reconcile = function (current, newValue) {\n        return this.determineType(newValue).reconcile(current, newValue);\n    };\n    Union$$1.prototype.determineType = function (value) {\n        // try the dispatcher, if defined\n        if (this.dispatcher !== null) {\n            return this.dispatcher(value);\n        }\n        // find the most accomodating type\n        var applicableTypes = this.types.filter(function (type) { return type.is(value); });\n        if (applicableTypes.length > 1)\n            return fail(\"Ambiguos snapshot \" + JSON.stringify(value) + \" for union \" + this\n                .name + \". Please provide a dispatch in the union declaration.\");\n        return applicableTypes[0];\n    };\n    Union$$1.prototype.isValidSnapshot = function (value, context) {\n        if (this.dispatcher !== null) {\n            return this.dispatcher(value).validate(value, context);\n        }\n        var errors = this.types.map(function (type) { return type.validate(value, context); });\n        var applicableTypes = errors.filter(function (errorArray) { return errorArray.length === 0; });\n        if (applicableTypes.length > 1) {\n            return typeCheckFailure$$1(context, value, \"Multiple types are applicable for the union (hint: provide a dispatch function)\");\n        }\n        else if (applicableTypes.length === 0) {\n            return typeCheckFailure$$1(context, value, \"No type is applicable for the union\").concat(flattenTypeErrors$$1(errors));\n        }\n        return typeCheckSuccess$$1();\n    };\n    return Union$$1;\n}(Type$$1));\n/**\n * types.union(dispatcher?, types...) create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function of the form (snapshot) => Type.\n *\n * @export\n * @alias types.union\n * @param {(ITypeDispatcher | IType<any, any>)} dispatchOrType\n * @param {...IType<any, any>[]} otherTypes\n * @returns {IType<any, any>}\n */\nfunction union$$1(dispatchOrType) {\n    var otherTypes = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        otherTypes[_i - 1] = arguments[_i];\n    }\n    var dispatcher = isType$$1(dispatchOrType) ? null : dispatchOrType;\n    var types = isType$$1(dispatchOrType) ? otherTypes.concat(dispatchOrType) : otherTypes;\n    var name = \"(\" + types.map(function (type) { return type.name; }).join(\" | \") + \")\";\n    // check all options\n    if (process.env.NODE_ENV !== \"production\") {\n        types.forEach(function (type) {\n            if (!isType$$1(type))\n                fail(\"expected all possible types to be a mobx-state-tree type, got \" +\n                    type +\n                    \" instead\");\n        });\n    }\n    return new Union$$1(name, types, dispatcher);\n}\n\nvar OptionalValue$$1 = /** @class */ (function (_super) {\n    __extends(OptionalValue$$1, _super);\n    function OptionalValue$$1(type, defaultValue) {\n        var _this = _super.call(this, type.name) || this;\n        _this.type = type;\n        _this.defaultValue = defaultValue;\n        return _this;\n    }\n    Object.defineProperty(OptionalValue$$1.prototype, \"flags\", {\n        get: function () {\n            return this.type.flags | TypeFlags$$1.Optional;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(OptionalValue$$1.prototype, \"shouldAttachNode\", {\n        get: function () {\n            return this.type.shouldAttachNode;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    OptionalValue$$1.prototype.describe = function () {\n        return this.type.describe() + \"?\";\n    };\n    OptionalValue$$1.prototype.instantiate = function (parent, subpath, environment, value) {\n        if (typeof value === \"undefined\") {\n            var defaultValue = this.getDefaultValue();\n            var defaultSnapshot = isStateTreeNode$$1(defaultValue)\n                ? getStateTreeNode$$1(defaultValue).snapshot\n                : defaultValue;\n            return this.type.instantiate(parent, subpath, environment, defaultSnapshot);\n        }\n        return this.type.instantiate(parent, subpath, environment, value);\n    };\n    OptionalValue$$1.prototype.reconcile = function (current, newValue) {\n        return this.type.reconcile(current, this.type.is(newValue) ? newValue : this.getDefaultValue());\n    };\n    OptionalValue$$1.prototype.getDefaultValue = function () {\n        var defaultValue = typeof this.defaultValue === \"function\" ? this.defaultValue() : this.defaultValue;\n        if (typeof this.defaultValue === \"function\")\n            typecheck$$1(this, defaultValue);\n        return defaultValue;\n    };\n    OptionalValue$$1.prototype.isValidSnapshot = function (value, context) {\n        // defaulted values can be skipped\n        if (value === undefined) {\n            return typeCheckSuccess$$1();\n        }\n        // bounce validation to the sub-type\n        return this.type.validate(value, context);\n    };\n    OptionalValue$$1.prototype.isAssignableFrom = function (type) {\n        return this.type.isAssignableFrom(type);\n    };\n    return OptionalValue$$1;\n}(Type$$1));\n/**\n * `types.optional` can be used to create a property with a default value.\n * If the given value is not provided in the snapshot, it will default to the provided `defaultValue`.\n * If `defaultValue` is a function, the function will be invoked for every new instance.\n * Applying a snapshot in which the optional value is _not_ present, causes the value to be reset\n *\n * @example\n * const Todo = types.model({\n *   title: types.optional(types.string, \"Test\"),\n *   done: types.optional(types.boolean, false),\n *   created: types.optional(types.Date, () => new Date())\n * })\n *\n * // it is now okay to omit 'created' and 'done'. created will get a freshly generated timestamp\n * const todo = Todo.create({ title: \"Get coffee \"})\n *\n * @export\n * @alias types.optional\n */\nfunction optional$$1(type, defaultValueOrFunction) {\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isType$$1(type))\n            fail(\"expected a mobx-state-tree type as first argument, got \" + type + \" instead\");\n        var defaultValue = typeof defaultValueOrFunction === \"function\"\n            ? defaultValueOrFunction()\n            : defaultValueOrFunction;\n        var defaultSnapshot = isStateTreeNode$$1(defaultValue)\n            ? getStateTreeNode$$1(defaultValue).snapshot\n            : defaultValue;\n        typecheck$$1(type, defaultSnapshot);\n    }\n    return new OptionalValue$$1(type, defaultValueOrFunction);\n}\n\nvar optionalNullType = optional$$1(nullType$$1, null);\n/**\n * Maybe will make a type nullable, and also null by default.\n *\n * @export\n * @alias types.maybe\n * @template S\n * @template T\n * @param {IType<S, T>} type The type to make nullable\n * @returns {(IType<S | null | undefined, T | null>)}\n */\nfunction maybe$$1(type) {\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isType$$1(type))\n            fail(\"expected a mobx-state-tree type as first argument, got \" + type + \" instead\");\n        if (type === frozen$$1) {\n            fail(\"Unable to declare `types.maybe(types.frozen)`. Frozen already accepts `null`. Consider using `types.optional(types.frozen, null)` instead.\");\n        }\n    }\n    return union$$1(optionalNullType, type);\n}\n\nvar Late$$1 = /** @class */ (function (_super) {\n    __extends(Late$$1, _super);\n    function Late$$1(name, definition) {\n        var _this = _super.call(this, name) || this;\n        _this._subType = null;\n        _this.definition = definition;\n        return _this;\n    }\n    Object.defineProperty(Late$$1.prototype, \"flags\", {\n        get: function () {\n            return this.subType.flags | TypeFlags$$1.Late;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Late$$1.prototype, \"shouldAttachNode\", {\n        get: function () {\n            return this.subType.shouldAttachNode;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Late$$1.prototype, \"subType\", {\n        get: function () {\n            if (this._subType === null) {\n                this._subType = this.definition();\n            }\n            return this._subType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Late$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n        return this.subType.instantiate(parent, subpath, environment, snapshot);\n    };\n    Late$$1.prototype.reconcile = function (current, newValue) {\n        return this.subType.reconcile(current, newValue);\n    };\n    Late$$1.prototype.describe = function () {\n        return this.subType.name;\n    };\n    Late$$1.prototype.isValidSnapshot = function (value, context) {\n        return this.subType.validate(value, context);\n    };\n    Late$$1.prototype.isAssignableFrom = function (type) {\n        return this.subType.isAssignableFrom(type);\n    };\n    return Late$$1;\n}(Type$$1));\n/**\n * Defines a type that gets implemented later. This is useful when you have to deal with circular dependencies.\n * Please notice that when defining circular dependencies TypeScript isn't smart enough to inference them.\n * You need to declare an interface to explicit the return type of the late parameter function.\n *\n * @example\n *  interface INode {\n *       childs: INode[]\n *  }\n *\n *   // TypeScript is'nt smart enough to infer self referencing types.\n *  const Node = types.model({\n *       childs: types.optional(types.array(types.late<any, INode>(() => Node)), [])\n *  })\n *\n * @export\n * @alias types.late\n * @template S\n * @template T\n * @param {string} [name] The name to use for the type that will be returned.\n * @param {ILateType<S, T>} type A function that returns the type that will be defined.\n * @returns {IType<S, T>}\n */\nfunction late$$1(nameOrType, maybeType) {\n    var name = typeof nameOrType === \"string\" ? nameOrType : \"late(\" + nameOrType.toString() + \")\";\n    var type = typeof nameOrType === \"string\" ? maybeType : nameOrType;\n    // checks that the type is actually a late type\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!(typeof type === \"function\" && type.length === 0))\n            fail(\"Invalid late type, expected a function with zero arguments that returns a type, got: \" +\n                type);\n    }\n    return new Late$$1(name, type);\n}\n\nvar Frozen$$1 = /** @class */ (function (_super) {\n    __extends(Frozen$$1, _super);\n    function Frozen$$1() {\n        var _this = _super.call(this, \"frozen\") || this;\n        _this.shouldAttachNode = false;\n        _this.flags = TypeFlags$$1.Frozen;\n        return _this;\n    }\n    Frozen$$1.prototype.describe = function () {\n        return \"<any immutable value>\";\n    };\n    Frozen$$1.prototype.instantiate = function (parent, subpath, environment, value) {\n        // deep freeze the object/array only in dev mode\n        var finalValue = process.env.NODE_ENV !== \"production\" ? deepFreeze(value) : value;\n        // create the node\n        return createNode$$1(this, parent, subpath, environment, finalValue);\n    };\n    Frozen$$1.prototype.isValidSnapshot = function (value, context) {\n        if (!isSerializable(value)) {\n            return typeCheckFailure$$1(context, value, \"Value is not serializable and cannot be frozen\");\n        }\n        return typeCheckSuccess$$1();\n    };\n    return Frozen$$1;\n}(Type$$1));\n/**\n * Frozen can be used to story any value that is serializable in itself (that is valid JSON).\n * Frozen values need to be immutable or treated as if immutable. They need be serializable as well.\n * Values stored in frozen will snapshotted as-is by MST, and internal changes will not be tracked.\n *\n * This is useful to store complex, but immutable values like vectors etc. It can form a powerful bridge to parts of your application that should be immutable, or that assume data to be immutable.\n *\n * Note: if you want to store free-form state that is mutable, or not serializeable, consider using volatile state instead.\n *\n * @example\n * const GameCharacter = types.model({\n *   name: string,\n *   location: types.frozen\n * })\n *\n * const hero = GameCharacter.create({\n *   name: \"Mario\",\n *   location: { x: 7, y: 4 }\n * })\n *\n * hero.location = { x: 10, y: 2 } // OK\n * hero.location.x = 7 // Not ok!\n *\n * @alias types.frozen\n */\nvar frozen$$1 = new Frozen$$1();\n\nvar StoredReference = /** @class */ (function () {\n    function StoredReference(mode, value) {\n        this.mode = mode;\n        this.value = value;\n        if (mode === \"object\") {\n            if (!isStateTreeNode$$1(value))\n                return fail(\"Can only store references to tree nodes, got: '\" + value + \"'\");\n            var targetNode = getStateTreeNode$$1(value);\n            if (!targetNode.identifierAttribute)\n                return fail(\"Can only store references with a defined identifier attribute.\");\n        }\n    }\n    return StoredReference;\n}());\nvar BaseReferenceType$$1 = /** @class */ (function (_super) {\n    __extends(BaseReferenceType$$1, _super);\n    function BaseReferenceType$$1(targetType) {\n        var _this = _super.call(this, \"reference(\" + targetType.name + \")\") || this;\n        _this.targetType = targetType;\n        _this.flags = TypeFlags$$1.Reference;\n        return _this;\n    }\n    BaseReferenceType$$1.prototype.describe = function () {\n        return this.name;\n    };\n    BaseReferenceType$$1.prototype.isAssignableFrom = function (type) {\n        return this.targetType.isAssignableFrom(type);\n    };\n    BaseReferenceType$$1.prototype.isValidSnapshot = function (value, context) {\n        return typeof value === \"string\" || typeof value === \"number\"\n            ? typeCheckSuccess$$1()\n            : typeCheckFailure$$1(context, value, \"Value is not a valid identifier, which is a string or a number\");\n    };\n    return BaseReferenceType$$1;\n}(Type$$1));\nvar IdentifierReferenceType$$1 = /** @class */ (function (_super) {\n    __extends(IdentifierReferenceType$$1, _super);\n    function IdentifierReferenceType$$1(targetType) {\n        var _this = _super.call(this, targetType) || this;\n        _this.shouldAttachNode = true;\n        return _this;\n    }\n    IdentifierReferenceType$$1.prototype.getValue = function (node) {\n        if (!node.isAlive)\n            return undefined;\n        var ref = node.storedValue;\n        // id already resolved, return\n        if (ref.mode === \"object\")\n            return ref.value;\n        // reference was initialized with the identifier of the target\n        var target = node.root.identifierCache.resolve(this.targetType, ref.value);\n        if (!target)\n            return fail(\"Failed to resolve reference of type \" + this.targetType\n                .name + \": '\" + ref.value + \"' (in: \" + node.path + \")\");\n        return target.value;\n    };\n    IdentifierReferenceType$$1.prototype.getSnapshot = function (node) {\n        var ref = node.storedValue;\n        switch (ref.mode) {\n            case \"identifier\":\n                return ref.value;\n            case \"object\":\n                return getStateTreeNode$$1(ref.value).identifier;\n        }\n    };\n    IdentifierReferenceType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n        return createNode$$1(this, parent, subpath, environment, new StoredReference(isStateTreeNode$$1(snapshot) ? \"object\" : \"identifier\", snapshot));\n    };\n    IdentifierReferenceType$$1.prototype.reconcile = function (current, newValue) {\n        if (current.type === this) {\n            var targetMode = isStateTreeNode$$1(newValue) ? \"object\" : \"identifier\";\n            var ref = current.storedValue;\n            if (targetMode === ref.mode && ref.value === newValue)\n                return current;\n        }\n        var newNode = this.instantiate(current.parent, current.subpath, current._environment, newValue);\n        current.die();\n        return newNode;\n    };\n    return IdentifierReferenceType$$1;\n}(BaseReferenceType$$1));\nvar CustomReferenceType$$1 = /** @class */ (function (_super) {\n    __extends(CustomReferenceType$$1, _super);\n    function CustomReferenceType$$1(targetType, options) {\n        var _this = _super.call(this, targetType) || this;\n        _this.options = options;\n        _this.shouldAttachNode = false;\n        return _this;\n    }\n    CustomReferenceType$$1.prototype.getValue = function (node) {\n        if (!node.isAlive)\n            return undefined;\n        return this.options.get(node.storedValue, node.parent ? node.parent.storedValue : null);\n    };\n    CustomReferenceType$$1.prototype.getSnapshot = function (node) {\n        return node.storedValue;\n    };\n    CustomReferenceType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n        var identifier$$1 = isStateTreeNode$$1(snapshot)\n            ? this.options.set(snapshot, parent ? parent.storedValue : null)\n            : snapshot;\n        return createNode$$1(this, parent, subpath, environment, identifier$$1);\n    };\n    CustomReferenceType$$1.prototype.reconcile = function (current, snapshot) {\n        var newIdentifier = isStateTreeNode$$1(snapshot)\n            ? this.options.set(snapshot, current ? current.storedValue : null)\n            : snapshot;\n        if (current.type === this) {\n            if (current.storedValue === newIdentifier)\n                return current;\n        }\n        var newNode = this.instantiate(current.parent, current.subpath, current._environment, newIdentifier);\n        current.die();\n        return newNode;\n    };\n    return CustomReferenceType$$1;\n}(BaseReferenceType$$1));\n/**\n * Creates a reference to another type, which should have defined an identifier.\n * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.\n *\n * @export\n * @alias types.reference\n */\nfunction reference$$1(subType, options) {\n    // check that a type is given\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isType$$1(subType))\n            fail(\"expected a mobx-state-tree type as first argument, got \" + subType + \" instead\");\n        if (arguments.length === 2 && typeof arguments[1] === \"string\")\n            fail(\"References with base path are no longer supported. Please remove the base path.\");\n    }\n    if (options)\n        return new CustomReferenceType$$1(subType, options);\n    else\n        return new IdentifierReferenceType$$1(subType);\n}\n\nvar IdentifierType$$1 = /** @class */ (function (_super) {\n    __extends(IdentifierType$$1, _super);\n    function IdentifierType$$1(identifierType) {\n        var _this = _super.call(this, \"identifier(\" + identifierType.name + \")\") || this;\n        _this.identifierType = identifierType;\n        _this.shouldAttachNode = false;\n        _this.flags = TypeFlags$$1.Identifier;\n        return _this;\n    }\n    IdentifierType$$1.prototype.instantiate = function (parent, subpath, environment, snapshot) {\n        if (!parent || !isStateTreeNode$$1(parent.storedValue))\n            return fail(\"Identifier types can only be instantiated as direct child of a model type\");\n        if (parent.identifierAttribute)\n            fail(\"Cannot define property '\" + subpath + \"' as object identifier, property '\" + parent.identifierAttribute + \"' is already defined as identifier property\");\n        parent.identifierAttribute = subpath;\n        return createNode$$1(this, parent, subpath, environment, snapshot);\n    };\n    IdentifierType$$1.prototype.reconcile = function (current, newValue) {\n        if (current.storedValue !== newValue)\n            return fail(\"Tried to change identifier from '\" + current.storedValue + \"' to '\" + newValue + \"'. Changing identifiers is not allowed.\");\n        return current;\n    };\n    IdentifierType$$1.prototype.describe = function () {\n        return \"identifier(\" + this.identifierType.describe() + \")\";\n    };\n    IdentifierType$$1.prototype.isValidSnapshot = function (value, context) {\n        if (value === undefined ||\n            value === null ||\n            typeof value === \"string\" ||\n            typeof value === \"number\")\n            return this.identifierType.validate(value, context);\n        return typeCheckFailure$$1(context, value, \"Value is not a valid identifier, which is a string or a number\");\n    };\n    return IdentifierType$$1;\n}(Type$$1));\n/**\n * Identifiers are used to make references, lifecycle events and reconciling works.\n * Inside a state tree, for each type can exist only one instance for each given identifier.\n * For example there couldn't be 2 instances of user with id 1. If you need more, consider using references.\n * Identifier can be used only as type property of a model.\n * This type accepts as parameter the value type of the identifier field that can be either string or number.\n *\n * @example\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifier(types.string),\n *      title: types.string\n *  })\n *\n * @export\n * @alias types.identifier\n * @template T\n * @param {IType<T, T>} baseType\n * @returns {IType<T, T>}\n */\nfunction identifier$$1(baseType) {\n    if (baseType === void 0) { baseType = string$$1; }\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!isType$$1(baseType))\n            fail(\"expected a mobx-state-tree type as first argument, got \" + baseType + \" instead\");\n    }\n    return new IdentifierType$$1(baseType);\n}\n\n/**\n * All imports / exports should be proxied through this file.\n * Why? It gives us full control over the module load order, preventing circular dependency isses\n */\n\n/** all code is initially loaded through internal, to avoid circular dep issues */\n// tslint:disable-next-line:no_unused-variable\nvar types = {\n    enumeration: enumeration$$1,\n    model: model$$1,\n    compose: compose$$1,\n    reference: reference$$1,\n    union: union$$1,\n    optional: optional$$1,\n    literal: literal$$1,\n    maybe: maybe$$1,\n    refinement: refinement$$1,\n    string: string$$1,\n    boolean: boolean$$1,\n    number: number$$1,\n    Date: DatePrimitive$$1,\n    map: map$$1,\n    array: array$$1,\n    frozen: frozen$$1,\n    identifier: identifier$$1,\n    late: late$$1,\n    undefined: undefinedType$$1,\n    null: nullType$$1\n};\n\nexports.types = types;\nexports.typecheck = typecheckPublic$$1;\nexports.escapeJsonPath = escapeJsonPath$$1;\nexports.unescapeJsonPath = unescapeJsonPath$$1;\nexports.decorate = decorate$$1;\nexports.addMiddleware = addMiddleware$$1;\nexports.process = process$1$$1;\nexports.isStateTreeNode = isStateTreeNode$$1;\nexports.flow = flow;\nexports.applyAction = applyAction$$1;\nexports.onAction = onAction$$1;\nexports.recordActions = recordActions$$1;\nexports.createActionTrackingMiddleware = createActionTrackingMiddleware;\nexports.getType = getType$$1;\nexports.getChildType = getChildType$$1;\nexports.onPatch = onPatch$$1;\nexports.onSnapshot = onSnapshot$$1;\nexports.applyPatch = applyPatch$$1;\nexports.recordPatches = recordPatches$$1;\nexports.protect = protect$$1;\nexports.unprotect = unprotect$$1;\nexports.isProtected = isProtected$$1;\nexports.applySnapshot = applySnapshot$$1;\nexports.getSnapshot = getSnapshot$$1;\nexports.hasParent = hasParent$$1;\nexports.getParent = getParent$$1;\nexports.getRoot = getRoot$$1;\nexports.getPath = getPath$$1;\nexports.getPathParts = getPathParts$$1;\nexports.isRoot = isRoot$$1;\nexports.resolvePath = resolvePath$$1;\nexports.resolveIdentifier = resolveIdentifier$$1;\nexports.tryResolve = tryResolve$$1;\nexports.getRelativePath = getRelativePath$$1;\nexports.clone = clone$$1;\nexports.detach = detach$$1;\nexports.destroy = destroy$$1;\nexports.isAlive = isAlive$$1;\nexports.addDisposer = addDisposer$$1;\nexports.getEnv = getEnv$$1;\nexports.walk = walk$$1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/mobx-state-tree/dist/mobx-state-tree.js\n// module id = 996\n// module chunks = 0","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<p>以一个简单的 TodoList 应用为例，分别使用 <a href=\\\"https://github.com/mobxjs/mobx-state-tree\\\">Mobx State Tree</a> 和 React Mobx VM 来实现一下，这样对比起来更明显</p>\\n<div class=\\\"picidae-toc\\\">\\n<ul>\\n<li>\\n<a href=\\\"#mst-todolist\\\">MST TodoList</a>\\n</li>\\n<li>\\n<a href=\\\"#vm-todolist\\\">VM TodoList</a>\\n</li>\\n</ul>\\n</div>\\n<hr>\\n<h2 id=\\\"mst-todolist\\\"><a href=\\\"#mst-todolist\\\" aria-hidden=\\\"true\\\"><span class=\\\"icon icon-link\\\"></span></a>MST TodoList</h2>\\n<p>如需实现如下一个简单的 TodoList 应用，使用 MST（Mobx State Tree）应该如何书写呢？</p>\\n<ul>\\n<li>index.js</li>\\n</ul>\\n<div class=\\\"transformer-react-render-container\\\"><transformer-react-render data-id=\\\"0\\\"></transformer-react-render><pre><code class=\\\"hljs language-jsx\\\" data-query=\\\"{&#x22;editable&#x22;:true,&#x22;placement&#x22;:&#x22;top&#x22;}\\\" data-lang=\\\"jsx\\\"><span class=\\\"hljs-keyword\\\">import</span> { observable, computed } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> { observer } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx-react'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> * <span class=\\\"hljs-keyword\\\">as</span> React <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> { render } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-dom'</span>\\n\\n<span class=\\\"hljs-keyword\\\">import</span> { TodoStore } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'../snippets/mst/models/TodoStore'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> { TodoList } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'../snippets/mst/components/TodoList'</span>\\n<span class=\\\"hljs-comment\\\">// 注意：该以下代码可同步编辑</span>\\n<span class=\\\"hljs-keyword\\\">const</span> store = TodoStore.create({\\n  <span class=\\\"hljs-attr\\\">todos</span>: [\\n    {\\n      <span class=\\\"hljs-attr\\\">title</span>: <span class=\\\"hljs-string\\\">'Get Coffee'</span>\\n    },\\n    {\\n      <span class=\\\"hljs-attr\\\">title</span>: <span class=\\\"hljs-string\\\">'Write simpler code'</span>\\n    }\\n  ]\\n})\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> &#x3C;TodoList todoStore={store}/></code></pre></div>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> { types } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx-state-tree'</span>\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">const</span> Todo = types\\n  .model(<span class=\\\"hljs-string\\\">'Todo'</span>, {\\n    <span class=\\\"hljs-attr\\\">id</span>: types.optional(types.number, () => <span class=\\\"hljs-built_in\\\">Math</span>.random()),\\n    <span class=\\\"hljs-attr\\\">title</span>: types.string,\\n    <span class=\\\"hljs-attr\\\">finished</span>: <span class=\\\"hljs-literal\\\">false</span>\\n  })\\n  .actions(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">self</span> =></span> (\\n    {\\n      toggle() {\\n        self.finished = !self.finished\\n      }\\n    }\\n  ))\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">const</span> TodoStore = types\\n  .model(<span class=\\\"hljs-string\\\">'TodoStore'</span>, {\\n    <span class=\\\"hljs-attr\\\">todos</span>: types.array(Todo)\\n  })\\n  .views(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">self</span> =></span> (\\n    {\\n      get unfinishedTodoCount() {\\n        <span class=\\\"hljs-keyword\\\">return</span> self.todos.filter(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">todo</span> =></span> !todo.finished).length\\n      }\\n    }\\n  ))\\n  .actions(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">self</span> =></span> (\\n    {\\n      addTodo(title) {\\n        self.todos.push({ title })\\n      }\\n    }\\n  ))</code></pre>\\n<ul>\\n<li>../snippets/mst/components/TodoList.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> { observable } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> { observer } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx-react'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> * <span class=\\\"hljs-keyword\\\">as</span> React <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react'</span>\\n\\n<span class=\\\"hljs-keyword\\\">import</span> { Todo } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'./Todo'</span>\\n\\n@observer\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-class\\\"><span class=\\\"hljs-keyword\\\">class</span> <span class=\\\"hljs-title\\\">TodoList</span> <span class=\\\"hljs-keyword\\\">extends</span> <span class=\\\"hljs-title\\\">React</span>.<span class=\\\"hljs-title\\\">Component</span> </span>{\\n  @observable newTodoTitle = <span class=\\\"hljs-string\\\">''</span>\\n\\n  render() {\\n    <span class=\\\"hljs-keyword\\\">const</span> { todoStore } = <span class=\\\"hljs-keyword\\\">this</span>.props\\n    <span class=\\\"hljs-keyword\\\">return</span> (\\n      <span class=\\\"xml\\\"><span class=\\\"hljs-tag\\\">&#x3C;<span class=\\\"hljs-name\\\">div</span>></span>\\n        </span>&#x3C;input value={this.newTodoTitle} onChange={this.handleChange}/>\\n        &#x3C;button onClick={this.handleNewTodoClick}>Add&#x3C;/button>\\n        &#x3C;ul>\\n          {todoStore.todos.map(todo => &#x3C;Todo todo={todo} key={todo.id}/>)}\\n        &#x3C;/ul>\\n        Tasks left: {todoStore.unfinishedTodoCount}\\n      &#x3C;/div>\\n    )\\n  }\\n\\n  handleChange = (e) => {\\n    this.newTodoTitle = e.target.value\\n  }\\n\\n  handleNewTodoClick = (e) => {\\n    e.stopPropagation()\\n    this.props.todoStore.addTodo(this.newTodoTitle)\\n    this.newTodoTitle = ''\\n  }\\n}</code></pre>\\n<ul>\\n<li>../snippets/mst/components/Todo.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> { observer } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'mobx-react'</span>;\\n<span class=\\\"hljs-keyword\\\">import</span> * <span class=\\\"hljs-keyword\\\">as</span> React <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react'</span>;\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">const</span> Todo = observer(<span class=\\\"hljs-function\\\">(<span class=\\\"hljs-params\\\">{ todo }</span>) =></span>\\n  &#x3C;li>\\n    <span class=\\\"xml\\\"><span class=\\\"hljs-tag\\\">&#x3C;<span class=\\\"hljs-name\\\">input</span>\\n      <span class=\\\"hljs-attr\\\">type</span>=<span class=\\\"hljs-string\\\">\\\"checkbox\\\"</span>\\n      <span class=\\\"hljs-attr\\\">checked</span>=<span class=\\\"hljs-string\\\">{todo.finished}</span>\\n      <span class=\\\"hljs-attr\\\">onClick</span>=<span class=\\\"hljs-string\\\">{todo.toggle}</span>\\n    /></span>\\n    {todo.title}\\n  <span class=\\\"hljs-tag\\\">&#x3C;/<span class=\\\"hljs-name\\\">li</span>></span></span>,\\n);</code></pre>\\n<h2 id=\\\"vm-todolist\\\"><a href=\\\"#vm-todolist\\\" aria-hidden=\\\"true\\\"><span class=\\\"icon icon-link\\\"></span></a>VM TodoList</h2>\\n<ul>\\n<li>index.js</li>\\n</ul>\\n<div class=\\\"transformer-react-render-container\\\"><transformer-react-render data-id=\\\"1\\\"></transformer-react-render><pre><code class=\\\"hljs language-jsx\\\" data-query=\\\"{&#x22;editable&#x22;:true,&#x22;placement&#x22;:&#x22;top&#x22;}\\\" data-lang=\\\"jsx\\\"><span class=\\\"hljs-keyword\\\">import</span> ReactDOM <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-dom'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> { h } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-mobx-vm'</span>\\n\\n<span class=\\\"hljs-keyword\\\">import</span> TodoList <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'../snippets/vm/TodoList'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> Todo <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'../snippets/vm/Todo'</span>\\n<span class=\\\"hljs-comment\\\">// 注意：该以下代码可同步编辑</span>\\n<span class=\\\"hljs-keyword\\\">const</span> App = TodoList.create({\\n  <span class=\\\"hljs-attr\\\">todos</span>: [\\n    Todo.create({\\n      <span class=\\\"hljs-attr\\\">title</span>: <span class=\\\"hljs-string\\\">'Get Coffee'</span>\\n    }),\\n    Todo.create({\\n      <span class=\\\"hljs-attr\\\">title</span>: <span class=\\\"hljs-string\\\">'Write simpler code'</span>\\n    })\\n  ]\\n})\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> h(App)</code></pre></div>\\n<ul>\\n<li>../snippets/vm/TodoList/index.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> {\\n  Root,\\n  bindView,\\n  observable,\\n  computed,\\n  action\\n} <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-mobx-vm'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> View <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'./View'</span>\\n\\n<span class=\\\"hljs-keyword\\\">import</span> Todo <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'../Todo'</span>\\n\\n@bindView(View)\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> <span class=\\\"hljs-class\\\"><span class=\\\"hljs-keyword\\\">class</span> <span class=\\\"hljs-title\\\">TodoList</span> <span class=\\\"hljs-keyword\\\">extends</span> <span class=\\\"hljs-title\\\">Root</span> </span>{\\n  @observable todos = []\\n  @observable newTodoTitle = <span class=\\\"hljs-string\\\">''</span>\\n  @computed get unfinishedTodoCount() {\\n    <span class=\\\"hljs-keyword\\\">return</span> <span class=\\\"hljs-keyword\\\">this</span>.todos.filter(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">todo</span> =></span> !todo.finished).length\\n  }\\n  @action addTodo() {\\n    <span class=\\\"hljs-keyword\\\">this</span>.todos.push(Todo.create({ <span class=\\\"hljs-attr\\\">title</span>: <span class=\\\"hljs-keyword\\\">this</span>.newTodoTitle }))\\n  }\\n}</code></pre>\\n<ul>\\n<li>../snippets/vm/TodoList/View.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> { h, binding } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-mobx-vm'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> * <span class=\\\"hljs-keyword\\\">as</span> React <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react'</span>\\n\\n@binding\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> <span class=\\\"hljs-class\\\"><span class=\\\"hljs-keyword\\\">class</span> <span class=\\\"hljs-title\\\">TodoList</span> <span class=\\\"hljs-keyword\\\">extends</span> <span class=\\\"hljs-title\\\">React</span>.<span class=\\\"hljs-title\\\">Component</span> </span>{\\n\\n  render() {\\n    <span class=\\\"hljs-keyword\\\">const</span> todoStore = <span class=\\\"hljs-keyword\\\">this</span>.local\\n    <span class=\\\"hljs-keyword\\\">return</span> (\\n      <span class=\\\"xml\\\"><span class=\\\"hljs-tag\\\">&#x3C;<span class=\\\"hljs-name\\\">div</span>></span>\\n        </span>&#x3C;input data-bind=\\\"newTodoTitle\\\" />\\n        &#x3C;button onClick={this.handleNewTodoClick}>Add&#x3C;/button>\\n        &#x3C;ul>\\n          {todoStore.todos.map(todo => h(todo, { key: todo.id }))}\\n        &#x3C;/ul>\\n        Tasks left: {todoStore.unfinishedTodoCount}\\n      &#x3C;/div><span class=\\\"xml\\\">\\n    )\\n  }\\n\\n  handleNewTodoClick = (e) => {\\n    e.stopPropagation()\\n    this.local.addTodo(this.newTodoTitle)\\n    this.local.newTodoTitle = ''\\n  }\\n}</span></code></pre>\\n<ul>\\n<li>../snippets/vm/Todo/index.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> { Root, bindView, observable, action } <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-mobx-vm'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> View <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'./View'</span>\\n\\n@bindView(View)\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> <span class=\\\"hljs-class\\\"><span class=\\\"hljs-keyword\\\">class</span> <span class=\\\"hljs-title\\\">Todo</span> <span class=\\\"hljs-keyword\\\">extends</span> <span class=\\\"hljs-title\\\">Root</span> </span>{\\n  @observable id = <span class=\\\"hljs-built_in\\\">Math</span>.random()\\n  @observable title = <span class=\\\"hljs-string\\\">''</span>\\n  @observable finished = <span class=\\\"hljs-literal\\\">false</span>\\n  @action toggle() {\\n    <span class=\\\"hljs-keyword\\\">this</span>.finished = !<span class=\\\"hljs-keyword\\\">this</span>.finished\\n  }\\n}</code></pre>\\n<ul>\\n<li>../snippets/vm/Todo/View.js</li>\\n</ul>\\n<pre><code class=\\\"hljs language-javascript\\\" data-query=\\\"{}\\\" data-lang=\\\"javascript\\\"><span class=\\\"hljs-keyword\\\">import</span> {\\n  stateless\\n} <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react-mobx-vm'</span>\\n<span class=\\\"hljs-keyword\\\">import</span> * <span class=\\\"hljs-keyword\\\">as</span> React <span class=\\\"hljs-keyword\\\">from</span> <span class=\\\"hljs-string\\\">'react'</span>\\n\\n<span class=\\\"hljs-keyword\\\">export</span> <span class=\\\"hljs-keyword\\\">default</span> stateless(<span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">local</span> =></span>\\n  &#x3C;li>\\n    <span class=\\\"xml\\\"><span class=\\\"hljs-tag\\\">&#x3C;<span class=\\\"hljs-name\\\">input</span>\\n      <span class=\\\"hljs-attr\\\">type</span>=<span class=\\\"hljs-string\\\">\\\"checkbox\\\"</span>\\n      <span class=\\\"hljs-attr\\\">checked</span>=<span class=\\\"hljs-string\\\">{local.finished}</span>\\n      <span class=\\\"hljs-attr\\\">onClick</span>=<span class=\\\"hljs-string\\\">{local.toggle.bind(local)}</span>\\n    /></span>\\n    {local.title}\\n  <span class=\\\"hljs-tag\\\">&#x3C;/<span class=\\\"hljs-name\\\">li</span>></span></span>\\n)</code></pre>\\n\",\n  \"extra\": {},\n  \"transformer-react-render\": {\n    \"list\": [\n      [\n        \"function anonymous(React,Component,ReactDOM,require\\n) {\\n\\nvar exports = {}, module = {};\\nmodule.exports = exports;\\n(function picidaeTransformerReactRender(){Object.defineProperty(exports,\\\"__esModule\\\",{value:true});var _mobx=require(\\\"mobx\\\");var _mobxReact=require(\\\"mobx-react\\\");var _react=require(\\\"react\\\");var React=_interopRequireWildcard(_react);var _reactDom=require(\\\"react-dom\\\");var _TodoStore=require(\\\"../snippets/mst/models/TodoStore\\\");var _TodoList=require(\\\"../snippets/mst/components/TodoList\\\");function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))newObj[key]=obj[key]}}newObj.default=obj;return newObj}}// 注意：该以下代码可同步编辑\\nvar store=_TodoStore.TodoStore.create({todos:[{title:\\\"Get Coffee\\\"},{title:\\\"Write simpler code\\\"}]});exports.default=React.createElement(_TodoList.TodoList,{todoStore:store})})(exports, module)\\nreturn module.exports.default || module.exports;\\n}\",\n        {\n          \"editable\": true,\n          \"placement\": \"top\"\n        },\n        7\n      ],\n      [\n        \"function anonymous(React,Component,ReactDOM,require\\n) {\\n\\nvar exports = {}, module = {};\\nmodule.exports = exports;\\n(function picidaeTransformerReactRender(){Object.defineProperty(exports,\\\"__esModule\\\",{value:true});var _reactDom=require(\\\"react-dom\\\");var _reactDom2=_interopRequireDefault(_reactDom);var _reactMobxVm=require(\\\"react-mobx-vm\\\");var _TodoList=require(\\\"../snippets/vm/TodoList\\\");var _TodoList2=_interopRequireDefault(_TodoList);var _Todo=require(\\\"../snippets/vm/Todo\\\");var _Todo2=_interopRequireDefault(_Todo);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}// 注意：该以下代码可同步编辑\\nvar App=_TodoList2.default.create({todos:[_Todo2.default.create({title:\\\"Get Coffee\\\"}),_Todo2.default.create({title:\\\"Write simpler code\\\"})]});exports.default=(0,_reactMobxVm.h)(App)})(exports, module)\\nreturn module.exports.default || module.exports;\\n}\",\n        {\n          \"editable\": true,\n          \"placement\": \"top\"\n        },\n        5\n      ]\n    ],\n    \"pkg\": {\n      \"react\": require('react'),\n      \"react-dom\": require('react-dom'),\n      \"mobx\": require('mobx'),\n      \"mobx-react\": require('mobx-react'),\n      \"../snippets/mst/models/TodoStore\": require('/home/travis/build/be-fe/react-mobx-vm/_site/docs/snippets/mst/models/TodoStore.js'),\n      \"../snippets/mst/components/TodoList\": require('/home/travis/build/be-fe/react-mobx-vm/_site/docs/snippets/mst/components/TodoList.js'),\n      \"react-mobx-vm\": require('/home/travis/build/be-fe/react-mobx-vm'),\n      \"../snippets/vm/TodoList\": require('/home/travis/build/be-fe/react-mobx-vm/_site/docs/snippets/vm/TodoList/index.js'),\n      \"../snippets/vm/Todo\": require('/home/travis/build/be-fe/react-mobx-vm/_site/docs/snippets/vm/Todo/index.js')\n    }\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/picidae/lib/lib/loaders/markdown-loader!./docs/guide/contrast.md\n// module id = 1010\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/setimmediate/setImmediate.js\n// module id = 1113\n// module chunks = 0"],"sourceRoot":""}